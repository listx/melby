# Copyright 2023 Linus Arver
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#+title: Developer Manual
#+SETUPFILE: lilac.theme
#+PROPERTY: header-args :noweb no-export
#+OPTIONS: ^:{}
#+OPTIONS: H:5

* Tech stack

We use several programming languages: Elixir, Lua, Rust, and Haskell.

- *Elixir*: Elixir is the main language used in this project because of it
  leverages the famed Erlang runtime, known for its world-class reliability.
  Elixir is used for programming the base system, as well as testing all of the
  components together.
- *Lua*: Lua is used as our configuration language, because of its power and
  flexibility. Users must create a Lua configuration file in order to use Melby.
- *Rust*: Rust is used in some places where static typing and performance might
  come in handy. Typically it's used for smaller, pure (lacking side effects)
  functions.
- *Haskell*: Haskell is used for the Melby client binary =melbyc=, and also the
  =melbyr= rendering service. Haskell maximizes code maintainability and
  stability, and so it is the preferred language for building smaller
  independent components outside of the base (Elixir) system.

We also use [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]] (LP). To this end, we use Emacs Org mode
(=*.org= files) as the source of truth. These files are /tangled/ into the above
languages for the application binaries. These same files are /woven/ to produce
HTML files for documentation (what you are reading now). We use several
languages for weaving:

- *Emacs Lisp*: We use Emacs Lisp to tame Emacs Org mode for LP. Emacs Org mode
  is used for LP in this project because it is probably the most flexible and
  widely-used LP system out there. LaTeX + Noweb is another possibility, but it
  was not chosen because Org mode by default looks reasonable in plaintext.
- *TikZ*: [[https://en.wikipedia.org/wiki/PGF/TikZ][PGF/TikZ]] is used for writing all of the diagrams and figures used for
  documentation. This is because TikZ is extremely stable, powerful, and
  flexible for creating diagrams of all sorts. It is also able to produce SVG
  files, which are required to generate diagrams of the highest quality.
- *HTML/CSS*: HTML and CSS power the documentation. Although PDF output can be
  very beautiful, HTML is simply more accessible and also does not require code
  listings to be broken across multiple pages.

If you are interested in helping to contribute back to Melby, see [[file:developer-manual.html#h-Contributing-to-Melby]["Contributing
to Melby" in the Developer Manual]].

* Lay of the land

[[./image/architecture-overall.svg]]

Melby uses a client/server architecture. There are two main parts:

#+begin_sidenote
=melbyd= is the daemon, which acts as a server in the client/server
architecture. We call it a daemon because it is expected to have direct access
to the local machine which is relevant to the client. This is unlike typical web
servers where the local machine characteristics of such servers are irrelevant
to clients.
#+end_sidenote

1. =melbyd=: The daemon (server), which itself is composed of two smaller pieces:
   a. The controller written in Elixir and Rust.
   b. The viewer written in Haskell. This is a separate server in its own right
      (a microservice).
2. =melbyc=: The client, written in Haskell. The client sends a request and
   receives a "view".

You may notice that the two parts of =melbyd= are the controller and viewer.
These parts are named this way to refer to the common [[https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller][Model-View-Controller]]
(MVC) pattern. One unusual deviation from the MVC pattern is that the client is
fully responsible for sending in the "template" for the view, as well as asking
the daemon what kind of data (Model) it would like to work with. The client does
this by sending in a Lua script.

So the entire flow is:

1. User writes a Lua script to specify what pieces of information it wants, and
   how it should be presented.
2. =melbyc= sends this script to =melbyd= for processing.
3. The =melbyd= controller gathers the necessary data (e.g., Git status) and
   sends it to the =melbyd= viewer (Haskell service) for generating the final
   view.
4. The view is sent back to =melbyc=, which then prints it to STDOUT.

* Overview of this manual

The developer manual consists of multiple parts for the following areas:

- The build system for Literate Programming (LP), which explains how LP is used
  in this project as well as how each Melby component is used. You may skip this
  section if you are only interested in Melby's business logic.
- The build system for packaging Melby, which explains how Melby can be packaged
  up using the Nix Package Manager. This is useful for developing Melby locally
  (setting up a development environment).
- melbyc: an overview of the client program that queries =melbyd= for information,
  to be displayed in a shell prompt (or anywhere else).
- melbyd: an overview of the Elixir service that accepts requests from =melbyc=
  (the client). This is where most of the "meat" of Melby business logic resides,
  and is perhaps the most interesting. One key area here is the use of [[https://github.com/rvirding/luerl][Luerl]] to
  enable Melby configuration using the Lua programming language. This also
  includes an overview of the Haskell =melbyr= service that performs string/data
  transformation and manipulation.

Each of these parts are included separately under their own top-level heading
below and prefixed with =Developer Manual: ...=.

* Build System for Literate Programming

#+include: "build-literate.org" :lines "16-"

* Build System for Packaging Melby

** Introduction

We use Nix for the build system. Nix allows us to package up Melby into an
installabe software unit, or package, as well as provide us a development
environment capable of building Melby from scratch.

*** What we must build

There are several pieces of software we need to build (compile from source):

1. melbyc (Haskell)
2. melbyr (Haskell)
3. melbyd (Elixir)
4. melbyd Nifs (Rust)

** Development environment

Developing is intimately tied to releasing. And of course, development must come
first before we can release. And so we discuss the development environment here.

We use Nix to set up the environment.

*** Nix shell

This is taken from [[https://github.com/tweag/haskell-stack-nix-example/blob/b9383e35416a2b0e21fbc97ed079538f9f395b6a/shell.nix#L1][here]].

Note that we first have to do =nix-shell --pure= in Melby's toplevel directory,
then =cd= into =melbyc= and only from here we are able to do =stack exec -- ghci=
to see the right version of GHC.

This is the main development shell and brings in all of our dependencies to
build all of our code. It's great for development and testing things out (e.g.,
running unit tests) for all of the various languages we use.

#+caption: shell.nix (toplevel dev environment)
#+begin_src nix :tangle shell.nix :eval no
let
  # Nixpkgs snapshot.
  sources = import ./package/nix/sources.nix;
  # Overlays
  oxalica-rust-overlay = import sources.rust-overlay;
  # Build rust crates.
  naersk = final: prev: {
    naersk = pkgs.callPackage sources.naersk
      {
        inherit sources;
      };
    };
  # The final "pkgs" attribute with all the bells and whistles of our overlays.
  pkgs = import sources.nixpkgs {
    overlays = [
      oxalica-rust-overlay
      naersk
    ];
  };

  # Wrap Stack to configure Nix integration and target the correct Stack-Nix
  # file
  #
  # - nix: Enable Nix support (use Stack's built-in Nix integration; this makes
  #   Stack populate the "ghc" variable in our nix/stack.nix file with the GHC
  #   version found in the stack.yaml file; this way we don't have to specify a
  #   GHC version in Nix (when we already define it transitively through
  #   specifying Stack's LTS version in stack.yaml)). This also makes it so that
  #   ghci is not available in the nix-shell; rather it can only be accessed
  #   through "stack exec -- ghci".
  #
  # - nix-pure: Do not pass environment variables, like `NIX_PATH`
  #
  # - nix-shell-file: Specify the Nix file to use (otherwise it uses `shell.nix`
  #   by default)
  #
  # Vanilla (unwrapped) stack is available as `.stack-wrapped`, courtesy of
  # pkgs.symlinkJoin.
  stack-wrapped = pkgs.symlinkJoin {
    name = "stack";
    paths = [ pkgs.stack ];
    buildInputs = [ pkgs.makeWrapper ];
    postBuild = ''
      wrapProgram $out/bin/stack \
        --add-flags "\
          --nix \
          --nix-pure \
          --system-ghc \
          --no-install-ghc \
          --nix-shell-file=./stack.nix \
        "
    '';
  };

  protoc-gen-elixir = pkgs.callPackage ./package/protoc-gen-elixir.nix {};
  darwin-cargo-build-rustflags = pkgs.lib.attrsets.optionalAttrs pkgs.stdenv.isDarwin {
    CARGO_BUILD_RUSTFLAGS = "-C link-arg=-undefined -C link-arg=dynamic_lookup";
  };
  macOS-security =
    # Make `/usr/bin/security` available in `PATH`, which is needed for stack
    # on darwin which calls this binary to find certificates. See
    # https://github.com/tweag/rules_haskell/commit/31171a520f49f263895112678ac93c7ed958ead1.
    pkgs.writeScriptBin "security" ''exec /usr/bin/security "$@"'';
in

# This is our development shell.
pkgs.mkShell ({
  buildInputs = [
    # Haskell
    stack-wrapped
    # Let stack use Nix with the Nix we version here.
    pkgs.nix

    # Rust
    pkgs.rust-bin.stable.latest.default
    pkgs.rust-analyzer

    # Elixir
    pkgs.beam.packages.erlangR26.elixir
    pkgs.beam.packages.erlangR26.erlang # erl, escript
    pkgs.mix2nix

    # gRPC and Protocol Buffers
    pkgs.protobuf
    # Needed for running Elixir plugin for protoc. E.g., "protoc
    # --elixir_out=plugins=grpc:. foo.proto". We need to install
    # protoc-gen-elixir.
    protoc-gen-elixir

    # Tangling and weaving for Literate Programming.
    pkgs.emacs29-nox
    pkgs.inkscape
    pkgs.pdf2svg

    # For updating Nix dependencies.
    pkgs.niv

    # Misc
    pkgs.git
    pkgs.less
  ]
  # For file_system on Linux.
  ++ pkgs.lib.optional pkgs.stdenv.isLinux pkgs.inotify-tools
  # For file_system on macOS. See
  # https://elixirforum.com/t/could-not-compile-file-system-watcher-for-mac/17432/10
  # for a discussion about getting a file system watcher working on Mac.
  ++ pkgs.lib.optionals pkgs.stdenv.isDarwin (with pkgs.darwin.apple_sdk.frameworks; [
    CoreFoundation
    CoreServices
    Security
  ])
  ++ pkgs.lib.optionals pkgs.stdenv.isDarwin [
    # This allows mix2nix to be able to download hex packages using HTTPS, in a
    # `nix-shell --pure` environment. See
    # https://github.com/NixOS/nixpkgs/issues/66716#issuecomment-883399373.
    pkgs.cacert
    macOS-security
  ];

  # FIXME: how to get the git version into the environment...???? The setting below for MELBY_PROJECT_ROOT only works for the dev env, not the release env
  shellHook = ''
    # Prefer to use melbyr and melbyc from the local development tree path.
    export PATH=$PWD/daemon/test:$PWD/daemon/lib/melbyd/renderer:$PWD/client:$PATH
    export KUBECONFIG=$PWD/daemon/test/fake_kube_config
    export MELBY_DIR=$PWD/daemon/test/sample
    export MELBY_PROJECT_ROOT=$PWD
    export MELBYR_PATH=$PWD/daemon/lib/melbyd/renderer/melbyr
    export LUA_PATH="$PWD/daemon/test/sample/?.lua"
  '';

  # Configure the Nix path to our own `pkgs`, to ensure Stack-with-Nix uses the
  # correct one rather than the global <nixpkgs> when looking for the right
  # `ghc` argument to pass in `nix/stack.nix`
  #
  # See https://nixos.org/nixos/nix-pills/nix-search-paths.html for more
  # information.
  NIX_PATH = "nixpkgs=" + pkgs.path;

  # Make Elixir not complain about using "latin1" encoding.
  LANG = "C.UTF-8";
  LOCALE_ARCHIVE = pkgs.lib.optional pkgs.stdenv.isLinux
    "${pkgs.glibcLocales}/lib/locale/locale-archive";
} // darwin-cargo-build-rustflags)
#+end_src

**** Make Stack understand Nix

#+caption: package/nix/stack.nix
#+begin_src nix :tangle package/nix/stack.nix :eval no
let
  sources = import ./sources.nix;
  pkgs = import sources.nixpkgs { };
in

# See https://docs.haskellstack.org/en/stable/nix_integration/#using-a-custom-shellnix-file
#
# But basically this tells stack to figure out the GHC version by looking at
# stack.yaml (we have to have this file in $PWD from the current nix-shell
# session).
#
# This is really great because this means we can technically have different
# tools use different versions of GHC. So maybe one of the smaller, simpler
# tools can use the latest GHC with useful features and have that as a role
# model for the other Haskell binaries that are lagging behind on older GHC
# versions due to dependencies that have not yet upgraded to the newer version.
{ ghc }:

pkgs.haskell.lib.buildStackProject {
  inherit ghc;
  name = "melby";
  # System dependencies needed at compilation time
  buildInputs = [
    pkgs.zlib
  ];
}
#+end_src

** Packaging

*** Releasing

We use Nix to package everything up. The main thing to note here is that we
reuse the shell environment's sources (in =nix/sources.nix=) to make sure that
the development environment's dependencies exactly match what we'll end up
shipping.

#+caption: package/build.nix
#+begin_src nix :tangle package/build.nix :eval no
let
  sources = import ./nix/sources.nix;
  pkgs = import sources.nixpkgs {};
  # We have to explicitly choose GHC 8.10.7 because 9.0.2 is the default for
  # nixos-22.11 (which we don't want because the Stack version we use, LTS
  # 18.28, uses 8.10.7).
  hpg8107 = pkgs.haskell.packages.ghc8107;
  hpg96 = pkgs.haskell.packages.ghc96;
  melby-client = hpg8107.callPackage ../client/melby-client.nix {};
  melby-client-rust = pkgs.callPackage ../client-rust/melby-client-rust.nix {};
  # FIXME: We need to pass in a "version" attribute to all Haskell packages
  # because the default buildStackProject helper does not provide a version.
  # This means we need to start creating version strings, probably in the format
  # "YY.MM.DD-<sha>" to make it incremental.
  #melby-client-2 = (import melby-client-1) {};
  #melby-client-3 = pkgs.haskell.lib.addBuildTool melby-client-2 fakeGit;
  melby-renderer = hpg8107.callPackage ../daemon/lib/melbyd/renderer/melby-renderer.nix {};
  melby-daemon = pkgs.callPackage ../daemon/melby-daemon.nix {};
  melby-nifs = pkgs.callPackage ../daemon/lib/melbyd/nifs/melby-nifs.nix {};
in
  {
    inherit melby-client melby-client-rust melby-renderer melby-daemon melby-nifs;
  }
#+end_src

We can now install everything above with =nix-env -if ./release.nix=. Be sure to
run =systemctl --user daemon-reload= to load the =systemd= definition that comes
with =melby.service=, and run =systemctl --user start melby.service= to actually
start it.

#+caption: package/release.nix
#+begin_src nix :tangle package/release.nix :eval no
let
  sources = import ./nix/sources.nix;
  pkgs = import sources.nixpkgs {};
  melby = import ./build.nix;
in
  pkgs.symlinkJoin {
    name = "melby";
    paths = with melby; [
      melby-client
      melby-client-rust
      melby-renderer
      melby-daemon
    ];
    # If users have already installed individual packages already, make the ones
    # we bundle here act as a fallback. Default priority is 5, and so by setting
    # it to 10, makes Nix treat the files of this derivation as a fallback if
    # there is a conflict.
    meta.priority = 10;
  }
#+end_src

Additional steps:

Create a =~/.melby/systemd/env= file with the contents

FIXME: Add in "prod" settings here for MELBYR_PATH, MELBYR_PORT, and so on so as
to not conflict with the dev environment. Even better, add these settings in our
Elixir code so that the user does not (normally) have to configure them.

#+begin_example
RELEASE_COOKIE=path/to/cookie
#+end_example

Then populate =path/to/cookie= with a random text string like this:

#+begin_example
$ cd ~/.melby
$ openssl rand -base64 48 > cookie
$ chmod 600 cookie
#+end_example

*** Makefile

FIXME: reduce repetition by using a build rule (akin to run_emacs)

#+caption: package/Makefile
#+begin_src makefile :tangle package/Makefile

define run_build
	nix-build build.nix --option sandbox relaxed --show-trace \
		-A $(1) --out-link $(1)
endef

build:
	nix-build build.nix --option sandbox relaxed --show-trace

build-melby-client:
	$(call run_build,melby-client)

build-melby-client-rust:
	$(call run_build,melby-client-rust)

build-melby-daemon:
	$(call run_build,melby-daemon)

build-melby-nifs:
	$(call run_build,melby-nifs)

build-melby-renderer:
	$(call run_build,melby-renderer)

shell:
	nix-shell --pure

# Update nix/ folder to pin dependencies to nixos-23.11.
update-nix:
	niv update nixpkgs --branch nixos-23.11

.PHONY: build
.PHONY: build-melby-client
.PHONY: build-melby-client-rust
.PHONY: build-melby-renderer
.PHONY: build-melby-daemon
.PHONY: build-melby-nifs
.PHONY: shell
.PHONY: update-nix
#+end_src

*** .gitignore

#+caption: package/.gitignore
#+begin_src text :tangle package/.gitignore
melby-client
melby-client-rust
melby-nifs
melby-renderer
melby-daemon
result*
#+end_src
* How to hack on this project

First realize that this project uses literate programming. Because of this, you
must ensure that you can edit the Org files and make sure that those changes (to
the source code) can get tangled into source code locations for the various
compilers (=ghc=, =elixir=, etc) can consume.

The next most important thing is making sure that the =shell.nix= file at the
project root works (such that running =make shell= works). Run =make shell= to
enter the development environment.

You then need to stand up each individual Melby component.

** Building each component

*** =melbyr= (renderer; required by daemon)

#+begin_example
cd daemon/lib/melbyd/renderer; make
#+end_example

*** =melbyd= (daemon)

#+begin_example
cd daemon && make
#+end_example

And then to run the daemon, do

#+begin_example
cd daemon && make run_dev
#+end_example

There is also a =run-prod= rule but this won't work if you are already running a
packaged version of =melbyd= in your system, because they will both try to use
the same TCP port. So in that case you have to first stop the packaged version
you are running.

** =melbyc= (client)

#+begin_example
cd client; make
#+end_example

For invoking =melbyc= after building it, the simplest thing to do is to use the
provided =preview.sh= script in [[file:daemon/test/preview.sh][=daemon/test/preview.sh=]]. This script sets up
all necessary environment variables.

Note that currently the script uses a fake =kubectl=, because we don't want to
bother standing up a real Kubernetes instance in order to just test how
the real =kubectl= would behave. The script hardcodes the path to =melbyc= so
that it refers to the one that has been compiled inside the development
environment.

** Testing local changes

FIXME: How to do testing? What about integration tests? How to invoke tests? =mix test=?

** Common scenarios

*** Hacking on the Lua config

Make sure to use fakes, and to add validation tests. FIXME show examples.

* melbyc

We first examine the client to get a sense of how things work from the
perspective of the human user, who is expected to invoke =melbyc= somewhere in
their shell prompt generation logic. We then look at the pieces in the daemon to
see how it all works.

** Purpose

=melby-client= is a client for Melby. It allows users to interact with melby (the
daemon).

** Architectural overview

(Insert diagram --- write tikz and export as SVG.)

** Design by contract

We would like our client to observe the following behaviors.

1. Allow users to talk to the daemon.
2. Run very quickly (the synchronous call to the daemon should finish in under
   500 milliseconds).
3. Have basic command-line argument handling.

These points are the main things (or problems) that our program has to worry
about. We look at each of these requirements below.

*** Talking to the daemon

We talk to melbyd using gRPC. This is rather straightforward as it just involves
a single unary (that is, non-streaming) gRPC call.

**** Lua

The more interesting thing here is that we send melbyd some Lua code to give the
user the flexibility of determining exactly how to construct the prompt. This
way, the user is not stuck with only the default "look" of the pieces of the
prompt (the user can do more than just rearrange these pieces --- they can
customizes the pieces themselves). To this

**** Proto

For concreteness, this is the actual protobuf file we use to define melbyc's
behavior when it talks to the daemon.

This is the protobuf definition that we need to generate the Haskell client
stub. We also use it to generate the Elixir server stubs (used by the daemon).
FIXME: add link to where it's used in Elixir.

#+name: melbyproto_melby_client
#+begin_src protobuf :tangle melby_client.proto
syntax = "proto3";

package melby_client;

// melbyc <-> melbyd communication
service View {
  rpc GetView (ViewRequest) returns (ViewResponse);
}

message ViewRequest {
  // Path to Lua configuration. Delegates reading the config to the daemon.
  string config_path = 1;

  // Lua configuration that is given directly. Currently unusued by the daemon.
  string config = 2;

  // Environment variables ((name, value) pairs) of interest.
  map<string, string> env_vars = 3;

  // Process ID number of the running (interactive) shell program. (FIXME: move
  // this to env var)
  string shell_pid = 4;
}

message ViewResponse {
  // Status of this response message.
  ViewStatus status = 1;

  // String result of running Lua script.
  string view = 2;

  // Error message from melbyd, if any.
  string error = 3;
}

enum ViewStatus {
  VIEW_STATUS_UNSPECIFIED = 0;
  VIEW_STATUS_ERROR = 1;
  VIEW_STATUS_OK = 2;
}
#+end_src

*** Running very quickly

We don't want the client to block too long, because it is expected to be called
as often as every second (or even more often if Zsh ever offers sub-1-second
delay with the =TMOUT= variable).

The basic way we ensure this is that we make melbyd return whatever it has
without waiting for any of its internal calculations to finish.

Because this is a daemon-side concern, there isn't much for us to do here.

*** Command line argument handling

This is somewhat "boring" and we actually don't have much to design here. Much
of the choices here depend heavily on the command line argument parsing library
that we will be using.

** Code overview

This walkthrough is written for the future maintainers of this codebase.

*** Overall structure

All of the business logic lies in the =melby-client.hs= file, which has the
following structure:

#+name: melbyc-melby-client.hs
#+caption: Layout of =melby-client.hs=
#+begin_src haskell :tangle client/melby-client.hs
__NREF__melbyc_pragmas

module Main where

__NREF__melbyc_imports
__NREF__melbyc_business_logic
__NREF__melbyc_option_handling
__NREF__melbyc_main
#+end_src

The more interesting bits are in the =<<business-logic>>= section, which
actually performs the gRPC call to melbyd. Everything else is mostly boilerplate
code.

We'll look at the business logic first, and then all of the other boilerplate
code.

** Business logic

Recall in section FIXME that we said we wanted to pass in some Lua code. So
that's basically what we do here --- we pass in a gRPC connection and a filepath
to the Lua script we want to send to melbyd. We do this in the =getView=
function.

#+name: __NREF__melbyc_business_logic
#+begin_src haskell
__NREF__melbyc_getView
#+end_src

Now let's construct the =getView= function.

#+name: __NREF__melbyc_getView
#+begin_src haskell
getView :: GRpcConnection View 'MsgProtoBuf -> FilePath -> T.Text -> Int -> IO ()
getView conn configPath' config' shell_pid' = do
  __NREF__melbyc_getView_construct_payload
  __NREF__melbyc_getView_call_melbyd
  __NREF__melbyc_getView_handle_payload
#+end_src

Below we construct a gRPC message payload (request) for melbyd.

#+name: __NREF__melbyc_getView_construct_payload
#+begin_src haskell
env_vars_str <- getEnvironment
let env_vars' = M.fromList $ map (\(k, v) -> (T.pack k, T.pack v)) env_vars_str
    req = toSchema $ MViewRequest
      { config_path = T.pack configPath'
      , config = config'
      , env_vars = env_vars'
      , shell_pid = T.pack $ show shell_pid'
      }
#+end_src

We then make the remote procedure call. There's some lens magic here, but the
important thing is that we call the =GetView= method by passing it the =req= as
an argument. We use the capitalized =GetView= instead of =getView= because the
capitzalized version is the suggested style for protocol buffers according to
https://developers.google.com/protocol-buffers/docs/style#services.
Unfortunately, we cannot use =#GetVrompt= (just like we would use =#getVrompt=,
the uncapitalized version) and so must instead do =fromLabel @"GetView"= because
capitalized words have a special meaning in Haskell. See
https://github.com/higherkindness/mu-haskell/issues/337#issuecomment-1243874126.

#+name: __NREF__melbyc_getView_call_melbyd
#+begin_src haskell
response <- conn ^. fromLabel @"GetView" $ req
#+end_src

For now we don't really care if the call to melbyd did not succeed and crash if
the response was not successfully completed. That's why we only pattern match
against =GRpcOk=.

=term= here is a mu-haskell type that can be converted into a Haskell type, as
below. However, the term itself is useful because we can use various "optics"
functions, such as =^.=.

Lastly we need to render the view to the user from the response.

#+name: __NREF__melbyc_getView_handle_payload
#+begin_src haskell
let term = case response of
      GRpcOk a -> Right a
      x -> Left $ T.pack ("unrecognized daemon response: " <> (show x))
case term of
  Left err -> do
    T.hPutStrLn stderr err
    exitFailure
  Right a -> do
    let viewResponse = fromSchema a :: MViewResponse
    case status viewResponse of
      VIEW_STATUS_UNSPECIFIED -> do
        T.hPutStrLn stderr ("VIEW_STATUS_UNSPECIFIED")
        exitFailure
      VIEW_STATUS_ERROR -> do
        T.hPutStrLn stderr ("encountered error: " <> getField @"error" viewResponse)
        exitFailure
      VIEW_STATUS_OK -> do
        T.putStrLn $ getField @"view" viewResponse
#+end_src

That's it! We are done printing to STDOUT and the shell program (or whatever
else) that is calling us can make use of this information. A primary use case is
making =getView= output a shell script itself (such as variable assignments)
that can be sourced by the shell. This way all that the shell has to do is
something like:

#+name: example
#+caption: Example usage of =melbyc= from your shell's configuration.
#+begin_src shell
source "$(melbyc view PATH_TO_LUA_CONFIG)"
#+end_src

** Boilerplate

*** Option handling

#+name: __NREF__melbyc_option_handling
#+begin_src haskell
__NREF__melbyc_option_handling_types
__NREF__melbyc_option_handling_parsers
__NREF__melbyc_option_handling_dispatcher
#+end_src

The types here are what we read in from the command line.

#+name: __NREF__melbyc_option_handling_types
#+begin_src haskell
data Opts = Opts
  { subcommand :: Subcommand
  , oMelbydPort :: PortNumber
  }

data Subcommand
  = View ViewOpts
  | Ping
  | Shutdown

data ViewOpts = ViewOpts
  { oConfigPath :: FilePath
  , oConfig :: T.Text
  , oShellPid :: Int
  }
#+end_src

The parsers here determine how the types we defined above are accepted on the
command line. For the user, this is the help message they see so that they know
how to provide the right arguments to ensure that we get the correct types.

#+name: __NREF__melbyc_option_handling_parsers
#+begin_src haskell
optionsP :: Parser Opts
optionsP = Opts
  <$> subcommandP
  <*> (option auto (long "melbyd-port"
                    <> help "port for melbyd (e.g., 50052 for dev environmont))"
                    <> showDefault <> value 50051 <> metavar "PORT"))

subcommandP :: Parser Subcommand
subcommandP = hsubparser
  (  command "view" (info
                     (View <$> viewOptsP)
                     (progDesc "get prompt information with Lua"))
  <> command "ping" (info
                     (pure Ping) (progDesc "Check melbyd connectivity"))
  <> command "shutdown" (info
                         (pure Shutdown)
                         (progDesc "Shut down melbyd instance"))
  <> metavar "SUBCOMMAND"
  )

viewOptsP :: Parser ViewOpts
viewOptsP
  = ViewOpts
  <$> (argument str (metavar "FILEPATH"))
  <*> (option auto (long "config"
                    <> help "raw Lua string" <> showDefault <> value ""
                    <> metavar "LUA_CONFIG_RAW"))
  <*> (option auto (long "shell-pid"
                    <> help "PID of invoking shell (in most shells this is '$$')"
                    <> showDefault <> value 0 <> metavar "PID"))

#+end_src

Lastly, =optsHandler= is where we send the types that we've constructed (after a
successful parse of command line arguments) to the business logic.

#+name: __NREF__melbyc_option_handling_dispatcher
#+begin_src haskell
optsHandler :: Opts -> IO ()
optsHandler (Opts subcommand' oMelbydPort') = do
  -- FIXME: configure the domain and port to be configurable through TOML or
  -- yaml in a shared location with the daemon. The daemon should configure its
  -- port with it. The precedence of settings (where later mechanisms override
  -- earlier ones) is: (1) the configuration file (in TOML) converted to a
  -- native Haskell type (with sane defaults) with tomland
  -- (https://kowainik.github.io/posts/2019-01-14-tomland), (2) command-line
  -- options that are passed in at runtime.
  Right viewClient <- initGRpc (grpcClientConfigSimple
                                 "127.0.0.1" oMelbydPort' False) msgProtoBuf
  --home <- T.pack <$> getEnv "HOME"
  case subcommand' of
    View o -> do
      getView viewClient (oConfigPath o) (oConfig o) (oShellPid o)
    Ping -> putStrLn "not implemented"
    Shutdown -> putStrLn "not implemented"
#+end_src

*** Main

#+name: __NREF__melbyc_main
#+begin_src haskell
main :: IO ()
main = do
  opts <- customExecParser (prefs showHelpOnEmpty) optsP
  optsHandler opts
  where
  optsP = info parserProgramOptions infoMod
  parserProgramOptions = helper
    <*> versionOption
    <*> optionsP
  infoMod = fullDesc
    <> header "melbyc - CLI for interacting with the melby daemon (melbyd)"
  __NREF__melbyc_gitVersion
#+end_src

*** gRPC schema

This is the code that helps melbyc understand how to encode and decode the raw
bytes that are used for communication with melbyd (an Elixir application). This
is usally autogenerated when you're using a gRPC stack (via built-in language
support from the =protoc= binary, a.k.a. the protobuf compiler). However the
Haskell library we use asks us to define these types, so we do that here. This
isn't that much work, and although it reads like autogenerated code, it is easy
enough to understand (thanks to how terse Haskell can be).

We define this in a separate file so that it can be reused by other programs,
namely the =melbyd-lens= Haskell service that runs as part of melbyd.

FIXME: break this up into smaller chunks

#+name: melbyc_lib_schema
#+begin_src haskell :tangle client/lib/MelbyClient/Schema.hs
{-# language CPP                   #-}
{-# language DataKinds             #-}
{-# language DeriveAnyClass        #-}
{-# language DeriveGeneric         #-}
{-# language DerivingVia           #-}
{-# language DuplicateRecordFields #-}
{-# language FlexibleContexts      #-}
{-# language FlexibleInstances     #-}
{-# language MultiParamTypeClasses #-}
{-# language OverloadedLabels      #-}
{-# language PolyKinds             #-}
{-# language TemplateHaskell       #-}
{-# language TypeFamilies          #-}
{-# language TypeOperators         #-}

module MelbyClient.Schema where

import qualified Data.Text as T
import qualified Data.Map.Strict as M
import GHC.Generics

import Mu.Quasi.GRpc
import Mu.Schema

grpc "MelbyClientSchema" id "lib/MelbyClient/melby_client.proto"

-- The "M" prefix for the types here is for "Message" as in a gRPC "message"
-- type.

data MViewRequest = MViewRequest
  { config_path :: T.Text
  , config :: T.Text
  , env_vars :: M.Map T.Text T.Text
  , shell_pid :: T.Text
  } deriving (Eq, Show, Ord, Generic
             , ToSchema MelbyClientSchema "ViewRequest"
             , FromSchema MelbyClientSchema "ViewRequest")

data MViewResponse = MViewResponse
  { status :: MViewStatus
  , view :: T.Text
  , error :: T.Text
  } deriving (Eq, Ord, Show, Generic
             , ToSchema MelbyClientSchema "ViewResponse"
             , FromSchema MelbyClientSchema "ViewResponse")

data MViewStatus
  = VIEW_STATUS_UNSPECIFIED
  | VIEW_STATUS_ERROR
  | VIEW_STATUS_OK
  deriving (Eq, Ord, Show, Generic
             , ToSchema MelbyClientSchema "ViewStatus"
             , FromSchema MelbyClientSchema "ViewStatus")
#+end_src

*** Other
**** Pragmas

The language pragmas are not that interesting, as their purpose is to basically
turn on the various GHC extensions that allow us to use the libraries we use.

#+name: __NREF__melbyc_pragmas
#+begin_src haskell
{-# language DataKinds #-}
{-# language OverloadedLabels #-}
{-# language OverloadedStrings #-}
{-# language ScopedTypeVariables #-}
{-# language TemplateHaskell #-}
{-# language TypeApplications #-}
#+end_src

**** Imports

#+name: __NREF__melbyc_imports
#+begin_src haskell
import Data.Map.Strict qualified as M
import Data.Text qualified as T
import Data.Text.IO qualified as T
import Data.Version (showVersion)
import GHC.OverloadedLabels (fromLabel)
import GHC.Records (getField)
import Mu.GRpc.Client.Optics
import Mu.Schema (fromSchema, toSchema)
import Network.Socket (PortNumber)
import Options.Applicative
import System.Environment (getEnvironment)
import System.Exit (exitFailure)
import System.IO (stderr)

import Paths_melby_client (version)
import MelbyClient.GitVersion
import MelbyClient.Schema
#+end_src

**** Git versioning

We want to store the git hash of the project into the melbyc binary itself (this
is just good practice). The part we do the storing in the binary is done below,
as part of the =<<main>>= block of code:

#+name: __NREF__melbyc_gitVersion
#+begin_src haskell
versionOption = infoOption
  (concat [showVersion version, "-g", $(gitVersion)])
  (long "version" <> short 'v' <> help "Show version")
#+end_src

The underlying plumbing that handles this is done in FIXME path:

#+name: melbyc_lib_gitVersion
#+begin_src haskell :tangle client/lib/MelbyClient/GitVersion.hs
module MelbyClient.GitVersion
  ( gitVersion
  ) where

import Data.Time.LocalTime
import Language.Haskell.TH
import System.Environment
import System.Process

-- Adapted from
-- https://stackoverflow.com/questions/5713418/templatehaskell-and-io#comment7962237_5713551
-- and https://stackoverflow.com/a/20871010/437583.

gitVersion :: Q Exp
gitVersion = stringE =<< runIO getCombinedInfo

getCombinedInfo :: IO String
getCombinedInfo = do
  gi <- getGitInfo
  ti <- getTimeInfo
  pure $ concat [gi, "  (", ti, ")"]

getGitInfo :: IO String
getGitInfo = do
  -- We can't use the convenient "tGitInfoCwd" function from the GitHash package
  -- because it uses the current directory (and if we are built by cabal, we're
  -- not in the actual source directory but a copy of it in a sandboxed folder).
  -- The "tGitInfo" function is parameterized to take arbitrary paths, but it's
  -- difficult to customize its behavior. Because of this we just invoke git
  -- with our own flags, because it's pretty easy to do so.
  --
  -- Anyway, the point of MELBY_PROJECT_ROOT is so that we can set this
  -- environment variable when we invoke cabal, so that we can read it back out
  -- here. This way we can pass in environment variables to Template Haskell
  -- (compile-time code).
  maybeProjectRoot <- lookupEnv "MELBY_PROJECT_ROOT"
  case maybeProjectRoot of
    Just projectRoot -> readProcess "git"
      [ "-C"
      , projectRoot
      , "describe"
      , "--abbrev=10"
      , "--always"
      , "--dirty"
      ] ""
    Nothing -> pure "-unknown"

getTimeInfo :: IO String
getTimeInfo = show <$> getZonedTime
#+end_src

** Build system

*** Makefile

#+begin_src makefile :tangle client/Makefile
# NOTE: Below is an installation rule for a Nix + Cabal workflow. It may be
# useful to do this in case stack doesn't work for some reason. Originally we
# wanted to use this workflow instead but ran up against a Nix + MacOS breakage
# (https://github.com/NixOS/nixpkgs/pull/149942). Currently only stack works, so
# that's what we use. It may be the case though that we end up using stack
# long-term, because of its stability guarantees.
#
#       MELBY_PROJECT_ROOT=$(PWD) cabal install --overwrite-policy=always

# Let stack be aware of NixOS's non-standard library paths. This is an
# alternative to specifying the `nix:` field in stack.yaml directly (we just
# want to use a plain stack.yaml that is not aware of NixOS so that we can use
# the same stack.yaml file on non-NixOS distributions including MacOS).
ZLIB_SO_DIR=$(shell pkg-config --libs-only-L zlib)
ZLIB_H_DIR=$(shell pkg-config --cflags-only-I zlib)

all: melbyc

melbyc:
	MELBY_PROJECT_ROOT=$(PWD) stack build \
		--copy-bins \
		--local-bin-path $(PWD) \
		--no-nix-pure \
		--extra-lib-dirs=$(ZLIB_SO_DIR:-L%=%) \
		--extra-include-dirs=$(ZLIB_H_DIR:-I%=%)
.PHONY: melbyc

ghci:
	stack exec -- ghci
.PHONY: ghci
#+end_src

It's OK if =MELBY_PROJECT_ROOT= isn't actually the Melby project root directory,
because Git will still figure out how to run =git describe=. We just use
=MELBY_PROJECT_ROOT= here to be consistent with the Makefile (FIXME: link) for
=melby-renderer=.

*** Cabal

#+name: melby-client.cabal
#+begin_src haskell-cabal :tangle client/melby-client.cabal
name: melby-client
version: 1.0.0.0
author: Linus Arver
maintainer: linusa@google.com
category: Utility
build-type: Simple
cabal-version: >=1.10
license: Apache-2.0
license-file: LICENSE
data-files: lib/MelbyClient/melby_client.proto

executable melbyc
  main-is: melby-client.hs
  default-language: Haskell2010
  other-modules:
    Paths_melby_client
  default-extensions:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  ghc-options:
    -O2 -Werror -threaded -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  build-depends:
      base >= 4.8
    , melby-client
    , aeson
    , bytestring
    , conduit >= 1.3.2 && <2
    , containers
    , http-client
    , mu-grpc-client >=0.3.0.0
    , mu-optics >=0.3.0.0
    , mu-protobuf >= 0.4.0
    , mu-rpc >= 0.4.0
    , mu-schema >= 0.3.0
    , optparse-applicative >= 0.16.1.0
    , network >= 3.1.1.1
    , swagger2
    , text >=1.2 && <2
    , unordered-containers >= 0.2.16.0

library
  default-language: Haskell2010
  exposed-modules:
    MelbyClient.GitVersion
    MelbyClient.Schema
  hs-source-dirs:
    lib
  default-extensions:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  ghc-options:
    -O2 -Werror -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  build-depends:
      base >= 4.8
    , aeson
    , bytestring
    , containers
    , mu-protobuf >= 0.4.0
    , mu-schema >= 0.3.0
    , process
    , template-haskell
    , text >=1.2 && <2
    , time
#+end_src

#+name: =cabal.project=
#+begin_src haskell-cabal :tangle client/cabal.project
executable-stripping: True
packages:
  ./melby-client.cabal
#+end_src

*** melbyc.nix

We use Stack for building our Haskell binaries. The biggest reason we do this is
simply because Stack's LTS snapshots stay frozen, whereas Nix keeps evolving to
support the latest and greatest packages.

#+begin_src nix :tangle client/melby-client.nix
let
  sources = import ../package/nix/sources.nix;
  pkgs = import sources.nixpkgs { };
  # Nix never copies the .git directory as input to generate a derivation,
  # because Git's .git directory is not deterministic. So we never have a Git
  # directory, which means any "use git to derive the version" command will
  # fail. One way around this is to fetch a previous version of this repo (using
  # fetchGit) and then use the revision there as an output here using string
  # interpolation. We then make this fake Git script take precedence over the
  # vanilla git binary, tricking our version generation code. See
  # https://jeancharles.quillet.org/posts/2022-04-22-Embed-the-git-hash-into-a-binary-with-nix.html
  # and
  # https://discourse.nixos.org/t/accessing-git-directory-in-flake-with-local-source/17370/7.
  fakeGit = pkgs.writeShellScriptBin "git"
  ''
    echo -unknown
  '';
  files = [
    ./LICENSE
    ./cabal.project
    ./lib
    ./lib/MelbyClient
    ./lib/MelbyClient/GitVersion.hs
    ./lib/MelbyClient/melby_client.proto
    ./lib/MelbyClient/Schema.hs
    ./melby-client.cabal
    ./melby-client.hs
    ./melby-client.nix
    ./stack.yaml
    ./stack.yaml.lock
  ];
  macOS-security =
    # Make `/usr/bin/security` available in `PATH`, which is needed for stack
    # on darwin which calls this binary to find certificates. See
    # https://github.com/tweag/rules_haskell/commit/31171a520f49f263895112678ac93c7ed958ead1.
    pkgs.writeScriptBin "security" ''exec /usr/bin/security "$@"'';
in

# When we tell  See https://docs.haskellstack.org/en/stable/nix_integration/#using-a-custom-shellnix-file.
{ ghc }:

pkgs.haskell.lib.buildStackProject {
  inherit ghc;
  name = "melby-client";
  src = builtins.path {
    name = "melby-client";
    path = ./.;
    filter = path: type: builtins.elem (/. + path) files;
  };
  # System dependencies needed at compilation time.
  buildInputs = [
    pkgs.zlib
    fakeGit
  ]
  # See
  # https://www.reddit.com/r/haskell/comments/rjm0x8/help_wanted_for_llvm_config_for_haskell_on_mac/
  # about needing a version of LLVM < 13 on Mac.
  ++ pkgs.lib.optionals pkgs.stdenv.isDarwin [pkgs.llvm_10 macOS-security];
}
#+end_src

*** Stack

#+caption: client/stack.yaml
#+begin_src yaml :tangle client/stack.yaml
resolver: lts-18.28
allow-newer: true

packages:
- .

extra-deps:
- compendium-client-0.2.1.1@sha256:cd477438d507273b34b82581ade333921ae997c1618b48af0c1da2a4968623e0,1203
- graphql-1.0.3.0
- http2-2.0.6
- http2-client-0.10.0.0
- http2-client-grpc-0.8.0.0
- http2-grpc-proto3-wire-0.1.0.0
- http2-grpc-types-0.5.0.0
- hw-kafka-conduit-2.7.0
- mu-avro-0.4.0.4@sha256:10e317c633c5152a26e89becba749456b76f70eb640d1c0b2ccdc0e45a7ef5da,2096
- mu-grpc-client-0.4.0.2@sha256:cc98a09601b9634531772b270fa9509503048946f27fa47ef140bb8cccb544f2,2006
- mu-grpc-common-0.4.0.0@sha256:568b5879cd67c0bc0e956d53fb87552bb6d9a6287c5d1b09e2284ed5b04de418,1394
- mu-optics-0.3.0.1@sha256:c3494c71c6300e6a0dcb77c9782481150956e912c1b47fccd69cbb795e461d52,1068
- mu-protobuf-0.4.2.0@sha256:4787a2688abdda107e150736433b61448acdf0b71eb0c174232239b4c143f78b,2119
- mu-rpc-0.5.0.2@sha256:470f5bc372de1b212f625f9e7310cdf82b7fa41ddea03e092fccff0cd9e19db1,1430
- mu-schema-0.3.1.2@sha256:c05e58de29d50376638d19dd3357cd3644d39f984664484f3568d5305b3034d9,1933
- stm-containers-1.2
- stm-hamt-1.2.0.7
- tracing-0.0.7.2
- tracing-control-0.0.7.3
- warp-3.3.14
- warp-grpc-0.4.0.1
#+end_src

*** .gitignore

#+caption: client/.gitignore
#+begin_src text :tangle client/.gitignore
dist-newstyle
melbyc
.stack-work
#+end_src


** Rust client

*** Code overview

While the Haskell client above does work, the [[https://github.com/higherkindness/mu-haskell][=mu-haskell=]] library it depends on
appears to be abandoned. So we need a backup plan in case that library does turn
out to be abandoned forever.

Here we use Rust to build an equivalent client. We start with =Cargo.toml= for
defining dependencies.

See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html.

#+name: rust-client-Cargo.toml
#+caption: Cargo.toml for client-rust
#+begin_src toml :tangle client-rust/Cargo.toml
[package]
name = "melbyc-rust"
description = "melby client, written in Rust"
version = "0.1.0"
edition = "2021"

[dependencies]
tonic = "0.11"
tokio = { version = "1.0", features = ["macros", "rt-multi-thread"] }
prost = "0.12"
clap = { version = "4.5.4", features = ["derive"]}
config = { version = "0.14", features = ["yaml"]}

[build-dependencies]
tonic-build = "0.11"

[[bin]]
name = "melbyc-rust"
path = "src/main.rs"

[profile.release]
# Strip all symbols.
strip = true
#+end_src

And here's the =.gitignore= for this client.

#+begin_src text :tangle client-rust/.gitignore
.cargo

target
#+end_src

Here's the =Makefile= for building and testing.

#+begin_src makefile :tangle client-rust/Makefile
build_dev:
	cargo build
.PHONY: build_dev

build_prod:
	cargo build --release
.PHONY: build_prod

test:
	cargo test
.PHONY: test
#+end_src

Here's the file for protobuf code generation. The =build.rs= name is a special
name that Cargo recognizes automatically.

#+name: build.rs
#+caption: build.rs for client-rust
#+begin_src rust :tangle client-rust/build.rs
use std::error::Error;

fn main() -> Result<(), Box<dyn Error>> {
    tonic_build::compile_protos("proto/melby_client.proto")?;
    tonic_build::configure()
    .build_server(false)
    .out_dir("src/grpc_generated")  // you can change the generated code's location
    .compile(
        &["proto/melby_client.proto"],
        &["proto"], // specify the root location to search proto dependencies
    ).unwrap();

    Ok(())
}
#+end_src

The code above generates =src/grpc_generated/melby_client.rs=. In order to
import it as a module, we have to export it as part of the =grpc_generated=
package. We do that below.

#+name: mod.rs
#+caption: mod.rs for generated code
#+begin_src rust :tangle client-rust/src/grpc_generated/mod.rs
pub mod melby_client;
#+end_src

**** Main function

#+name: rust-client-main.rs
#+caption: main.rs for client-rust
#+begin_src rust :tangle client-rust/src/main.rs
__NREF__client-rust--imports
__NREF__client-rust--option-handling
__NREF__client-rust--main
__NREF__client-rust--business-logic
#+end_src

Basic imports.

#+header: :noweb-ref __NREF__client-rust--imports
#+begin_src rust
use std::collections::HashMap;
use std::error::Error;
use std::path::PathBuf;
use clap::{Parser, Subcommand};
#+end_src

Import generated gRPC code. These are built by =build.rs=.

#+header: :noweb-ref __NREF__client-rust--imports
#+begin_src rust
pub mod grpc_generated;
use grpc_generated::melby_client::view_client::ViewClient;
use grpc_generated::melby_client::ViewRequest;
#+end_src

Global options.

#+header: :noweb-ref __NREF__client-rust--option-handling
#+begin_src rust
#[derive(Parser)]
#[command(version, about, long_about = None)]
/// Global options (applies to all subcommands).
struct Cli {
    /// Config file path.
    #[arg(short, long,
          value_name = "LUA_CONFIG_FILE", default_value = "~/.melby/melby.lua")]
    config: PathBuf,

    /// Inline Lua config if you want to test out small(er) snippets of code
    /// directly without having to write a LUA_CONFIG_FILE on disk somewhere.
    /// Currently ignored by the daemon.
    #[arg(short = 'r', long,
          value_name = "RAW_INLINE_LUA_CONFIG", default_value = "")]
    config_raw: String,

    /// Port of melbyd (presumed to be running on localhost).
    #[arg(short, long, default_value_t = 50051)]
    melbyd_port: u16,

    /// Subcommands.
    #[command(subcommand)]
    command: Option<Commands>,
}
#+end_src

Subcommands. There's only 1 right now, but we'll have more in the future.

#+header: :noweb-ref __NREF__client-rust--option-handling
#+begin_src rust
/// Subcommands and their options.
#[derive(Subcommand)]
enum Commands {
    View {
        #[arg(short, long, default_value_t = 0)]
        shell_pid: u32,
    },
}
#+end_src

Entrypoint.

#+header: :noweb-ref __NREF__client-rust--main
#+begin_src rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();

    match &cli.command {
        Some(Commands::View { shell_pid }) => {
            view(&cli, *shell_pid).await?;
        }
        None => {
            ()
        }
    }

    Ok(())
}
#+end_src

View the output of running the Lua configuration inside melbyd.

#+header: :noweb-ref __NREF__client-rust--business-logic
#+begin_src rust
async fn view(cli: &Cli, shell_pid: u32) -> Result<(), Box<dyn Error>> {
    let url = format!("http://127.0.0.1:{0}", cli.melbyd_port);
    let mut client = ViewClient::connect(url).await?;

    // FIXME: Instead of slurping up everything, only slurp up
    // an "allowlist" of known ENV vars we want to feed into the daemon. This
    // allowlist could be defined in settings.yml or even as an additive list of
    // flags. We could do the additive list of flags first and then move to
    // settings.yml in the future if there are just too many flags.
    let mut env_vars: HashMap<String, String> = HashMap::new();
    for (k, v) in std::env::vars() {
        env_vars.insert(k, v);
    }

    let req = ViewRequest {
        config_path: cli.config.display().to_string(),
        config: cli.config_raw.to_string(),
        env_vars: env_vars,
        shell_pid: shell_pid.to_string(),
    };

    let request = tonic::Request::new(req);
    let response = client.get_view(request).await?;

    println!("{}", response.get_ref().view);

    Ok(())
}
#+end_src

*** Packaging

#+begin_src nix :tangle client-rust/melby-client-rust.nix
{ sources ? import ../package/nix/sources.nix }:
let
  # Overlays
  oxalica-rust-overlay = import sources.rust-overlay;
  # Build rust crates.
  naersk = pkgs.callPackage sources.naersk {
    cargo = pkgs.rust-bin.stable.latest.minimal;
    rustc = pkgs.rust-bin.stable.latest.minimal;
  };
  # The final "pkgs" attribute with all the bells and whistles of our overlays.
  pkgs = import sources.nixpkgs {
    overlays = [
      oxalica-rust-overlay
    ];
  };
in
  naersk.buildPackage {
    src = ./.;
    copyBins = true;
    copyTarget = false;
    # See https://pyo3.rs/v0.14.2/building_and_distribution.html#macos (by way
    # of https://github.com/PyO3/pyo3/issues/1800#issuecomment-1071890916).
    CARGO_BUILD_RUSTFLAGS = pkgs.lib.optional
      pkgs.stdenv.isDarwin
      "-C link-arg=-undefined -C link-arg=dynamic_lookup";
    buildInputs = [
      pkgs.protobuf
    ];
  }
#+end_src

* melbyd

# We skip the first line with ":lines ..." because otherwise the "#+title: ..."
# of that document interferes our own title.
#+include: "daemon.org" :lines "16-"

* Contributing to Melby

Thank you for showing interest in contributing back to this project!

But before we can accept your contributions, there are some things we have to
sort out.

** Code of conduct

You must adhere to the Code of Conduct (FIXME insert link).

** Where to make changes

Remember that the source of truth is in the =*.org= files. /Everything else is
generated code./ Editing the source code directly will not work at all because
tangling the =*.org= files will overwrite those changes.

*** Audit of what's tangled

Some files in this project are not tangled for convenience. Below is a script
that asks Git for a list of all tracked files, and compares it against what's
tangled from Org files.

The script also takes into account a list of known non-tangled tracked files
which acts as an allowlist.

#+begin_src sh :shebang #!/usr/bin/env bash :tangle audit.sh
set -euo pipefail

SCRIPT_ROOT="$(dirname "$(realpath "$0")")"

# Files which are tracked outside of our tangling step, but for legitimate
# reasons (generated code, symlinks to dependencies, or LICENSE files,
# typically).
known_not_tangled=(
    # Generated by Git itself.
    .gitmodules

    # Legalese.
    LICENSE

    # Build system metadata.
    client-rust/Cargo.lock

    # Copied over from toplevel proto in Makefile.
    client-rust/proto/melby_client.proto

    # Generated by client-rust/build.rs.
    client-rust/src/grpc_generated/melby_client.rs

    # Legalese, same as toplevel (copied over in Makefile).
    client/LICENSE

    # Copied over from toplevel proto in Makefile.
    client/lib/MelbyClient/melby_client.proto

    # Needed for Haskell+Stack integration.
    client/stack.nix

    # Build system metadata.
    client/stack.yaml.lock

    # Generated gRPC stubs (Elixir).
    daemon/lib/generated/melby.pb.ex
    daemon/lib/generated/melby_client.pb.ex
    daemon/lib/generated/melby_daemon.pb.ex
    daemon/lib/generated/melby_renderer.pb.ex

    # Build system metadata.
    daemon/lib/melbyd/nifs/Cargo.lock

    # Legalese.
    daemon/lib/melbyd/renderer/LICENSE

    # Copied over from toplevel proto in Makefile.
    daemon/lib/melbyd/renderer/lib/MelbyRenderer/melby_renderer.proto

    # Needed for Haskell+Stack integration.
    daemon/lib/melbyd/renderer/stack.nix

    # Build system metadata.
    daemon/lib/melbyd/renderer/stack.yaml.lock

    # Build system metadata.
    daemon/mix.lock

    # Generated by mix2nix.
    daemon/mix.nix

    # Generated SVG output (TikZ->PDF->SVG).
    image/architecture-overall.svg

    # Symlinks to Lilac.
    lilac.css
    lilac.js
    lilac.theme

    # Generated by Niv.
    package/nix/sources.json
    package/nix/sources.nix

    # Symlink to Lilac.
    syntax-highlighting.css
)

# List all files we explicitly tangle from Org files.
tangled_files()
{
    git -C "${SCRIPT_ROOT}" grep -P '^#\+begin_\w+ .+? :tangle' -- '*.org' \
        | sed 's/^.\+:tangle \(\S\+\).*$/\1/' \
        | sort
}

# List all files checked into version control.
tracked_files()
{
    git -C "${SCRIPT_ROOT}" ls-tree -r HEAD \
        | awk '{print $2,$4}' \
        | grep '^blob' \
        | grep -v '\.\(html\|org\)$' \
        | awk '{print $2}'
}

main()
{
    # Combine tangled files and those which are tracked but not tangled. This
    # list should match the sum of all tangled files (modulo HTML and Org
    # files).
    diff -u \
        <(printf '%s\n' "$(tangled_files)" "${known_not_tangled[@]}" | sort) \
        <(tracked_files)
}

main "$@"
#+end_src

** Focus on prose, not code

Remember that this project uses LP. LP requires /literate/ programs, and as
such, require everything to be explained in prose. If you make substantial
changes in code only without touching any of the surrounding prose, chances are
you are doing it wrong and your changes will not be accepted without extensive
revisions.

You must explain your changes in prose. Please try to explain things with simple
language, with simple words. And be as direct as possible. Avoid theatrics. Try
to explain things so that even inexperienced developers can understand.

It is completely normal for a Pull Request to go through /multiple rounds of
review/ before it is accepted.
