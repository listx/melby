# Copyright 2023 Linus Arver
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#+title: View
#+PROPERTY: header-args :noweb no-export

* Purpose

=melbyr= (the melby-renderer) converts raw data into strings that can be
interpreted and presented by some other program (e.g., Zsh prompt display).

There are basically 2 concrete things that =melbyr= can do:

1. Convert existing composite data types into a string token ("render" the data
   into a string representation).
2. Convert a list of string tokens into a new string ("render" the tokens down
   into a final string output).

The second step involves interpreting layout tokens such as =FILL= and =SPACE=.

* Architectural overview

(Insert diagram --- write tikz and export as SVG.)

* Design by contract

We would like =melbyr= to observe the following behaviors.

** Communication between melbyd and melbyr

*** Proto

#+name: melbyproto_melby_renderer
#+begin_src protobuf :tangle melby_renderer.proto
syntax = "proto3";

package melby_renderer;

// melby <-> melby-renderer communication
service Renderer {
  // For other Git Repo stats, each of those stats can be inserted into the
  // layout with Lua so that the user can configure the order/orientation of
  // each bit (they should also be able to decide how much of the 40-char sha
  // they want to expose --- so we need a way to colorize all 40 chars by using
  // all 160 bits of data).
  rpc GetColorizedGitSha (ColorizedGitShaRequest) returns (ColorizedGitShaResponse);
  rpc RenderWidgets (RenderWidgetsRequest) returns (RenderWidgetsResponse);
  // This is not a method for rendering, but because
  // https://github.com/higherkindness/mu-haskell/pull/309 isn't released yet,
  // we cannot use a separate service for this, because doing so would require
  // us to use a second TCP port. Once mu-grpc-server gets a new release that
  // includes the above PR, we can use a separate service and multiplex it on
  // the same port for better code organization.
  rpc ParsePathAliases (ParsePathAliasesRequest) returns (ParsePathAliasesResponse);
}

message ColorizedGitShaRequest {
  string sha = 1;
  // How many SHA hex chars to colorize (and output). Typically this will be
  // less than 40 because in practice people rarely want the full 40-char SHA in
  // their shell prompt.
  uint32 sha_length = 2;
  // How many space characters to add to the left/right of the final (colorized)
  // output. These space characters will take on the background color of their
  // adjacent colorized hex chars in the SHA string. This is purely for
  // aesthetic reasons.
  uint32 pad_left = 3;
  uint32 pad_right = 4;
  RenderOptions render_options = 5;
}

message ColorizedGitShaResponse {
  string sha_colorized = 1;
}

message RenderOptions {
  RenderFormat format = 1;
  RenderColorDepth color_depth = 2;
}

enum RenderFormat {
  RENDER_FORMAT_UNSPECIFIED = 0;
  RENDER_FORMAT_UNIX_TERMINAL = 1;
}

enum RenderColorDepth {
  // "Unspecified" just means to refrain from doing any special colorizations.
  RENDER_COLOR_DEPTH_UNSPECIFIED = 0;
  RENDER_COLOR_DEPTH_256 = 1;
  RENDER_COLOR_DEPTH_24_BIT = 2;
}

message RenderWidgetsRequest {
  repeated Widget widgets = 1;
  // By default, this is a single space character (without any colors) and acts
  // as a separater between all widgets.
  Widget delimiter = 2;
  RenderOptions render_options = 3;
}

message RenderWidgetsResponse {
  string widgets_rendered = 1;
}

message Widget {
  string str = 1;
  TextProperty prop = 2;
  bool drop_delim_left = 3;
  bool drop_delim_right = 4;
}

message TextProperty {
  Color fg = 1;
  Color bg = 2;
  repeated TextStyle styles = 3;
  // FIXME: It is possible to have underlines in a different color than the
  // current foreground color. This field captures that possibility. BUT the
  // ansi-terminal library does not appear to support this. So don't bother.
  // Color line_color = 4;
}

message Color {
  oneof color_oneof {
    Color24Bit color_24_bit = 1;
    // The well-known "256" colors as used in ANSI escade codes. The first 16
    // colors (0 through 15) are the traditional 16 colors used before 256
    // colors became a thing. The colors 232-255 represent a grayscale gradient
    // (dark to light), and finally the middle 216 colors (16-231) represent
    // additional colors in 6 squares, each with 36 colors. See FIXME table
    // here: https://en.wikipedia.org/wiki/ANSI_escape_code
    uint32 color_256 = 2;
  }
}

message Color24Bit {
  // Ideally each of these should be a "uint8" but protobuf does not have this
  // scalar type. So target applications have to convert to a uint8 (mask the
  // lower 8 bits) of each color channel.
  uint32 red = 1;
  uint32 green = 2;
  uint32 blue = 3;
}

enum TextStyle {
  TEXT_STYLE_UNSPECIFIED = 0;
  TEXT_STYLE_BOLD = 1;
  TEXT_STYLE_ITALIC = 2;
  TEXT_STYLE_UNDERLINE = 3;
  TEXT_STYLE_UNDERLINE_DOUBLE = 4;
  TEXT_STYLE_BLINK = 5;
  TEXT_STYLE_BLINK_RAPID = 6;
}

message ParsePathAliasesRequest {
  string path_aliases_raw = 1;
}

message ParsePathAliasesResponse {
  ParseStatus status = 1;
  // Happy path.
  map<string, string> path_aliases = 2;
  // Error message from melbyr, if any.
  string error = 3;
}

enum ParseStatus {
  PARSE_STATUS_UNSPECIFIED = 0;
  PARSE_STATUS_ERROR = 1;
  PARSE_STATUS_OK = 2;
}
#+end_src

** Running very quickly

We don't want the client to block too long, because it is expected to be called
as often as every second (or even more often if Zsh ever offers sub-1-second
delay with the =TMOUT= variable).

The basic way we ensure this is that we make melbyd return whatever it has
without waiting for any of its internal calculations to finish.

Because this is a server-side concern, there isn't much for us to do here.

** Command line argument handling

This is somewhat "boring" and we actually don't have much to design here. Much
of the choices here depend heavily on the command line argument parsing library
that we will be using.

* Code overview

This walkthrough is written for the future maintainers of this codebase.

** Overall structure

#+name: =melby-renderer.hs=
#+caption: Layout of =melby-renderer.hs=
#+begin_src haskell :tangle daemon/lib/melbyd/renderer/melby-renderer.hs
__NREF__melbyr_pragmas

module Main where

__NREF__melbyr_imports
__NREF__melbyr_option_handling
__NREF__melbyr_main
#+end_src

* Business logic

** Widget Rendering System

A "widget" object encodes a string of text that must be rendered on the
terminal. Widgets are encoded in Lua directly in the user configuration. Here is
an example:

#+begin_src lua
foo = {str=" foo ", fg="white", bg="blue", styles={"bold"}}
#+end_src

This encodes the =" foo "= string with a blue background with white, bolded
text. The user can then just send over a list of these widgets to be rendered on
a single line (assuming they do not encode any newlines in the =str= field).

Between each widget, 1 space character is inserted by default. This can be
adjusted with the =delimiter= option in the call to =render()=, like this:

#+begin_src lua
rendered = melbyd.render(widgets, delimiter={str="**"}, render_options={format="RENDER_FORMAT_UNIX_TERMINAL", color_depth="RENDER_COLOR_DEPTH_24_BIT"})
#+end_src

This uses 2 asterisks as a delimiter.

*** Widget field reference

Widgets can have the following fields:

| Field  | Description                                               | Examples           |
| str    | The literal string character(s) to display.               | =" foo "=          |
| fg     | Forground stying. Colors and/or text formatting accepted. | ="black"=          |
| bg     | Background colors.                                        | ="white"=          |
| styles | List of styles to apply.                                  | ="bold", "italic"= |

For a complete list of color names, see
https://www.w3.org/TR/css-color-4/#named-colors. For other accepted color
formats, refer to the [[https://github.com/mazznoer/csscolorparser-rs][csscolorparser Rust library]] which we use. Note that any
color that we cannot parse is just given a generic, grey color. This is because
we don't yet have configuration validation.

*** Optional widget delimiters

List all widgets. If 0 or 1 in length, do nothing.

If the length is $> 1$, then create a second copy. Shift by 1 (drop 1), and zip
together, so that if we have e.g. =[1, 2, 3]= we get =[(1, 2), (2, 3)]=. Thus we
are able to get a "pairwise" view of all widgets.

Then just loop through this list of pairs, and build up the final widgets list
(with or without delimiters) depending on the =drop_delim_left= and
=drop_delim_right= fields in each pair. The final list is built up by adding in
up to 2 widgets at a time, the left pair item and an optional delimiter widget.
Finally, append the last widget unconditionally.

Actually we can do the above with just recursion. See =injectDelimiters=.

*** Implementation

#+name: =Widgets.hs=
#+begin_src haskell :tangle daemon/lib/melbyd/renderer/lib/MelbyRenderer/Widgets.hs
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TypeApplications #-}

module MelbyRenderer.Widgets
  ( renderWidgets
  ) where

import Control.Monad.Logger hiding (logDebug)
import Data.Colour.SRGB (sRGB24)
import Data.Maybe (catMaybes, listToMaybe)
import qualified Data.Text as T
import GHC.Records (getField)
import Mu.Server
import System.Console.ANSI
       ( setSGRCode
       , BlinkSpeed (..)
       , ConsoleIntensity (..)
       , ConsoleLayer (..)
       , SGR (..)
       , Underlining (..))

import MelbyRenderer.Log (logDebug)
import MelbyRenderer.Schema

renderWidgets
  :: (MonadServer m, MonadLogger m)
  => MRenderWidgetsRequest
  -> m MRenderWidgetsResponse
renderWidgets req = do
  logDebug $ "request was: " <> (T.pack $ show req)
  pure $ MRenderWidgetsResponse
    { widgets_rendered = rendered
    }
  where
  rendered = T.concat $ map (renderWidget renderOpts) widgetsWithDelimiters
  widgetsWithDelimiters = injectDelimiters delimiterFinal $ widgets req
  delimiterFinal = case delimiter req of
    Just d -> d
    Nothing -> MWidget
      { str = " "
      , prop = Nothing
      , drop_delim_left = False
      , drop_delim_right = False
      }
  renderOpts = case GHC.Records.getField @"render_options" req of
    Just ro -> ro
    Nothing -> MRenderOptions
      { format = RENDER_FORMAT_UNIX_TERMINAL
      , color_depth = RENDER_COLOR_DEPTH_24_BIT
      }

injectDelimiters :: MWidget -> [MWidget] -> [MWidget]
injectDelimiters delim ws = case ws of
  [] -> []
  [w] -> [w]
  (w1:w2:rest) -> let recurse = injectDelimiters delim (w2:rest)
    in if drop_delim_right w1 || drop_delim_left w2
      then w1:recurse
      else w1:delim:recurse

renderWidget :: MRenderOptions -> MWidget -> T.Text
renderWidget renderOptions widget = case format renderOptions of
  RENDER_FORMAT_UNSPECIFIED -> "RENDER_FORMAT_UNSPECIFIED is unimplemented"
  RENDER_FORMAT_UNIX_TERMINAL -> T.concat
    [ propCodes
    , MelbyRenderer.Schema.str widget
    , T.pack $ setSGRCode [Reset]
    ]
  where
  propCodes = case prop widget of
    Just p -> textPropToAnsiCode p
    Nothing -> ""

textPropToAnsiCode :: MTextProperty -> T.Text
textPropToAnsiCode tp
  = T.pack . setSGRCode $ catMaybes
    ([ propFg
     , propBg
     ] <> map (listToMaybe . styleToSGRCode) (styles tp))
  where
  propFg = case fg tp of
    Nothing -> Nothing
    Just mcolor -> colorToSGRCode mcolor Foreground
  propBg = case bg tp of
    Nothing -> Nothing
    Just mcolor -> colorToSGRCode mcolor Background
  colorToSGRCode mcolor fgOrBg = case color_oneof mcolor of
    -- FIXME: Get the default terminal background color and use it to blend the
    -- foreground color here against it to get a Colour (instead of
    -- AlphaColour).

    -- (MColorOneOf24Bit mcolor24bit) -> Just
    --                                . SetRGBColor Foreground
    --                                . withOpacity (fromIntegral $ alpha mcolor24bit)
    (MColorOneOf24Bit mcolor24bit) -> Just . SetRGBColor fgOrBg
      $ sRGB24 (fromIntegral $ red mcolor24bit)
               (fromIntegral $ green mcolor24bit)
               (fromIntegral $ blue mcolor24bit)
    (MColorOneOf256 mcolor256) -> Just $ SetPaletteColor fgOrBg (fromIntegral mcolor256)
  styleToSGRCode = \case
    TEXT_STYLE_UNSPECIFIED -> []
    TEXT_STYLE_BOLD -> [SetConsoleIntensity BoldIntensity]
    TEXT_STYLE_ITALIC -> [SetItalicized True]
    TEXT_STYLE_UNDERLINE -> [SetUnderlining SingleUnderline]
    TEXT_STYLE_UNDERLINE_DOUBLE -> [SetUnderlining DoubleUnderline]
    TEXT_STYLE_BLINK -> [SetBlinkSpeed SlowBlink]
    TEXT_STYLE_BLINK_RAPID -> [SetBlinkSpeed RapidBlink]
#+end_src

** Colorized Git SHA

We want to colorized a Git SHA to make it easier to tell apart from another Git
SHA without having to read each individual hex digit. The basic idea is to use
the hex digits (which have a lot of entropy due to the cryptographic nature of
the underlying SHA-1 hash algorithm) to generate the colors, so that one commit
SHA will look very different (color-wise) from another, even if they share the
same leading hex digits.

There are two effecitve color modes (=OutputColorDepth=): 256 colors (available
to all standard terminals) and 24-bit color (available to most modern
terminals). The colorization algorithms for these modes differ significantly,
but they both have the following properties:

1. colorize all 40 hex characters,
2. feed the underlying bits of the hex characters themselves into the
   colorization algorithm (to make it deterministic), and
3. make it so that even if 2 different commit SHAs have the same leading N hex
   characters, that these two are colorized very differently.

The last property is important because most users will want to only display the
leading 7 to 10 characters of the hex string because this is typically enough in
practice, and we don't want 2 different commits that share the leading 7 to 10
characters to appear the same (for these leading characters). There are many
ways to achieve this, such as using the tail end of the hex string to colorize
the front.

Our algorithms below do their best to make use of all 160 bits of entropy in
every commit SHA. Generally they do this with 2 methods --- choosing the colors
and distributing these colors onto the 40 hex characters.

*** Overview

#+name: =Widgets.hs=
#+begin_src haskell :tangle daemon/lib/melbyd/renderer/lib/MelbyRenderer/Colorizer.hs
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TypeApplications #-}

module MelbyRenderer.Colorizer
  ( getColorizedGitSha
  ) where

import Control.Monad.Logger hiding (logDebug)
import Data.Bits (xor)
import qualified Data.ByteString as B
import qualified Data.ByteString.Base16 as B16
import Data.Colour.CIE.Illuminant (d65)
import Data.Colour.CIE (lightness)
import Data.Colour.SRGB (sRGB24, toSRGB24)
import Data.Colour.RGBSpace
import Data.Either (fromRight)
import qualified Data.Text.Encoding as T
import qualified Data.Text as T
import Data.Word (Word32)
import Mu.Server
import System.Console.ANSI (setSGRCode, ConsoleIntensity (..), ConsoleLayer (..), SGR (..))

import MelbyRenderer.Log (logDebug)
import MelbyRenderer.Schema

getColorizedGitSha
  :: (MonadServer m, MonadLogger m)
  => MColorizedGitShaRequest
  -> m MColorizedGitShaResponse
getColorizedGitSha req = do
  logDebug $ "request was: " <> (T.pack $ show req)
  pure $ MColorizedGitShaResponse{ sha_colorized = colorize (sha req) (sha_length req) (pad_left req) (pad_right req)}
  where
  colorize bytes len padl padr
    = renderColorized
    . (<> [(Reset, "")])
    . ((SetConsoleIntensity BoldIntensity, "") :)
    . addPadding padl padr
    $ colorizeGitSha24bit bytes len

__NREF__melbyr_colorize_git_sha_24_bit
__NREF__melbyr_add_padding
__NREF__melbyr_render_misc
__NREF__melbyr_perceived_lightness
#+end_src

*** 24-bit colors

The Git SHA uses SHA-1 and has 160 random bits. We want 80 extra random bits so
that we have 240 total bits. We generate the 80 extra bits by XOR-ing the first
half and second half of the original together.

Now we have 240 bits to work with, and this is a "nice" number because we can
now choose 10 24-bit colors. We then split up the 40 hex chars into 10 groups of
4 characters, and colorize each of these groups using the 10 chosen colors.

**** Cosmetics

We do 2 additional things for colorization:

1. optionally pad the left and right by an extra space character, so that the
   hex characters (with the colored background) are easier to read on the eyes,
   and
2. choose to display the hex char text in either black or white depending on the
   perceived brightness of the background color.

***** Choose black or white foreground text based on perceived lightness

The [[https://en.wikipedia.org/wiki/RGB_color_model][RGB color model]], which is used extensively in computer graphics, noticeably
lacks a "luminance" value. The [[https://en.wikipedia.org/wiki/CIELAB_color_space][CIELAB color space]] includes a luminance value to
measure perceptual lightness. The simplest thing we can do to find the perceived
lightness from a given RGB value is to convert it to the CIELAB color space and
extract the lightness value from it.

Note that a color model is just how a color is described, whereas a color space
is responsible for generating actual (physically real) colors from the color
model's discrete (limited) values. See [[https://photo.stackexchange.com/a/48985][this post]] for more information about
color models vs color spaces.

Anyway, see https://stackoverflow.com/a/56678483/437583 for an explanation of
how to find perceived lightness from an RGB (color model) value. However, we
don't follow that guide because the work has already been done for us in the
[[https://hackage.haskell.org/package/colour-2.3.6][colour]] library for Haskell, which includes conversion into the CIELAB color
space.

#+name: __NREF__melbyr_perceived_lightness
#+begin_src haskell
getPerceivedLightness :: (Floating b, RealFrac b) => Colour b -> Double
getPerceivedLightness c = lightness d65 $ sRGB24 r g b
  where
  m = toSRGB24 c
  r = channelRed m
  g = channelGreen m
  b = channelBlue m

getContrastingColor :: (Floating b, RealFrac b) => Colour b -> Colour b
getContrastingColor c = if (getPerceivedLightness c) < 50.0
  then sRGB24 255 255 255
  else sRGB24 0 0 0
#+end_src

**** Implementation

#+name: __NREF__melbyr_colorize_git_sha_24_bit
#+begin_src haskell
colorizeGitSha24bit :: T.Text -> Word32 -> [(SGR, T.Text)]
colorizeGitSha24bit shaStr len
  = reverse
  . zip colorCodes
  . buildOutput []
  $ T.take (fromIntegral len) shaStr
  where
  bytes = asBytes shaStr
  -- XOR the first and second halves of the input bytes (20 bytes) to generate
  -- 10 more bytes. Now we have 30 bytes in total in bytesFinal.
  bytes1 = B.take 10 bytes
  -- FIXME: after ByteString 0.11.1.0, use B.takeEnd
  bytes2 = B.drop (B.length bytes - 10) bytes
  bytesFinal = B.concat
    -- FIXME: after ByteString 0.11.1.0, use B.packZipWith
    --[B.packZipWith (\a b -> xor a b) bytes1 bytes2, B.reverse bytes]
    [(B.pack $ B.zipWith (\a b -> xor a b) bytes1 bytes2), B.reverse bytes]
  -- Using the 30 bytes in bytesFinal, generate 10 colors (of 3 bytes, or 24 bits, each).
  colorCodes = gen10Colors [] bytesFinal
  gen10Colors acc bs = case B.length (B.take 3 bs) of
    3 -> gen10Colors ((toSgrCode . toRgbTuple $ B.take 3 bs) : acc) (B.drop 3 bs)
    _ -> acc
  toRgbTuple bs3
    = ( fromIntegral $ B.index bs3 0
      , fromIntegral $ B.index bs3 1
      , fromIntegral $ B.index bs3 2
      )
  toSgrCode (r, g, b) = SetRGBColor Background $ sRGB24 r g b
  -- Construct the output string as groups of 4 hex chars each. Use the same
  -- recursion pattern as in gen10Colors to build up an output that colorizes 4
  -- hex chars at a time.
  buildOutput acc hexChars = case T.length (T.take 4 hexChars) of
    0 -> acc
    _ -> buildOutput (T.take 4 hexChars : acc) (T.drop 4 hexChars)
#+end_src

#+name: __NREF__melbyr_add_padding
#+begin_src haskell
addPadding :: Word32 -> Word32 -> [(SGR, T.Text)] -> [(SGR, T.Text)]
addPadding padl padr colorized = case colorized of
  [] -> []
  (c, t):[] -> [(c, prefix <> t <> suffix)]
  (c1, t1):(c2, t2):[] -> [(c1, prefix <> t1), (c2, t2 <> suffix)]
  _ -> let
    (c1, t1) = head colorized
    (c2, t2) = last colorized
    mid = init $ drop 1 colorized
    in [(c1, prefix <> t1)] <> mid <> [(c2, t2 <> suffix)]
  where
  prefix = T.replicate (fromIntegral padl) " "
  suffix = T.replicate (fromIntegral padr) " "
#+end_src

#+name: __NREF__melbyr_render_misc
#+begin_src haskell
renderColorized :: [(SGR, T.Text)] -> T.Text
renderColorized = T.concat . map f
  where
  f (code, hexChars) = T.pack (setSGRCode [code]) <> fgColor <> hexChars
    where
    fgColor = case code of
      (SetRGBColor Background bgColor) -> ( T.pack
                                          $ setSGRCode [ SetRGBColor Foreground
                                                       $ getContrastingColor bgColor
                                                       ])
      _ -> T.empty

asBytes :: T.Text -> B.ByteString
asBytes = (fromRight B.empty . B16.decode) . T.encodeUtf8
#+end_src

** Parse path aliases

#+name: =PathAliases.hs=
#+begin_src haskell :tangle daemon/lib/melbyd/renderer/lib/MelbyRenderer/PathAliases.hs
{-# LANGUAGE FlexibleContexts #-}

module MelbyRenderer.PathAliases
  ( parsePathAliases
  , pPathAliases
  , pPathAlias
  ) where

import Control.Applicative hiding (many, some)
import Data.Map.Strict as M
import qualified Data.Text as T
import Data.Void
import Text.Megaparsec
import Text.Megaparsec.Char
import qualified Text.Megaparsec.Char.Lexer as L
import Data.Char (isAsciiUpper, isAsciiLower, isDigit, isPunctuation, isAlphaNum)
import Mu.Server (MonadServer)
import Control.Monad.Logger hiding (logDebug)

import MelbyRenderer.Log (logDebug)
import MelbyRenderer.Schema

type Megaparser = Parsec Void T.Text

parsePathAliases
  :: (MonadServer m, MonadLogger m)
  => MParsePathAliasesRequest
  -> m MParsePathAliasesResponse
parsePathAliases req = do
  logDebug $ "request was: " <> (T.pack $ show req)
  let
    result = parsePathAliasesRaw $ path_aliases_raw req
  case result of
    Right pathAliases -> pure $ MParsePathAliasesResponse
      { status = PARSE_STATUS_OK
      , path_aliases = pathAliases
      , error = ""
      }
    Left err -> pure $ MParsePathAliasesResponse
      { status = PARSE_STATUS_ERROR
      , path_aliases = M.empty
      , error = err
      }

parsePathAliasesRaw :: T.Text -> Either T.Text (M.Map T.Text T.Text)
parsePathAliasesRaw input = case parse pPathAliases "" input of
  Left err -> Left . T.pack $ errorBundlePretty err
  Right m -> Right m

pPathAliases :: Megaparser (M.Map T.Text T.Text)
pPathAliases = do
  -- Clear leading whitespace/comments.
  _ <- optional sc
  pathAliasesAsTuples <- Text.Megaparsec.many pPathAlias
  eof
  pure $ M.fromList pathAliasesAsTuples

pPathAlias :: Megaparser (T.Text, T.Text)
pPathAlias = do
  -- Example of the kind of line we want to parse:
  --    hash -d   kt=${HOME}/go/src/k8s.io/test-infra
  _ <- symbol "hash"
  _ <- symbol "-d"
  alias <- pAlias
  _ <- char '='
  path <- T.concat <$> lexeme (directoryPath <?> "directory path")
  -- We want to have the path as the key to the Map, because that's how we use
  -- it back in Elixir (FIXME: add link).
  pure (path, alias)
  -- FIXME: Use withRecovery to recover from a parse error. See
  -- https://stackoverflow.com/questions/59640023/how-to-report-multiple-errors-using-megaparsec.
  --if isValid path
    --then pure Just (path, alias)
    --else pure Nothing
  where
  directoryPath = do
    dp <- some $ choice [pPath, pVariable]
    -- This is a hacky way of checking cases where we should fail when the user
    -- has put in an aberrant "$" symbol (when it is *not* used as part of
    -- defining an environment variable like "${FOO}".) This is the only way we
    -- can expect a kind of "eof" at the end here without actually using "eof"
    -- (we can't use eof because this parser is part of a larger parser that
    -- uses eof, namely pPathAliases). We would ideally want to use an eof here
    -- because we want this parser to consume all non-space characters while
    -- still playing nicely with the lexeme which consumes all trailing comments
    -- and newlines.

    -- In other words, this checks the case where we have a badly formed path
    -- like "/clam-chowder-$oup" --- here the "/clam-chowder-" will get
    -- successfully parsed, and neither pVariable nor pPath will succeed on the
    -- remaining "$oup" input. We want to ensure that whatever we end up
    -- parsing, we will *NOT* get a dollar symbol immediately following a
    -- successful parse.
    notFollowedBy (char '$')
    pure dp

pAlias :: Megaparser T.Text
pAlias = do
  firstLetter <- satisfy isAllowedFirstLetter <?> "first letter of alias"
  rest <- takeWhileP (Just "alias chars") isAllowedTrailingLetter
  pure $ T.cons firstLetter rest
  where
  -- The equivalent regex for the allowed range is "_A-Za-z0-9".
  isAllowedFirstLetter c
    = or $ Prelude.map ($ c)
      [ isAsciiLower
      , isAsciiUpper
      , isDigit
      , (== '_')
      ]
  -- Same as isAllowedFirstLetter, but also allow dashes. Note that these
  -- parsing rules is just a reflection of what is normally allowed by Zsh's
  -- "hash" builtin function. There, if we try something like "hash -d
  -- -myalias=/a/very/long/path", the "-myalias" gets interpreted as a flag to
  -- the "hash" function. This is why we don't allow the dash character to be
  -- used as the first letter of the alias.
  isAllowedTrailingLetter c = isAllowedFirstLetter c || c == '-'

pPath :: Megaparser T.Text
pPath = takeWhile1P (Just "directory chars") isAllowedPathChar
  where
  -- Technically speaking, a folder can have a literal "$" character in it, like
  -- this: "/foo/bar/\$baz", but in order to simplify our implementation we
  -- forbid them because they are too rare. So, we just prohibit the dollar
  -- symbol, because it is the first expected character of a variable.
  isAllowedPathChar c = (c /= '$') && (isAlphaNum c || isPunctuation c)

pVariable :: Megaparser T.Text
pVariable = do
  _ <- string "${" <?> "dollar-and-opening-brace"
  firstLetter <- satisfy isAllowedFirstLetter <?> "first letter of shell variable name"
  rest <- takeWhile1P (Just "shell variable name chars") isAllowedTrailingLetter
  _ <- char '}'
  pure $ "${" <> T.cons firstLetter rest <> "}"
  where
  isAllowedFirstLetter c
    | isAsciiUpper c = True
    | c == '_' = True
    | otherwise = False
  isAllowedTrailingLetter c = isAllowedFirstLetter c || isDigit c

-- This is taken from https://markkarpov.com/tutorial/megaparsec.html#lexing. We
-- want to use these lexeme-based helpers to create parsers that ignore both
-- whitespace as well as comment lines. Othwerwise, we'd have to manually
-- construct these parsers as well, which is annoying and too low-level for us.
sc :: Megaparser ()
sc = L.space
  space1
  (L.skipLineComment "#")
  Text.Megaparsec.empty

lexeme :: Megaparser a -> Megaparser a
lexeme = L.lexeme sc

symbol :: T.Text -> Megaparser T.Text
symbol = L.symbol sc
#+end_src

#+name: =Main.hs= for melbyr tests
#+begin_src haskell :tangle daemon/lib/melbyd/renderer/test/Main.hs
{-# LANGUAGE QuasiQuotes #-}

module Main (main) where

import Data.Map.Strict as M
import NeatInterpolation
import Test.Hspec
import Test.Hspec.Megaparsec
import Text.Megaparsec

import MelbyRenderer.PathAliases (pPathAlias, pPathAliases)

main :: IO ()
main = hspec $ do
  describe "pPathAlias" $ do
    -- Good cases.
    context "when parsing a typical case" $
      it "works" $
        parse pPathAlias "" "hash -d foo=/bar" `shouldParse` ("/bar", "foo")
    context "when parsing a typical case with extra spaces" $
      it "works" $
        parse pPathAlias "" "hash   -d     foo=/bar   " `shouldParse` ("/bar", "foo")
    context "when parsing a path with an embedded variable" $
      it "works" $
        parse pPathAlias "" "hash -d   kk=${HOME}/go/src/k8s.io/kubernetes" `shouldParse` ("${HOME}/go/src/k8s.io/kubernetes", "kk")
    context "when parsing a path with multiple embedded variables" $
      it "works" $
        parse pPathAlias "" "hash -d   x=${HOME}/foo/${SUBDIR}/baz" `shouldParse` ("${HOME}/foo/${SUBDIR}/baz", "x")
    context "when parsing a path with a trailing comment" $
      it "works" $
        parse pPathAlias "" "hash -d   x=${HOME}/hello # Comment text" `shouldParse` ("${HOME}/hello", "x")
    -- Bad cases.
    context "when the equal sign has a space to the left" $
      it "fails" $
        parse pPathAlias "" "hash   -d     foo =/bar   " `shouldFailWith` err 17 (utok ' ' <> etok '=' <> elabel "alias chars")
    context "when the equal sign has a space to the right" $
      it "fails" $
        parse pPathAlias "" "hash   -d     foo= /bar   " `shouldFailWith` err 18 (utoks " /" <> elabel "directory path")
    context "when there is an aberrant dollar sign in the path" $
      it "fails" $
        parse pPathAlias "" "hash -d x=/clam-chowder-$oup\n" `shouldFailWith` err 24 (utok '$' <> elabel "directory chars" <> elabel "dollar-and-opening-brace")
  describe "pPathAliases" $ do
    context "when there are comment lines" $
      it "works" $
        let
          x =
            [trimming|

            # Comment at beginning of file.

            hash -d x=/foo # Trailing comment.
            # Commented out declaration.
            # hash -d x=/foo

            # Unfortunately we have to escape the dollar sign to make it play nicely with Template Haskell.
            hash -d kk=$${HOME}/go/src/k8s.io/kubernetes

            # Indented entry.
              hash    -d   y=/hello
            # Comment at end of file.
            |]
        in parse pPathAliases "" x `shouldParse` M.fromList [("/foo", "x"), ("${HOME}/go/src/k8s.io/kubernetes", "kk"), ("/hello", "y")]
#+end_src

* Boilerplate

** Option handling

#+name: __NREF__melbyr_option_handling
#+begin_src haskell
__NREF__melbyr_option_handling_types
__NREF__melbyr_option_handling_parsers
__NREF__melbyr_option_handling_dispatcher
#+end_src


#+name: __NREF__melbyr_option_handling_types
#+begin_src haskell
newtype Opts = Opts
  { subcommand :: Subcommand }

data Subcommand
  = Serve ServeOpts
  | Ping

data ServeOpts = ServeOpts
  { oPort :: Int
  }
#+end_src


#+name: __NREF__melbyr_option_handling_parsers
#+begin_src haskell
optionsP :: Parser Opts
optionsP = Opts <$> subcommandP

subcommandP :: Parser Subcommand
subcommandP = hsubparser
  (  command "serve" (info (Serve <$> serveOptsP) (progDesc "get prompt information with Lua"))
  <> command "ping" (info (pure Ping) (progDesc "FIXME ?"))
  <> metavar "SUBCOMMAND"
  )

serveOptsP :: Parser ServeOpts
serveOptsP
  = ServeOpts
  <$> (argument auto (metavar "PORT"))

#+end_src


#+name: __NREF__melbyr_option_handling_dispatcher
#+begin_src haskell
optsHandler :: Opts -> IO ()
optsHandler (Opts subcommand') = do
  case subcommand' of
    Serve o -> do
      putStrLn $ "serving over port " <> (show (oPort o))
      mixEnv <- lookupEnv "MIX_ENV"
      let
        logFilter = case mixEnv of
          -- For production, disable LevelDebug logs.
          Just "prod" -> (\_logSource logLevel -> logLevel > LevelInfo)
          _ -> (\_ _ -> True)
      runGRpcAppTrans msgProtoBuf (oPort o) (runStderrLoggingT . filterLogger logFilter) renderer
    Ping -> putStrLn "not implemented"

renderer :: (MonadServer m, MonadLogger m) => SingleServerT info Renderer m _
renderer = singleService
  ( method @"GetColorizedGitSha" getColorizedGitSha
  , method @"RenderWidgets" renderWidgets
  , method @"ParsePathAliases" parsePathAliases
  )
#+end_src

** Main

#+name: __NREF__melbyr_main
#+begin_src haskell
main :: IO ()
main = do
  opts <- customExecParser (prefs showHelpOnEmpty) optsP
  optsHandler opts
  where
  optsP = info parserProgramOptions infoMod
  parserProgramOptions = helper
    <*> versionOption
    <*> optionsP
  infoMod = fullDesc
    <> header "melbyr - melby renderer"
  __NREF__melbyr_gitVersion
#+end_src

** gRPC schema

FIXME: break this up into smaller chunks

#+name: melbyr_lib_schema
#+begin_src haskell :tangle daemon/lib/melbyd/renderer/lib/MelbyRenderer/Schema.hs
{-# language CPP                   #-}
{-# language DataKinds             #-}
{-# language DeriveAnyClass        #-}
{-# language DeriveGeneric         #-}
{-# language DerivingVia           #-}
{-# language DuplicateRecordFields #-}
{-# language FlexibleContexts      #-}
{-# language FlexibleInstances     #-}
{-# language MultiParamTypeClasses #-}
{-# language OverloadedLabels      #-}
{-# language PolyKinds             #-}
{-# language TemplateHaskell       #-}
{-# language TypeFamilies          #-}
{-# language TypeOperators         #-}

module MelbyRenderer.Schema where

import qualified Data.Map.Strict as M
import qualified Data.Text as T
import Data.Word (Word32)
import GHC.Generics

import Mu.Quasi.GRpc
import Mu.Schema

grpc "MelbyRendererSchema" id "lib/MelbyRenderer/melby_renderer.proto"

__NREF__melbyr_schema_colorized_git_sha
__NREF__melbyr_schema_widgets
__NREF__melbyr_schema_render_options
__NREF__melbyr_schema_parse_path_aliases
#+end_src

*** Colorized Git SHA

#+name: __NREF__melbyr_schema_colorized_git_sha
#+begin_src haskell
data MColorizedGitShaRequest = MColorizedGitShaRequest
  -- In mu-haskell, nested types must be contained in a Maybe. See
  -- https://github.com/higherkindness/mu-haskell/issues/255#issuecomment-730468011.
  { sha :: T.Text
  , sha_length :: Word32
  , pad_left :: Word32
  , pad_right :: Word32
  , render_options :: Maybe MRenderOptions
  } deriving (Eq, Show, Ord, Generic
             , ToSchema MelbyRendererSchema "ColorizedGitShaRequest"
             , FromSchema MelbyRendererSchema "ColorizedGitShaRequest")

data MColorizedGitShaResponse = MColorizedGitShaResponse
  { sha_colorized :: T.Text
  } deriving (Eq, Ord, Show, Generic
             , ToSchema MelbyRendererSchema "ColorizedGitShaResponse"
             , FromSchema MelbyRendererSchema "ColorizedGitShaResponse")
#+end_src

*** Render options

#+name: __NREF__melbyr_schema_render_options
#+begin_src haskell
data MRenderOptions = MRenderOptions
  { format :: MRenderFormat
  , color_depth :: MRenderColorDepth
  } deriving (Eq, Ord, Show, Generic
           , ToSchema MelbyRendererSchema "RenderOptions"
           , FromSchema MelbyRendererSchema "RenderOptions")

data MRenderFormat
  = RENDER_FORMAT_UNSPECIFIED
  | RENDER_FORMAT_UNIX_TERMINAL
  deriving (Eq, Ord, Show, Generic
           , ToSchema MelbyRendererSchema "RenderFormat"
           , FromSchema MelbyRendererSchema "RenderFormat")

data MRenderColorDepth
  = RENDER_COLOR_DEPTH_UNSPECIFIED
  | RENDER_COLOR_DEPTH_256
  | RENDER_COLOR_DEPTH_24_BIT
  deriving (Eq, Ord, Show, Generic
           , ToSchema MelbyRendererSchema "RenderColorDepth"
           , FromSchema MelbyRendererSchema "RenderColorDepth")
#+end_src

*** Widgets

#+name: __NREF__melbyr_schema_widgets
#+begin_src haskell
data MRenderWidgetsRequest = MRenderWidgetsRequest
  { widgets :: [MWidget]
  , delimiter :: Maybe MWidget
  -- FIXME: allow duplicate fields once we move to GHC 9 (waiting on mu-haskell)
  , render_options :: Maybe MRenderOptions
  } deriving (Eq, Show, Ord, Generic
             , ToSchema MelbyRendererSchema "RenderWidgetsRequest"
             , FromSchema MelbyRendererSchema "RenderWidgetsRequest")

data MRenderWidgetsResponse = MRenderWidgetsResponse
  { widgets_rendered :: T.Text
  } deriving (Eq, Ord, Show, Generic
             , ToSchema MelbyRendererSchema "RenderWidgetsResponse"
             , FromSchema MelbyRendererSchema "RenderWidgetsResponse")

data MWidget = MWidget
  { str :: T.Text
  , prop :: Maybe MTextProperty
  , drop_delim_left :: Bool
  , drop_delim_right :: Bool
  } deriving (Eq, Ord, Show, Generic
           , ToSchema MelbyRendererSchema "Widget"
           , FromSchema MelbyRendererSchema "Widget")

data MTextProperty = MTextProperty
  { fg :: Maybe MColor
  , bg :: Maybe MColor
  , styles :: [MTextStyle]
  } deriving (Eq, Ord, Show, Generic
           , ToSchema MelbyRendererSchema "TextProperty"
           , FromSchema MelbyRendererSchema "TextProperty")

data MColor = MColor
  { color_oneof :: MColorOneof
  } deriving (Eq, Ord, Show, Generic
           , ToSchema MelbyRendererSchema "Color"
           , FromSchema MelbyRendererSchema "Color")

data MColorOneof
  = MColorOneOf24Bit MColor24Bit
  | MColorOneOf256 Word32
  deriving (Eq, Ord, Show, Generic)

data MColor24Bit = MColor24Bit
  { red :: Word32
  , green :: Word32
  , blue :: Word32
  -- FIXME: add alpha channel?
  } deriving (Eq, Ord, Show, Generic
             , ToSchema MelbyRendererSchema "Color24Bit"
             , FromSchema MelbyRendererSchema "Color24Bit")

data MTextStyle
  = TEXT_STYLE_UNSPECIFIED
  | TEXT_STYLE_BOLD
  | TEXT_STYLE_ITALIC
  | TEXT_STYLE_UNDERLINE
  | TEXT_STYLE_UNDERLINE_DOUBLE
  | TEXT_STYLE_BLINK
  | TEXT_STYLE_BLINK_RAPID
  deriving (Eq, Ord, Show, Generic
           , ToSchema MelbyRendererSchema "TextStyle"
           , FromSchema MelbyRendererSchema "TextStyle")
#+end_src

*** Parse path aliases

#+name: __NREF__melbyr_schema_parse_path_aliases
#+begin_src haskell
data MParsePathAliasesRequest = MParsePathAliasesRequest
  { path_aliases_raw :: T.Text
  } deriving (Eq, Show, Ord, Generic
             , ToSchema MelbyRendererSchema "ParsePathAliasesRequest"
             , FromSchema MelbyRendererSchema "ParsePathAliasesRequest")

data MParsePathAliasesResponse = MParsePathAliasesResponse
  { status :: MParseStatus
  , path_aliases :: M.Map T.Text T.Text
  , error :: T.Text
  } deriving (Eq, Ord, Show, Generic
             , ToSchema MelbyRendererSchema "ParsePathAliasesResponse"
             , FromSchema MelbyRendererSchema "ParsePathAliasesResponse")

data MParseStatus
  = PARSE_STATUS_UNSPECIFIED
  | PARSE_STATUS_ERROR
  | PARSE_STATUS_OK
  deriving (Eq, Ord, Show, Generic
           , ToSchema MelbyRendererSchema "ParseStatus"
           , FromSchema MelbyRendererSchema "ParseStatus")
#+end_src

** Logging

#+name: =MelbyRenderer/Log.hs=
#+begin_src haskell :tangle daemon/lib/melbyd/renderer/lib/MelbyRenderer/Log.hs
module MelbyRenderer.Log where

import Control.Monad.Logger
import Control.Monad.Logger.Prefix
import qualified Data.Text as T

-- FIXME: Make this debug output an environment variable option (only turn it on
-- if lookupEnv says MELBYR_VERBOSE is true).
logDebug :: MonadLogger m => T.Text -> m ()
logDebug t = prefixLogs "melbyr" $ logDebugN t
#+end_src

** Other
*** Pragmas

#+name: __NREF__melbyr_pragmas
#+begin_src haskell
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedLabels #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
-- It's funny that we have to specify this, when we already declare
-- PartialTypeSignatures above.
{-# OPTIONS_GHC -fno-warn-partial-type-signatures #-}
#+end_src

*** Imports

#+name: __NREF__melbyr_imports
#+begin_src haskell
import Control.Monad.Logger hiding (logDebug)
import Data.Version (showVersion)
import Mu.GRpc.Server
import Mu.Server
import Options.Applicative
import System.Environment (lookupEnv)

import Paths_melby_renderer (version)
import MelbyRenderer.Colorizer (getColorizedGitSha)
import MelbyRenderer.GitVersion
import MelbyRenderer.Schema
import MelbyRenderer.PathAliases (parsePathAliases)
import MelbyRenderer.Widgets (renderWidgets)
#+end_src

*** Git versioning

#+name: __NREF__melbyr_gitVersion
#+begin_src haskell
versionOption = infoOption
  (concat [showVersion version, "-g", $(gitVersion)])
  (long "version" <> short 'v' <> help "Show version")
#+end_src

FIXME: should we move this to a common "melby" haskell package?

#+name: __NREF__melbyr_lib_gitVersion
#+begin_src haskell :tangle daemon/lib/melbyd/renderer/lib/MelbyRenderer/GitVersion.hs
module MelbyRenderer.GitVersion
  ( gitVersion
  ) where

import Data.Time.LocalTime
import Language.Haskell.TH
import System.Environment
import System.Process

gitVersion :: Q Exp
gitVersion = stringE =<< runIO getCombinedInfo

getCombinedInfo :: IO String
getCombinedInfo = do
  gi <- getGitInfo
  ti <- getTimeInfo
  pure $ concat [gi, "  (", ti, ")"]

getGitInfo :: IO String
getGitInfo = do
  maybeProjectRoot <- lookupEnv "MELBY_PROJECT_ROOT"
  case maybeProjectRoot of
    Just projectRoot -> readProcess "git" ["-C", projectRoot, "describe", "--abbrev=10", "--always", "--dirty"] ""
    Nothing -> pure "-unknown"

getTimeInfo :: IO String
getTimeInfo = show <$> getZonedTime
#+end_src

* Build system

** Makefile

This follows the Makefile for =melbyc= (FIXME: add link).

#+begin_src makefile :tangle daemon/lib/melbyd/renderer/Makefile
ZLIB_SO_DIR=$(shell pkg-config --libs-only-L zlib)
ZLIB_H_DIR=$(shell pkg-config --cflags-only-I zlib)

all: melbyr

melbyr:
	MELBY_PROJECT_ROOT=$(PWD) stack build \
		--copy-bins \
		--local-bin-path $(PWD) \
		--no-nix-pure \
		--extra-lib-dirs=$(ZLIB_SO_DIR:-L%=%) \
		--extra-include-dirs=$(ZLIB_H_DIR:-I%=%)
.PHONY: melbyr

ghci:
	stack exec -- ghci
.PHONY: ghci

# This avoids building the main executable on top of the base library and test
# executable. For various reasons, Stack always builds the main executable
# binary. See https://github.com/commercialhaskell/stack/issues/5647#issuecomment-1106796448.
test:
	stack build melby-renderer:test
.PHONY: test
#+end_src

** Cabal

#+name: melby-renderer.cabal
#+begin_src haskell-cabal :tangle daemon/lib/melbyd/renderer/melby-renderer.cabal
name: melby-renderer
version: 1.0.0.0
author: Linus Arver
maintainer: linusa@google.com
category: Utility
build-type: Simple
cabal-version: >=1.10
license: Apache-2.0
license-file: LICENSE
data-files: lib/MelbyRenderer/melby_renderer.proto

executable melbyr
  main-is: melby-renderer.hs
  default-language: Haskell2010
  other-modules:
    Paths_melby_renderer
  default-extensions:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  ghc-options:
    -O2 -Werror -threaded -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  build-depends:
      base >= 4.8
    , melby-renderer
    , monad-logger >= 0.3 && <0.4
    , mu-grpc-server >=0.3.0.0
    , mu-rpc >= 0.4.0
    , optparse-applicative >= 0.16.1.0

library
  default-language: Haskell2010
  exposed-modules:
    MelbyRenderer.Colorizer
    MelbyRenderer.GitVersion
    MelbyRenderer.Log
    MelbyRenderer.PathAliases
    MelbyRenderer.Schema
    MelbyRenderer.Widgets
  hs-source-dirs:
    lib
  default-extensions:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  ghc-options:
    -O2 -Werror -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  build-depends:
      base >= 4.8
    , aeson
    , ansi-terminal
    , base16-bytestring
    , bytestring
    , colour
    , containers >= 0.6.5.1
    , megaparsec >= 9.0.1
    , monad-logger >= 0.3 && <0.4
    , monad-logger-prefix >= 0.1.12 && <0.2
    , mu-protobuf >= 0.4.0
    , mu-grpc-server >=0.3.0.0
    , mu-rpc >= 0.4.0
    , mu-schema >= 0.3.0
    , process
    , template-haskell
    , text >=1.2 && <2
    , time

test-suite test
  type: exitcode-stdio-1.0
  hs-source-dirs: test
  main-is: Main.hs
  default-language: Haskell2010
  default-extensions:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  ghc-options:
    -O2 -Werror -threaded -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  build-depends:
      base >= 4.8
    , containers >= 0.6.5.1
    , melby-renderer
    , hspec >=2.0 && <3.0
    , hspec-expectations >=0.8 && <0.9
    , hspec-megaparsec
    , megaparsec >= 9.0.1
    , neat-interpolation
#+end_src

#+name: =cabal.project=
#+begin_src haskell-cabal :tangle daemon/lib/melbyd/renderer/cabal.project
executable-stripping: True
packages:
  ./melby-renderer.cabal
#+end_src

** Nix

#+begin_src nix :tangle daemon/lib/melbyd/renderer/melby-renderer.nix
let
  sources = import ../../../../package/nix/sources.nix;
  pkgs = import sources.nixpkgs { };
  fakeGit = pkgs.writeShellScriptBin "git"
  ''
    echo -unknown
  '';
  files = [
    ./LICENSE
    ./cabal.project
    ./lib
    ./lib/MelbyRenderer
    ./lib/MelbyRenderer/Colorizer.hs
    ./lib/MelbyRenderer/GitVersion.hs
    ./lib/MelbyRenderer/Log.hs
    ./lib/MelbyRenderer/melby_renderer.proto
    ./lib/MelbyRenderer/PathAliases.hs
    ./lib/MelbyRenderer/Schema.hs
    ./lib/MelbyRenderer/Widgets.hs
    ./melby-renderer.cabal
    ./melby-renderer.hs
    ./melby-renderer.nix
    ./stack.yaml
    ./stack.yaml.lock
  ];
  macOS-security =
    # Make `/usr/bin/security` available in `PATH`, which is needed for stack
    # on darwin which calls this binary to find certificates. See
    # https://github.com/tweag/rules_haskell/commit/31171a520f49f263895112678ac93c7ed958ead1.
    pkgs.writeScriptBin "security" ''exec /usr/bin/security "$@"'';
in

{ ghc }:

pkgs.haskell.lib.buildStackProject {
  inherit ghc;
  name = "melby-renderer";
  src = ./.;
  buildInputs = [
    pkgs.zlib
    fakeGit
  ] ++ pkgs.lib.optionals pkgs.stdenv.isDarwin [pkgs.llvm_10 macOS-security];
}
#+end_src

** Stack

#+begin_src yaml :tangle daemon/lib/melbyd/renderer/stack.yaml
resolver: lts-18.28
allow-newer: true

packages:
- .

extra-deps:
- compendium-client-0.2.1.1@sha256:cd477438d507273b34b82581ade333921ae997c1618b48af0c1da2a4968623e0,1203
- graphql-1.0.3.0
- http2-2.0.6
- http2-client-0.10.0.0
- http2-client-grpc-0.8.0.0
- http2-grpc-proto3-wire-0.1.0.0
- http2-grpc-types-0.5.0.0
- hw-kafka-conduit-2.7.0
- mu-avro-0.4.0.4@sha256:10e317c633c5152a26e89becba749456b76f70eb640d1c0b2ccdc0e45a7ef5da,2096
- mu-grpc-common-0.4.0.0@sha256:568b5879cd67c0bc0e956d53fb87552bb6d9a6287c5d1b09e2284ed5b04de418,1394
- mu-optics-0.3.0.1@sha256:c3494c71c6300e6a0dcb77c9782481150956e912c1b47fccd69cbb795e461d52,1068
- mu-protobuf-0.4.2.0@sha256:4787a2688abdda107e150736433b61448acdf0b71eb0c174232239b4c143f78b,2119
- mu-rpc-0.5.0.2@sha256:470f5bc372de1b212f625f9e7310cdf82b7fa41ddea03e092fccff0cd9e19db1,1430
- mu-grpc-server-0.5.0.0@sha256:c67bd7c5dcc87e11ec34ac07b4d18fb1f6de036f58db4176274e6826099fe0a8,2749
- mu-schema-0.3.1.2@sha256:c05e58de29d50376638d19dd3357cd3644d39f984664484f3568d5305b3034d9,1933
- stm-containers-1.2
- stm-hamt-1.2.0.7
- tracing-0.0.7.2
- tracing-control-0.0.7.3
- warp-3.3.14
- warp-grpc-0.4.0.1
#+end_src

** .gitignore

#+begin_src text :tangle daemon/lib/melbyd/renderer/.gitignore
dist-newstyle
melbyr
.stack-work
#+end_src
