<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Developer Manual</title>
<meta name="author" content="Linus Arver" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&family=Source+Sans+3:ital,wght@0,200..900;1,200..900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900">
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<script src="lilac.js"></script>
<link rel="stylesheet" type="text/css" href="syntax-highlighting.css"/>
<link rel="stylesheet" type="text/css" href="lilac.css" />
<!-- LILAC_HTML_HEAD -->
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@4.0.0-beta.4/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Developer Manual</h1>
<div id="table-of-contents" role="doc-toc">

<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h-Overview-of-this-manual">1. Overview of this manual</a>
<ul>
<li><a href="#h-Tech-stack">1.1. Tech stack</a></li>
<li><a href="#h-Architectural-overview-of-Melby-components">1.2. Architectural overview of Melby components</a></li>
</ul>
</li>
<li><a href="#h-Build-System-for-Literate-Programming">2. Build System for Literate Programming</a>
<ul>
<li><a href="#h-Overview-of-how-LP-is-used-in-this-project">2.1. Overview of how LP is used in this project</a></li>
<li><a href="#h-Weaving--generating-the-docs">2.2. Weaving (generating the docs)</a>
<ul>
<li><a href="#h-Emacs-customizations">2.2.1. Emacs customizations</a></li>
<li><a href="#h-Diagrams">2.2.2. Diagrams</a></li>
<li><a href="#h-Ignore-woven-HTML-from--git-diff">2.2.3. Ignore woven HTML from <code>git diff</code></a>
<ul>
<li><a href="#h-git-add--p">2.2.3.1. <code>git add -p</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-Tangling--generating-the-source-code">2.3. Tangling (generating the source code)</a>
<ul>
<li><a href="#h-Copyright-headers">2.3.1. Copyright headers</a></li>
<li><a href="#h-gitignore">2.3.2. .gitignore</a></li>
<li><a href="#h-Post-tangled-phase">2.3.3. Post-tangled phase</a>
<ul>
<li><a href="#h-Elixir">2.3.3.1. Elixir</a></li>
<li><a href="#h-Rust">2.3.3.2. Rust</a></li>
<li><a href="#h-Haskell">2.3.3.3. Haskell</a></li>
<li><a href="#h-Lua">2.3.3.4. Lua</a></li>
</ul>
</li>
<li><a href="#h-Audit-of-what-s-tangled">2.3.4. Audit of what's tangled</a></li>
</ul>
</li>
<li><a href="#h-Glossary">2.4. Glossary</a></li>
</ul>
</li>
<li><a href="#h-Build-System-for-Packaging-Melby">3. Build System for Packaging Melby</a>
<ul>
<li><a href="#h-Introduction">3.1. Introduction</a>
<ul>
<li><a href="#h-What-we-must-build">3.1.1. What we must build</a></li>
</ul>
</li>
<li><a href="#h-Development-environment">3.2. Development environment</a>
<ul>
<li><a href="#h-nix-direnv">3.2.1. nix-direnv</a></li>
<li><a href="#h-Nix-shell">3.2.2. Nix shell</a>
<ul>
<li><a href="#h-Make-Stack-understand-Nix">3.2.2.1. Make Stack understand Nix</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-Packaging">3.3. Packaging</a>
<ul>
<li><a href="#h-Releasing">3.3.1. Releasing</a></li>
<li><a href="#h-Makefile">3.3.2. Makefile</a></li>
<li><a href="#h-gitignore-1">3.3.3. .gitignore</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-How-to-hack-on-this-project">4. How to hack on this project</a>
<ul>
<li><a href="#h-Building-each-component">4.1. Building each component</a>
<ul>
<li><a href="#h-melbyr---renderer--required-by-daemon">4.1.1. <code>melbyr</code> (renderer; required by daemon)</a></li>
<li><a href="#h-melbyd---daemon">4.1.2. <code>melbyd</code> (daemon)</a></li>
</ul>
</li>
<li><a href="#h-melbyc---client">4.2. <code>melbyc</code> (client)</a></li>
<li><a href="#h-Testing-local-changes">4.3. Testing local changes</a></li>
<li><a href="#h-Common-scenarios">4.4. Common scenarios</a>
<ul>
<li><a href="#h-Hacking-on-the-Lua-config">4.4.1. Hacking on the Lua config</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-melbyc">5. melbyc</a>
<ul>
<li><a href="#h-Purpose">5.1. Purpose</a></li>
<li><a href="#h-Design-by-contract">5.2. Design by contract</a>
<ul>
<li><a href="#h-Talking-to-the-daemon">5.2.1. Talking to the daemon</a>
<ul>
<li><a href="#h-Lua-1">5.2.1.1. Lua</a></li>
<li><a href="#h-Proto">5.2.1.2. Proto</a></li>
</ul>
</li>
<li><a href="#h-Running-very-quickly">5.2.2. Running very quickly</a></li>
<li><a href="#h-Command-line-argument-handling">5.2.3. Command line argument handling</a></li>
</ul>
</li>
<li><a href="#h-Code-overview">5.3. Code overview</a>
<ul>
<li><a href="#h-Overall-structure">5.3.1. Overall structure</a></li>
</ul>
</li>
<li><a href="#h-Business-logic">5.4. Business logic</a></li>
<li><a href="#h-Boilerplate">5.5. Boilerplate</a>
<ul>
<li><a href="#h-Option-handling">5.5.1. Option handling</a></li>
<li><a href="#h-Main">5.5.2. Main</a></li>
<li><a href="#h-gRPC-schema">5.5.3. gRPC schema</a></li>
<li><a href="#h-Other">5.5.4. Other</a>
<ul>
<li><a href="#h-Pragmas">5.5.4.1. Pragmas</a></li>
<li><a href="#h-Imports">5.5.4.2. Imports</a></li>
<li><a href="#h-Git-versioning">5.5.4.3. Git versioning</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-Build-system">5.6. Build system</a>
<ul>
<li><a href="#h-Makefile-1">5.6.1. Makefile</a></li>
<li><a href="#h-Cabal">5.6.2. Cabal</a></li>
<li><a href="#h-melbyc-nix">5.6.3. melbyc.nix</a></li>
<li><a href="#h-Stack">5.6.4. Stack</a></li>
<li><a href="#h-gitignore-2">5.6.5. .gitignore</a></li>
</ul>
</li>
<li><a href="#h-Rust-client">5.7. Rust client</a>
<ul>
<li><a href="#h-Code-overview-1">5.7.1. Code overview</a>
<ul>
<li><a href="#h-Main-function">5.7.1.1. Main function</a></li>
</ul>
</li>
<li><a href="#h-Packaging-1">5.7.2. Packaging</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-melbyd">6. melbyd</a>
<ul>
<li><a href="#h-Purpose-1">6.1. Purpose</a></li>
<li><a href="#h-Proto-1">6.2. Proto</a></li>
<li><a href="#h-Tech-stack-1">6.3. Tech stack</a></li>
<li><a href="#h-Life-of-a-request-to-render-a-shell-prompt">6.4. Life of a request to render a shell prompt</a></li>
<li><a href="#h-Internals">6.5. Internals</a>
<ul>
<li><a href="#h-Standard-Resource-Server">6.5.1. Standard Resource Server</a>
<ul>
<li><a href="#h-Proto-2">6.5.1.1. Proto</a></li>
<li><a href="#h-Implementation">6.5.1.2. Implementation</a></li>
<li><a href="#h-Tick">6.5.1.3. Tick</a></li>
<li><a href="#h-Marking-staleness">6.5.1.4. Marking staleness</a>
<ul>
<li><a href="#h-Filesystem-based-staleness">6.5.1.4.1. Filesystem-based staleness</a></li>
<li><a href="#h-Duration-based-staleness--polling">6.5.1.4.2. Duration-based staleness (polling)</a></li>
</ul>
</li>
<li><a href="#h-Graceful-shutdown">6.5.1.5. Graceful shutdown</a></li>
<li><a href="#h-Client-interface">6.5.1.6. Client interface</a></li>
<li><a href="#h-Supervisor">6.5.1.7. Supervisor</a></li>
</ul>
</li>
<li><a href="#h-Shell-Logger-GenServer--SLG">6.5.2. Shell Logger GenServer (SLG)</a>
<ul>
<li><a href="#h-Tick-1">6.5.2.1. Tick</a></li>
<li><a href="#h-Handle-PubSub-messages">6.5.2.2. Handle PubSub messages</a></li>
<li><a href="#h-Graceful-shutdown-1">6.5.2.3. Graceful shutdown</a></li>
<li><a href="#h-Client-interface-1">6.5.2.4. Client interface</a></li>
<li><a href="#h-Supervisor-1">6.5.2.5. Supervisor</a></li>
</ul>
</li>
<li><a href="#h-Current-path--path-shortening">6.5.3. Current path (path shortening)</a>
<ul>
<li><a href="#h-Path">6.5.3.1. Path</a></li>
<li><a href="#h-Caching">6.5.3.2. Caching</a></li>
</ul>
</li>
<li><a href="#h-Colors">6.5.4. Colors</a></li>
<li><a href="#h-Entrypoint-for-client">6.5.5. Entrypoint for client</a>
<ul>
<li><a href="#h-melbyr-dependency">6.5.5.1. melbyr dependency</a></li>
</ul>
</li>
<li><a href="#h-gRPC-services">6.5.6. gRPC services</a>
<ul>
<li><a href="#h-View--melbyr-interface">6.5.6.1. View (melbyr interface)</a></li>
<li><a href="#h-Standard-Resource-Service">6.5.6.2. Standard Resource Service</a>
<ul>
<li><a href="#h-Motivation">6.5.6.2.1. Motivation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-Lua-API">6.5.7. Lua API</a>
<ul>
<li><a href="#h-Melbyd-LuaInterop">6.5.7.1. <code>Melbyd.LuaInterop</code></a>
<ul>
<li><a href="#h-Validation">6.5.7.1.1. Validation</a></li>
</ul>
</li>
<li><a href="#h-Auto-loaded-Elixir-module-exposed-to-Lua---Melbyd-LuaSdk-">6.5.7.2. Auto-loaded Elixir module exposed to Lua (<code>Melbyd.LuaSdk</code>)</a>
<ul>
<li><a href="#h-Render-widgets--convert-string--objects--into-strings-with-ANSI-escape-codes">6.5.7.2.1. Render widgets (convert string "objects" into strings with ANSI escape codes)</a></li>
<li><a href="#h-Pretty-paths">6.5.7.2.2. Pretty paths</a></li>
<li><a href="#h-Colorized-Git-SHA">6.5.7.2.3. Colorized Git SHA</a></li>
<li><a href="#h-Time">6.5.7.2.4. Time</a></li>
<li><a href="#h-Export-to-shell-script">6.5.7.2.5. Export to shell script</a></li>
<li><a href="#h-Expected-functions-in-the-Lua-file-for-SRS">6.5.7.2.6. Expected functions in the Lua file for SRS</a></li>
<li><a href="#h-Messaging">6.5.7.2.7. Messaging</a></li>
<li><a href="#h-Other-1">6.5.7.2.8. Other</a></li>
</ul>
</li>
<li><a href="#h-Boilerplate-1">6.5.7.3. Boilerplate</a></li>
<li><a href="#h-Luerl-util">6.5.7.4. Luerl util</a>
<ul>
<li><a href="#h-Reading-from-Lua-tables-returned-by-Luerl">6.5.7.4.1. Reading from Lua tables returned by Luerl</a></li>
<li><a href="#h-Array-to-native-list">6.5.7.4.2. Array to native list</a></li>
<li><a href="#h-Table-to-native-map">6.5.7.4.3. Table to native map</a></li>
<li><a href="#h-Lua-tables-to-Elixir-maps">6.5.7.4.4. Lua tables to Elixir maps</a></li>
</ul>
</li>
<li><a href="#h-Tests">6.5.7.5. Tests</a></li>
</ul>
</li>
<li><a href="#h-Purpose-2">6.5.8. Purpose</a></li>
<li><a href="#h-Design-by-contract-1">6.5.9. Design by contract</a>
<ul>
<li><a href="#h-Communication-between-melbyd-and-melbyr">6.5.9.1. Communication between melbyd and melbyr</a>
<ul>
<li><a href="#h-Proto-3">6.5.9.1.1. Proto</a></li>
</ul>
</li>
<li><a href="#h-Running-very-quickly-1">6.5.9.2. Running very quickly</a></li>
<li><a href="#h-Command-line-argument-handling-1">6.5.9.3. Command line argument handling</a></li>
</ul>
</li>
<li><a href="#h-Code-overview-2">6.5.10. Code overview</a>
<ul>
<li><a href="#h-Overall-structure-1">6.5.10.1. Overall structure</a></li>
</ul>
</li>
<li><a href="#h-Business-logic-1">6.5.11. Business logic</a>
<ul>
<li><a href="#h-Widget-Rendering-System">6.5.11.1. Widget Rendering System</a>
<ul>
<li><a href="#h-Widget-field-reference">6.5.11.1.1. Widget field reference</a></li>
<li><a href="#h-Optional-widget-delimiters">6.5.11.1.2. Optional widget delimiters</a></li>
<li><a href="#h-Implementation-1">6.5.11.1.3. Implementation</a></li>
</ul>
</li>
<li><a href="#h-Colorized-Git-SHA-1">6.5.11.2. Colorized Git SHA</a>
<ul>
<li><a href="#h-Overview">6.5.11.2.1. Overview</a></li>
<li><a href="#h-24-bit-colors">6.5.11.2.2. 24-bit colors</a></li>
</ul>
</li>
<li><a href="#h-Parse-path-aliases">6.5.11.3. Parse path aliases</a></li>
</ul>
</li>
<li><a href="#h-Boilerplate-2">6.5.12. Boilerplate</a>
<ul>
<li><a href="#h-Option-handling-1">6.5.12.1. Option handling</a></li>
<li><a href="#h-Main-1">6.5.12.2. Main</a></li>
<li><a href="#h-gRPC-schema-1">6.5.12.3. gRPC schema</a>
<ul>
<li><a href="#h-Colorized-Git-SHA-2">6.5.12.3.1. Colorized Git SHA</a></li>
<li><a href="#h-Render-options">6.5.12.3.2. Render options</a></li>
<li><a href="#h-Widgets">6.5.12.3.3. Widgets</a></li>
<li><a href="#h-Parse-path-aliases-1">6.5.12.3.4. Parse path aliases</a></li>
</ul>
</li>
<li><a href="#h-Logging">6.5.12.4. Logging</a></li>
<li><a href="#h-Other-2">6.5.12.5. Other</a>
<ul>
<li><a href="#h-Pragmas-1">6.5.12.5.1. Pragmas</a></li>
<li><a href="#h-Imports-1">6.5.12.5.2. Imports</a></li>
<li><a href="#h-Git-versioning-1">6.5.12.5.3. Git versioning</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-Build-system-1">6.5.13. Build system</a>
<ul>
<li><a href="#h-Makefile-2">6.5.13.1. Makefile</a></li>
<li><a href="#h-Cabal-1">6.5.13.2. Cabal</a></li>
<li><a href="#h-Nix">6.5.13.3. Nix</a></li>
<li><a href="#h-Stack-1">6.5.13.4. Stack</a></li>
<li><a href="#h-gitignore-3">6.5.13.5. .gitignore</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-Installation">6.6. Installation</a>
<ul>
<li><a href="#h-Linux">6.6.1. Linux</a></li>
</ul>
</li>
<li><a href="#h-Build-system-2">6.7. Build system</a>
<ul>
<li><a href="#h-Elixir-1">6.7.1. Elixir</a>
<ul>
<li><a href="#h-Makefile-3">6.7.1.1. Makefile</a></li>
<li><a href="#h-gitattributes">6.7.1.2. gitattributes</a></li>
<li><a href="#h-Mix-tool-configuration">6.7.1.3. Mix tool configuration</a></li>
<li><a href="#h-gitignore-4">6.7.1.4. .gitignore</a></li>
<li><a href="#h-Formatter">6.7.1.5. Formatter</a></li>
<li><a href="#h-protoc-gen-elixir-nix">6.7.1.6. protoc-gen-elixir.nix</a></li>
<li><a href="#h-Mix-release">6.7.1.7. Mix release</a></li>
<li><a href="#h-Additional-application-configuration">6.7.1.8. Additional application configuration</a></li>
</ul>
</li>
<li><a href="#h-Rust-NIFs-integration">6.7.2. Rust NIFs integration</a>
<ul>
<li><a href="#h-Elixir-wrapper">6.7.2.1. Elixir wrapper</a></li>
<li><a href="#h-Rust-wrapper">6.7.2.2. Rust wrapper</a></li>
<li><a href="#h-Boilerplate-3">6.7.2.3. Boilerplate</a>
<ul>
<li><a href="#h-Makefile-4">6.7.2.3.1. Makefile</a></li>
<li><a href="#h-Cargo">6.7.2.3.2. Cargo</a></li>
<li><a href="#h-gitignore-5">6.7.2.3.3. .gitignore</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-Haskell--melbyr">6.7.3. Haskell (melbyr)</a>
<ul>
<li><a href="#h-Set-up-GHCi-environment">6.7.3.1. Set up GHCi environment</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-Tests-1">6.8. Tests</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-h-Overview-of-this-manual" class="outline-2">
<h2 id="h-Overview-of-this-manual"><span class="section-number-2">1.</span> Overview of this manual</h2>
<div class="outline-text-2" id="text-h-Overview-of-this-manual">
<p>
This manual covers several topics:
</p>

<ul class="org-ul">
<li>The build system for Literate Programming (LP), which explains how LP is
used in this project.</li>

<li>The build system for packaging Melby, which explains how Melby can be
packaged up using the Nix Package Manager. This is useful for developing
Melby locally (setting up a development environment).</li>

<li>The daemon and client programs that make up the Melby implementation.</li>
</ul>

<p>
Before we get into the details, let's take a quick look at the tech stack used
and the architectural overview of how the different pieces fit together.
</p>
</div>

<div id="outline-container-h-Tech-stack" class="outline-3">
<h3 id="h-Tech-stack"><span class="section-number-3">1.1.</span> Tech stack</h3>
<div class="outline-text-3" id="text-h-Tech-stack">
<p>
We use several programming languages: Elixir, Lua, Rust, and Haskell.
</p>

<ul class="org-ul">
<li><b>Elixir</b>: Elixir is the main language used in this project because of it
leverages the famed Erlang runtime, known for its world-class reliability.
Elixir is used for programming the base system, as well as testing all of
the components together.</li>

<li><b>Lua</b>: Lua is used as our configuration language, because of its power
(especially by integrating with <a href="https://github.com/rvirding/luerl">Luerl</a>, which allows us to interop with
Elixir) and flexibility.</li>

<li><b>Rust</b>: Rust is used in some places where static typing and performance might
come in handy. Typically it's used for smaller, pure (lacking side effects)
functions as NIFs (Native Inline Functions) inside Elixir.</li>

<li><b>Haskell</b>: Haskell is used for the Melby client binary <code>melbyc</code>, and also the
<code>melbyr</code> rendering service. Haskell maximizes code maintainability and
stability, and so it is the preferred language for building smaller
independent components outside of the base (Elixir) system.</li>
</ul>

<p>
We also use <a href="https://en.wikipedia.org/wiki/Literate_programming">Literate Programming</a> (LP). To this end, we use Emacs Org mode
(<code>*.org</code> files) as the source of truth. These files are <i>tangled</i> into the above
languages for the application binaries. These same Org files are <i>woven</i> to
produce HTML files for documentation (what you are probably reading now). We use
several languages for weaving:
</p>

<ul class="org-ul">
<li><b>Emacs Lisp</b>: We use Emacs Lisp to tame Emacs Org mode for LP. Emacs Org mode
is used for LP in this project because it is probably the most flexible and
widely-used LP system out there. LaTeX + Noweb is another possibility, but
it was not chosen because Org mode by default looks reasonable in plaintext.</li>

<li><b>TikZ</b>: <a href="https://en.wikipedia.org/wiki/PGF/TikZ">PGF/TikZ</a> is used for writing all of the diagrams and figures used for
documentation. This is because TikZ is extremely stable, powerful, and
flexible for creating diagrams of all sorts. SVG is the preferred file
format.</li>

<li><b>HTML/CSS</b>: HTML and CSS power the documentation. Although PDF output can be
very beautiful, HTML is simply more accessible and also does not require
code listings to be broken across multiple pages.</li>
</ul>
</div>
</div>

<div id="outline-container-h-Architectural-overview-of-Melby-components" class="outline-3">
<h3 id="h-Architectural-overview-of-Melby-components"><span class="section-number-3">1.2.</span> Architectural overview of Melby components</h3>
<div class="outline-text-3" id="text-h-Architectural-overview-of-Melby-components">

<div id="org0000000" class="figure">
<p><img src="./image/architecture-overall.svg" alt="architecture-overall.svg" class="org-svg" width="700px">
</p>
</div>

<p>
Melby uses a client/server architecture. There are two main parts:
</p>

<div class="sidenote" id="org0000001">
<p>
<code>melbyd</code> is the daemon, which acts as a server in the client/server
architecture. We call it a daemon because it is expected to have direct access
to the local machine which is relevant to the client. This is unlike typical web
servers where the local machine characteristics of such servers are irrelevant
to clients.
</p>

</div>

<ol class="org-ol">
<li><p>
<code>melbyd</code>: The daemon (server), which itself is composed of two smaller
pieces:
</p>

<p>
a) The core application written in Elixir and Rust.
</p>

<p>
b) The renderer (<code>melbyr</code>) written in Haskell. This is a separate child
   process controlled by the core app.
</p></li>

<li><p>
<code>melbyc</code>: The client, written in Haskell.
</p>

<p>
a) <code>melbyc-rust</code> is an equivalent client written in Rust.
</p></li>
</ol>

<p>
The pieces above work like this:
</p>

<ol class="org-ol">
<li>User writes a Lua script to specify what pieces of information it wants,
and how it should be presented.</li>

<li><code>melbyc</code> sends this script to <code>melbyd</code> for processing.</li>

<li><code>melbyd</code> gathers the necessary data (e.g., Git status or Kubernetes metadata)
and sends it <code>melbyr</code> for generating the final view (an arbitrary string).</li>

<li>The view is sent back to <code>melbyc</code>, which then prints it to STDOUT.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-h-Build-System-for-Literate-Programming" class="outline-2">
<h2 id="h-Build-System-for-Literate-Programming"><span class="section-number-2">2.</span> Build System for Literate Programming</h2>
<div class="outline-text-2" id="text-h-Build-System-for-Literate-Programming">
</div>

<div id="outline-container-h-Overview-of-how-LP-is-used-in-this-project" class="outline-3">
<h3 id="h-Overview-of-how-LP-is-used-in-this-project"><span class="section-number-3">2.1.</span> Overview of how LP is used in this project</h3>
<div class="outline-text-3" id="text-h-Overview-of-how-LP-is-used-in-this-project">
<p>
Melby uses <a href="https://github.com/listx/lilac">Lilac</a>, a literate programming tool.
</p>
</div>
</div>

<div id="outline-container-h-Weaving--generating-the-docs" class="outline-3">
<h3 id="h-Weaving--generating-the-docs"><span class="section-number-3">2.2.</span> Weaving (generating the docs)</h3>
<div class="outline-text-3" id="text-h-Weaving--generating-the-docs">
<p>
Weaving is conceptually simpler than tangling because there is no extra step &#x2014;
the output is an HTML page and that is something that we can use directly
(unlike program source code, which may require additional compilation into a
binary, depending on the language). We also limit ourselves to only HTML for
simplicity (in particular, we don't have to worry about page breaks).
</p>

<p>
Weaving for requires the following dependencies:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Dependency</td>
<td class="org-left">Why</td>
<td class="org-left">How to install it</td>
</tr>

<tr>
<td class="org-left">GNU Make</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">emacs</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">texlive</td>
<td class="org-left">Diagrams</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">pdf2svg</td>
<td class="org-left">Diagrams</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">inkscape</td>
<td class="org-left">Diagrams</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">html-beautify</td>
<td class="org-left">Format HTML with indentation</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
For Melby, we have a top-level <code>Makefile</code> so that we can run some <code>make</code> commands
on the command line (instead of needing to invoke emacs directly).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name"><code>Makefile</code></label><span class="lilac-caption-link-symbol"><a href="#code-Makefile--code">&#x1f517;</a></span></div><pre class="src src-makefile" id="code-Makefile--code"><span class="org-variable-name">PROJ_ROOT</span> := $(<span class="org-variable-name">shell</span> git rev-parse --show-toplevel)
<span class="org-variable-name">LILAC_ROOT</span> := $(<span class="org-variable-name">PROJ_ROOT</span>)/deps/elisp/lilac
<span class="org-variable-name">PROCS</span> := $(<span class="org-variable-name">shell</span> nproc)
define run_emacs
    <span class="org-variable-name">LILAC_ROOT</span>=$(<span class="org-variable-name">LILAC_ROOT</span>) PROJ_ROOT=$(<span class="org-variable-name">PROJ_ROOT</span>) emacs $(<span class="org-variable-name">2</span>) \
        --quick --batch --kill \
        --load $(<span class="org-variable-name">LILAC_ROOT</span>)/lilac.el \
        --load $(<span class="org-variable-name">PROJ_ROOT</span>)/melby.el \
        <span class="org-variable-name">--eval</span>=<span class="org-string">"$(</span><span class="org-string"><span class="org-variable-name">1</span></span><span class="org-string">)"</span>
endef

<span class="org-makefile-targets">all</span>: tangle weave

<span class="org-makefile-targets">all-build-tools</span>: tangle-build-tools weave

<span class="org-makefile-targets">fresh-repl</span>:
    make -C $(<span class="org-variable-name">PROJ_ROOT</span>) -j$(<span class="org-variable-name">PROCS</span>) tangle
    make -C $(<span class="org-variable-name">PROJ_ROOT</span>)/daemon repl

<span class="lilac-child-link-from-parent"><a href="#__NREF__Makefile-tangle">Makefile-tangle</a></span>

<span class="org-makefile-targets">weave</span>: build-html build-images

<span class="org-makefile-targets">weave-quick</span>:
    <span class="org-variable-name">MELBY_LP_QUICK</span>=1 make -C ${<span class="org-variable-name">PROJ_ROOT</span>} -j$(<span class="org-variable-name">PROCS</span>) build-html build-images
<span class="org-makefile-targets">.PHONY</span>: weave-quick

<span class="org-makefile-targets">weave-profile</span>:
    $(<span class="org-variable-name">call</span> run_emacs,(lilac-publish-profile),main.org)
<span class="org-makefile-targets">.PHONY</span>: weave-profile

<span class="org-makefile-targets">weave-profile-inspect</span>:
    emacs -Q --load $(<span class="org-variable-name">LILAC_ROOT</span>)/lilac.el \
        <span class="org-variable-name">--eval</span>=<span class="org-string">"(profiler-find-profile \"emacs-profile-weave.txt\"))"</span>
<span class="org-makefile-targets">.PHONY</span>: weave-profile-inspect

<span class="org-makefile-targets">build-images</span>: image-org
    $(<span class="org-variable-name">MAKE</span>) -C image

<span class="org-makefile-targets">build-html</span>: main.html image.html developer-manual.html user-manual.html

<span class="org-makefile-targets">main.html</span>: developer-manual.html image.html main.org
<span class="org-makefile-space">    #</span><span class="org-comment">$(</span><span class="org-comment"><span class="org-variable-name">call</span></span><span class="org-comment"> run_emacs,(lilac-gen-css-and-exit),main.org)</span>
    $(<span class="org-variable-name">call</span> run_emacs,(lilac-publish),main.org)

<span class="org-makefile-targets">developer-manual.html</span>: developer-manual.org
    $(<span class="org-variable-name">call</span> run_emacs,(lilac-publish),developer-manual.org)

<span class="org-makefile-targets">user-manual.html</span>: user-manual.org developer-manual.html
    $(<span class="org-variable-name">call</span> run_emacs,(lilac-publish),user-manual.org)

<span class="org-makefile-targets">image.html</span>: image.org
    $(<span class="org-variable-name">call</span> run_emacs,(lilac-publish),image.org)

<span class="org-makefile-targets">.PHONY</span>: all all-build-tools weave

<span class="org-comment-delimiter"># </span><span class="org-comment">Enter development environment.</span>
<span class="org-makefile-targets">shell</span>:
    nix-shell --pure
</pre></div></div>
</div>

<div id="outline-container-h-Emacs-customizations" class="outline-4">
<h4 id="h-Emacs-customizations"><span class="section-number-4">2.2.1.</span> Emacs customizations</h4>
<div class="outline-text-4" id="text-h-Emacs-customizations">
<p>
Because Lilac does not come with built-in support for syntax highlighting for
all of the different programming languages we use, we have to import them here
manually. That way, when we run <code>(lilac-publish)</code> we'll get all of the syntax
highlighting that we need.
</p>

<div class="org-src-container"><pre class="src src-emacs-lisp" id="nil-1"><span class="org-comment-delimiter">;; </span><span class="org-comment">Built-in packages (distributed with Emacs).</span>
(<span class="org-keyword">require</span> '<span class="org-constant">tex-mode</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">elisp-mode</span>)

(<span class="org-keyword">defun</span> <span class="org-function-name">melby-load</span> (path)
    (add-to-list 'load-path (concat
                             (getenv <span class="org-string">"PROJ_ROOT"</span>)
                             (concat <span class="org-string">"/deps/elisp/"</span>
                                     path))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Third-party packages (checked in as Git submodules)</span>
(melby-load <span class="org-string">"dash.el"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">dash</span>) <span class="org-comment-delimiter">; </span><span class="org-comment">required by magit</span>

(melby-load <span class="org-string">"compat.el"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">compat</span>) <span class="org-comment-delimiter">; </span><span class="org-comment">required by magit</span>

(melby-load <span class="org-string">"haskell-mode"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">haskell-mode</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">haskell-cabal</span>)

(melby-load <span class="org-string">"magit/lisp"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">magit-section</span>) <span class="org-comment-delimiter">; </span><span class="org-comment">required by nix-mode</span>

(melby-load <span class="org-string">"nix-mode"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">nix-mode</span>)

(melby-load <span class="org-string">"rust-mode"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">rust-mode</span>)

(melby-load <span class="org-string">"emacs-elixir"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">elixir-mode</span>)

(melby-load <span class="org-string">"lua-mode"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">lua-mode</span>)

(melby-load <span class="org-string">"protobuf/editors"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">protobuf-mode</span>)

(melby-load <span class="org-string">"yaml-mode"</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">yaml-mode</span>)

(<span class="org-keyword">setq</span> org-latex-compiler <span class="org-string">"lualatex"</span>)
</pre></div>
</div>
</div>

<div id="outline-container-h-Diagrams" class="outline-4">
<h4 id="h-Diagrams"><span class="section-number-4">2.2.2.</span> Diagrams</h4>
<div class="outline-text-4" id="text-h-Diagrams">
<p>
The code used to generate the diagrams used in this doc is <a href="image.html">here</a>. We don't
discuss that code in this doc because it would make this doc even more verbose.
</p>
</div>
</div>

<div id="outline-container-h-Ignore-woven-HTML-from--git-diff" class="outline-4">
<h4 id="h-Ignore-woven-HTML-from--git-diff"><span class="section-number-4">2.2.3.</span> Ignore woven HTML from <code>git diff</code></h4>
<div class="outline-text-4" id="text-h-Ignore-woven-HTML-from--git-diff">
<p>
Typically we only need to look at the rendered HTML output in a web browser as
the raw HTML diff output is extremely difficult to parse as a human. So by
default we ask Git to exclude it from <code>git diff</code> by treating them as binary
data.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name"><code>.gitattributes</code></label><span class="lilac-caption-link-symbol"><a href="#code--gitattributes--code">&#x1f517;</a></span></div><pre class="src src-gitattributes" id="code--gitattributes--code">* -diff
**/*.json diff
**/*.org diff
**/.gitattributes diff
**/.gitmodules diff
**/.gitignore diff
</pre></div></div><p>
In order to still show the HTML textual diff, we can run <code>git diff --text</code>.
</p>
</div>

<div id="outline-container-h-git-add--p" class="outline-5">
<h5 id="h-git-add--p"><span class="section-number-5">2.2.3.1.</span> <code>git add -p</code></h5>
<div class="outline-text-5" id="text-h-git-add--p">
<p>
Note that the above setting to treat HTML files as binary data prevents them
from being considered for <code>git add -p</code>. In order to add them, use <code>git add -u</code>
instead.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-h-Tangling--generating-the-source-code" class="outline-3">
<h3 id="h-Tangling--generating-the-source-code"><span class="section-number-3">2.3.</span> Tangling (generating the source code)</h3>
<div class="outline-text-3" id="text-h-Tangling--generating-the-source-code">
<p>
Tangling is simply the act of collecting the <code>#+begin_src ... #+end_src</code> blocks
and arranging them into the various target (source code) files. Every source
code block is given a unique name.
</p>

<p>
We simply tangle all major <code>*.org</code> files in the top-level Makefile.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#code-Makefile--code">Makefile-tangle</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__Makefile-tangle">&#x1f517;</a></span></div><pre class="src src-makefile" id="__NREF__Makefile-tangle"><span class="org-makefile-targets">tangle-build-tools</span>: build-tools tangle-sources tangle-generated
<span class="org-makefile-space">    #</span><span class="org-comment-delimiter"> </span><span class="org-comment">Duplicate some files. This way we avoid symlinking, because symlinks can</span>
<span class="org-makefile-space">    #</span><span class="org-comment-delimiter"> </span><span class="org-comment">break when we section off parts of the codebase into separate sandboxes</span>
<span class="org-makefile-space">    #</span><span class="org-comment-delimiter"> </span><span class="org-comment">for building things, such as when building Haskell packages.</span>
    cp -f LICENSE client/LICENSE
    cp -f melby_client.proto client/lib/MelbyClient/melby_client.proto
    cp -f melby_client.proto client-rust/proto/melby_client.proto
    cp -f melby_renderer.proto daemon/lib/melbyd/renderer/lib/MelbyRenderer/melby_renderer.proto
<span class="org-makefile-targets">.PHONY</span>: tangle-build-tools

<span class="org-comment-delimiter"># </span><span class="org-comment">Same as tangle-build-tools, but does not rebuild build tools (ptu).</span>
<span class="org-makefile-targets">do-tangle</span>: tangle-sources tangle-generated
    cp -f LICENSE client/LICENSE
    cp -f melby_client.proto client/lib/MelbyClient/melby_client.proto
    cp -f melby_client.proto client-rust/proto/melby_client.proto
    cp -f melby_renderer.proto daemon/lib/melbyd/renderer/lib/MelbyRenderer/melby_renderer.proto
<span class="org-makefile-targets">.PHONY</span>: do-tangle

<span class="org-comment-delimiter"># </span><span class="org-comment">Currently we don't have any optimizations for tangling, but we still set</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">MELBY_LP_QUICK=1 anyway to align with what we do for weave-quick.</span>
<span class="org-makefile-targets">tangle</span>:
    <span class="org-variable-name">MELBY_LP_QUICK</span>=1 make -C $(<span class="org-variable-name">PROJ_ROOT</span>) -j$(<span class="org-variable-name">PROCS</span>) do-tangle
    <span class="org-type">@</span><span class="org-makefile-shell">$(</span><span class="org-makefile-shell"><span class="org-variable-name">PROJ_ROOT</span></span><span class="org-makefile-shell">)/audit.sh</span>
<span class="org-makefile-targets">.PHONY</span>: tangle

<span class="org-makefile-targets">tangle-profile</span>:
    $(<span class="org-variable-name">call</span> run_emacs,(melby-tangle-profile),developer-manual.org)
<span class="org-makefile-targets">.PHONY</span>: tangle-profile

<span class="org-makefile-targets">tangle-profile-inspect</span>:
    emacs -Q --load $(<span class="org-variable-name">LILAC_ROOT</span>)/lilac.el \
        <span class="org-variable-name">--eval</span>=<span class="org-string">"(profiler-find-profile \"emacs-profile-tangle.txt\"))"</span>
<span class="org-makefile-targets">.PHONY</span>: tangle-profile-inspect

<span class="org-makefile-targets">tangle-generated</span>:
<span class="org-makefile-space">    #</span><span class="org-comment-delimiter"> </span><span class="org-comment">Generate generated source code.</span>
    $(<span class="org-variable-name">MAKE</span>) -C daemon all
<span class="org-makefile-targets">.PHONY</span>: tangle-generated

<span class="org-comment-delimiter"># </span><span class="org-comment">Generate source code.</span>
<span class="org-makefile-targets">tangle-sources</span>: developer-manual-org \
        user-manual-org \
        image-org

<span class="org-makefile-targets">image-org</span>: image.org
    $(<span class="org-variable-name">call</span> run_emacs,(org-babel-tangle),image.org)
<span class="org-comment-delimiter"># </span><span class="org-comment">The developer manual generates the toplevel Makefile (this file) and</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">image/Makefile (overwriting them if necessary) to bootstrap the whole</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">literate-programming pipeline. Note that these LP-related Makefiles are</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">different than the ones used to compile the tangled source code.</span>
<span class="org-makefile-targets">developer-manual-org</span>:
    $(<span class="org-variable-name">call</span> run_emacs,(org-babel-tangle),developer-manual.org)
<span class="org-makefile-targets">user-manual-org</span>: developer-manual-org
    $(<span class="org-variable-name">call</span> run_emacs,(org-babel-tangle),user-manual.org)

<span class="org-makefile-targets">.PHONY</span>: tangle-sources
<span class="org-makefile-targets">.PHONY</span>: developer-manual-org
<span class="org-makefile-targets">.PHONY</span>: user-manual-org
<span class="org-makefile-targets">.PHONY</span>: image-org
</pre></div></div>
</div>

<div id="outline-container-h-Copyright-headers" class="outline-4">
<h4 id="h-Copyright-headers"><span class="section-number-4">2.3.1.</span> Copyright headers</h4>
<div class="outline-text-4" id="text-h-Copyright-headers">
<p>
We used to use a utility called <code>ptu</code> ("post-tangle utility") to prepend
copyright headers to all tangled files, but this resulted in a few problems:
</p>

<ol class="org-ol">
<li>no support for copyright year ranges (e.g., 2020-2024),</li>
<li>no support for checking when each tangled part was actually modified in the
Org source file.</li>
</ol>

<p>
Because of these issues, the utility has been removed.
</p>
</div>
</div>

<div id="outline-container-h-gitignore" class="outline-4">
<h4 id="h-gitignore"><span class="section-number-4">2.3.2.</span> .gitignore</h4>
<div class="outline-text-4" id="text-h-gitignore">
<div class="org-src-container"><pre class="src src-gitignore" id="nil-2"># Cache directory used by the .envrc file.
.direnv

# Apple file system metadata.
.DS_Store

# Haskell "stack" tooling metadata.
.stack-work

# This folder holds dependencies we bring into this project via Git submodules.
# Ignore them here so that we don't search into them when we invoke ripgrep to
# perform text searches.
deps/

# By the same token, ignore all HTML files because we don't want ripgrep to
# search them either.
*.html

# Temporary files related to image generation.
image/*.aux
image/*.log
image/*.pdf
image/*uncropped*
</pre></div>
</div>
</div>

<div id="outline-container-h-Post-tangled-phase" class="outline-4">
<h4 id="h-Post-tangled-phase"><span class="section-number-4">2.3.3.</span> Post-tangled phase</h4>
<div class="outline-text-4" id="text-h-Post-tangled-phase">
<p>
Here we discuss the various programming languages and their required build
environments.
</p>
</div>

<div id="outline-container-h-Elixir" class="outline-5">
<h5 id="h-Elixir"><span class="section-number-5">2.3.3.1.</span> Elixir</h5>
<div class="outline-text-5" id="text-h-Elixir">
<p>
We use Elixir 1.13.4+.
</p>
</div>
</div>

<div id="outline-container-h-Rust" class="outline-5">
<h5 id="h-Rust"><span class="section-number-5">2.3.3.2.</span> Rust</h5>
<div class="outline-text-5" id="text-h-Rust">
</div>
</div>

<div id="outline-container-h-Haskell" class="outline-5">
<h5 id="h-Haskell"><span class="section-number-5">2.3.3.3.</span> Haskell</h5>
<div class="outline-text-5" id="text-h-Haskell">
<p>
We use stack for reproducibility, although we should probably also think of
moving to Nix.
</p>

<p>
We're stuck on GHC 8.10.7 because of mu-haskell which currently does not build
with GHC 9+. We'll move to <a href="https://github.com/well-typed/grapesy">Grapesy</a> when that library becomes ready for use.
</p>
</div>
</div>

<div id="outline-container-h-Lua" class="outline-5">
<h5 id="h-Lua"><span class="section-number-5">2.3.3.4.</span> Lua</h5>
<div class="outline-text-5" id="text-h-Lua">
<p>
We use <a href="https://github.com/rvirding/luerl">luerl</a>, which uses Lua 5.2 with some 5.3 support.
</p>
</div>
</div>
</div>


<div id="outline-container-h-Audit-of-what-s-tangled" class="outline-4">
<h4 id="h-Audit-of-what-s-tangled"><span class="section-number-4">2.3.4.</span> Audit of what's tangled</h4>
<div class="outline-text-4" id="text-h-Audit-of-what-s-tangled">
<p>
Some files in this project are not tangled for convenience. Below is a script
that asks Git for a list of all tracked files, and compares it against what's
tangled from Org files.
</p>

<p>
The script also takes into account a list of known non-tangled tracked files
which acts as an allowlist.
</p>

<div class="org-src-container"><pre class="src src-sh" id="nil-3"><span class="org-builtin">set</span> -euo pipefail

<span class="org-variable-name">SCRIPT_ROOT</span>=<span class="org-string">"$(dirname "$(realpath "$0")")"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Files which are tracked outside of our tangling step, but for legitimate</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">reasons (generated code, symlinks to dependencies, or LICENSE files,</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">typically).</span>
<span class="org-variable-name">known_not_tangled</span>=(
    <span class="org-comment-delimiter"># </span><span class="org-comment">Generated by Git itself.</span>
    .gitmodules

    <span class="org-comment-delimiter"># </span><span class="org-comment">Legalese.</span>
    LICENSE

    <span class="org-comment-delimiter"># </span><span class="org-comment">Build system metadata.</span>
    client-rust/Cargo.lock

    <span class="org-comment-delimiter"># </span><span class="org-comment">Copied over from toplevel proto in Makefile.</span>
    client-rust/proto/melby_client.proto

    <span class="org-comment-delimiter"># </span><span class="org-comment">Generated by client-rust/build.rs.</span>
    client-rust/src/grpc_generated/melby_client.rs

    <span class="org-comment-delimiter"># </span><span class="org-comment">Legalese, same as toplevel (copied over in Makefile).</span>
    client/LICENSE

    <span class="org-comment-delimiter"># </span><span class="org-comment">Copied over from toplevel proto in Makefile.</span>
    client/lib/MelbyClient/melby_client.proto

    <span class="org-comment-delimiter"># </span><span class="org-comment">Needed for Haskell+Stack integration.</span>
    client/stack.nix

    <span class="org-comment-delimiter"># </span><span class="org-comment">Build system metadata.</span>
    client/stack.yaml.lock

    <span class="org-comment-delimiter"># </span><span class="org-comment">Generated gRPC stubs (Elixir).</span>
    daemon/lib/generated/melby.pb.ex
    daemon/lib/generated/melby_client.pb.ex
    daemon/lib/generated/melby_daemon.pb.ex
    daemon/lib/generated/melby_renderer.pb.ex

    <span class="org-comment-delimiter"># </span><span class="org-comment">Build system metadata.</span>
    daemon/lib/melbyd/nifs/Cargo.lock

    <span class="org-comment-delimiter"># </span><span class="org-comment">Legalese.</span>
    daemon/lib/melbyd/renderer/LICENSE

    <span class="org-comment-delimiter"># </span><span class="org-comment">Copied over from toplevel proto in Makefile.</span>
    daemon/lib/melbyd/renderer/lib/MelbyRenderer/melby_renderer.proto

    <span class="org-comment-delimiter"># </span><span class="org-comment">Needed for Haskell+Stack integration.</span>
    daemon/lib/melbyd/renderer/stack.nix

    <span class="org-comment-delimiter"># </span><span class="org-comment">Build system metadata.</span>
    daemon/lib/melbyd/renderer/stack.yaml.lock

    <span class="org-comment-delimiter"># </span><span class="org-comment">Build system metadata.</span>
    daemon/mix.lock

    <span class="org-comment-delimiter"># </span><span class="org-comment">Generated by mix2nix.</span>
    daemon/mix.nix

    <span class="org-comment-delimiter"># </span><span class="org-comment">Generated SVG output (TikZ-&gt;PDF-&gt;SVG).</span>
    image/architecture-overall.svg

    <span class="org-comment-delimiter"># </span><span class="org-comment">Symlinks to Lilac.</span>
    lilac.css
    lilac.js
    lilac.theme

    <span class="org-comment-delimiter"># </span><span class="org-comment">Generated by Niv.</span>
    package/nix/sources.json
    package/nix/sources.nix

    <span class="org-comment-delimiter"># </span><span class="org-comment">Symlink to Lilac.</span>
    syntax-highlighting.css
)

<span class="org-comment-delimiter"># </span><span class="org-comment">List all files we explicitly tangle from Org files.</span>
<span class="org-function-name">tangled_files</span>()
{
    git -C <span class="org-string">"${SCRIPT_ROOT}"</span> grep -P <span class="org-string">'^#\+begin_\w+ .+? :tangle'</span> -- <span class="org-string">'*.org'</span> <span class="org-sh-escaped-newline">\</span>
        | sed <span class="org-string">'s/^.\+:tangle \(\S\+\).*$/\1/'</span> <span class="org-sh-escaped-newline">\</span>
        | sort
}

<span class="org-comment-delimiter"># </span><span class="org-comment">List all files checked into version control.</span>
<span class="org-function-name">tracked_files</span>()
{
    git -C <span class="org-string">"${SCRIPT_ROOT}"</span> ls-tree -r HEAD <span class="org-sh-escaped-newline">\</span>
        | awk <span class="org-string">'{print $2,$4}'</span> <span class="org-sh-escaped-newline">\</span>
        | grep <span class="org-string">'^blob'</span> <span class="org-sh-escaped-newline">\</span>
        | grep -v <span class="org-string">'\.\(html\|org\)$'</span> <span class="org-sh-escaped-newline">\</span>
        | awk <span class="org-string">'{print $2}'</span>
}

<span class="org-function-name">main</span>()
{
    &gt;&amp;2 echo -n <span class="org-string">"$0: checking tangled vs tracked files... "</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Combine tangled files and those which are tracked but not tangled. This</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">list should match the sum of all tangled files (modulo HTML and Org</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">files).</span>
    <span class="org-keyword">if</span> diff -u <span class="org-sh-escaped-newline">\</span>
        &lt;(printf <span class="org-string">'%s\n'</span> <span class="org-string">"$(tangled_files)"</span> <span class="org-string">"${known_not_tangled[@]}"</span> | sort) <span class="org-sh-escaped-newline">\</span>
        &lt;(tracked_files); <span class="org-keyword">then</span>

        &gt;&amp;2 echo <span class="org-string">"OK"</span>
    <span class="org-keyword">else</span>
        &gt;&amp;2 echo <span class="org-string">"$0: failed"</span>
    <span class="org-keyword">fi</span>
}

main <span class="org-string">"$@"</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-h-Glossary" class="outline-3">
<h3 id="h-Glossary"><span class="section-number-3">2.4.</span> Glossary</h3>
<div class="outline-text-3" id="text-h-Glossary">
<ul class="org-ul">
<li><b>Melby component</b>: a modular piece of software used to deliver the Melby user
experience.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-h-Build-System-for-Packaging-Melby" class="outline-2">
<h2 id="h-Build-System-for-Packaging-Melby"><span class="section-number-2">3.</span> Build System for Packaging Melby</h2>
<div class="outline-text-2" id="text-h-Build-System-for-Packaging-Melby">
</div>

<div id="outline-container-h-Introduction" class="outline-3">
<h3 id="h-Introduction"><span class="section-number-3">3.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-h-Introduction">
<p>
We use Nix for the build system. Nix allows us to package up Melby into an
installable software unit, or package, as well as provide us a development
environment capable of building Melby from scratch.
</p>
</div>

<div id="outline-container-h-What-we-must-build" class="outline-4">
<h4 id="h-What-we-must-build"><span class="section-number-4">3.1.1.</span> What we must build</h4>
<div class="outline-text-4" id="text-h-What-we-must-build">
<p>
There are several pieces of software we need to build (compile from source):
</p>

<ol class="org-ol">
<li>melbyc (Haskell)</li>
<li>melbyr (Haskell)</li>
<li>melbyd (Elixir)</li>
<li>melbyd Nifs (Rust)</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-h-Development-environment" class="outline-3">
<h3 id="h-Development-environment"><span class="section-number-3">3.2.</span> Development environment</h3>
<div class="outline-text-3" id="text-h-Development-environment">
<p>
Developing is intimately tied to releasing. And of course, development must come
first before we can release. And so we discuss the development environment here.
</p>

<p>
We use <a href="https://github.com/NixOS/nixpkgs">Nixpkgs</a> (aka "Nix") to set up the environment, because it is the largest
package repository that's available on both Mac (via <a href="https://github.com/LnL7/nix-darwin">nix-darwin</a>) and Linux. So
it makes developing software that spans across multiple different programming
language ecosystems that much easier.
</p>
</div>

<div id="outline-container-h-nix-direnv" class="outline-4">
<h4 id="h-nix-direnv"><span class="section-number-4">3.2.1.</span> nix-direnv</h4>
<div class="outline-text-4" id="text-h-nix-direnv">
<p>
The <a href="https://direnv.net/">direnv</a> tool looks for <code>.envrc</code> files in folders; then you can configure your
shell so that it picks up project-specific settings whenever your shell moves
in/out of such a folder. We invoke <code>use nix</code> so that it picks up the environment
defined inside <a href="shell.nix">shell.nix</a> (see <a href="#h-Nix-shell">3.2.2</a> below).
</p>

<div class="org-src-container"><pre class="src src-sh" id="nil-4">use nix
</pre></div><p>
There are a number of <a href="https://github.com/direnv/direnv/wiki/Nix">similar projects</a> that make the above <code>use nix</code> invocation
faster. We recommend using <code>nix-direnv</code>. On <a href="https://github.com/LnL7/nix-darwin">nix-darwin</a>, installing <code>nix-direnv</code> also
installs <code>direnv</code> for us on the system.
</p>
</div>
</div>

<div id="outline-container-h-Nix-shell" class="outline-4">
<h4 id="h-Nix-shell"><span class="section-number-4">3.2.2.</span> Nix shell</h4>
<div class="outline-text-4" id="text-h-Nix-shell">
<p>
This is taken from <a href="https://github.com/tweag/haskell-stack-nix-example/blob/b9383e35416a2b0e21fbc97ed079538f9f395b6a/shell.nix#L1">here</a>, and it's what <code>direnv</code> will use when we enter the
top-level directory in the shell.
</p>

<p>
If <code>direnv</code> is not available, then we have to manually run the equivalent of the
<code>use nix</code> line in <a href=".envrc">.envrc</a>, which would be <code>nix-shell --pure</code>. You can also do
this by running <code>make shell</code>.
</p>

<p>
This is the main development shell and brings in all of our dependencies to
build all of our code. It's great for development and testing things out (e.g.,
running unit tests) for all of the various languages we use.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">shell.nix (toplevel dev environment)</label><span class="lilac-caption-link-symbol"><a href="#shell-nix--toplevel-dev-environment">&#x1f517;</a></span></div><pre class="src src-nix" id="shell-nix--toplevel-dev-environment"><span class="org-nix-keyword">let</span>
  <span class="org-comment"># Nixpkgs snapshot.</span>
  <span class="org-nix-attribute">sources</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">./package/nix/sources.nix</span>;
  <span class="org-comment"># Overlays</span>
  <span class="org-nix-attribute">oxalica-rust-overlay</span> = <span class="org-nix-builtin">import</span> sources.rust-overlay;
  <span class="org-comment"># Build rust crates.</span>
  <span class="org-nix-attribute">naersk</span> = final: prev: {
    <span class="org-nix-attribute">naersk</span> = pkgs.callPackage sources.naersk
      {
        <span class="org-nix-keyword">inherit</span> sources;
      };
    };
  <span class="org-comment"># The final "pkgs" attribute with all the bells and whistles of our overlays.</span>
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs {
    <span class="org-nix-attribute">overlays</span> = [
      oxalica-rust-overlay
      naersk
    ];
  };

  <span class="org-comment"># Wrap Stack to configure Nix integration and target the correct Stack-Nix</span>
  <span class="org-comment"># file</span>
  <span class="org-comment">#</span>
  <span class="org-comment"># - nix: Enable Nix support (use Stack's built-in Nix integration; this makes</span>
  <span class="org-comment">#   Stack populate the "ghc" variable in our nix/stack.nix file with the GHC</span>
  <span class="org-comment">#   version found in the stack.yaml file; this way we don't have to specify a</span>
  <span class="org-comment">#   GHC version in Nix (when we already define it transitively through</span>
  <span class="org-comment">#   specifying Stack's LTS version in stack.yaml)). This also makes it so that</span>
  <span class="org-comment">#   ghci is not available in the nix-shell; rather it can only be accessed</span>
  <span class="org-comment">#   through "stack exec -- ghci".</span>
  <span class="org-comment">#</span>
  <span class="org-comment"># - nix-pure: Do not pass environment variables, like `NIX_PATH`</span>
  <span class="org-comment">#</span>
  <span class="org-comment"># - nix-shell-file: Specify the Nix file to use (otherwise it uses `shell.nix`</span>
  <span class="org-comment">#   by default)</span>
  <span class="org-comment">#</span>
  <span class="org-comment"># Vanilla (unwrapped) stack is available as `.stack-wrapped`, courtesy of</span>
  <span class="org-comment"># pkgs.symlinkJoin.</span>
  <span class="org-nix-attribute">stack-wrapped</span> = pkgs.symlinkJoin {
    <span class="org-nix-attribute">name</span> = <span class="org-string">"stack"</span>;
    <span class="org-nix-attribute">paths</span> = [ pkgs.stack ];
    <span class="org-nix-attribute">buildInputs</span> = [ pkgs.makeWrapper ];
    <span class="org-nix-attribute">postBuild</span> = <span class="org-string">''</span>
<span class="org-string">      wrapProgram $out/bin/stack \</span>
<span class="org-string">        --add-flags "\</span>
<span class="org-string">          --nix \</span>
<span class="org-string">          --nix-pure \</span>
<span class="org-string">          --system-ghc \</span>
<span class="org-string">          --no-install-ghc \</span>
<span class="org-string">          --nix-shell-file=./stack.nix \</span>
<span class="org-string">        "</span>
<span class="org-string">    ''</span>;
  };

  <span class="org-nix-attribute">protoc-gen-elixir</span> = pkgs.callPackage <span class="org-nix-constant">./package/protoc-gen-elixir.nix</span> {};
  <span class="org-nix-attribute">darwin-cargo-build-rustflags</span> = pkgs.lib.attrsets.optionalAttrs pkgs.stdenv.isDarwin {
    <span class="org-nix-attribute">CARGO_BUILD_RUSTFLAGS</span> = <span class="org-string">"-C link-arg=-undefined -C link-arg=dynamic_lookup"</span>;
  };
  <span class="org-nix-attribute">macOS-security</span> =
    <span class="org-comment"># Make `/usr/bin/security` available in `PATH`, which is needed for stack</span>
    <span class="org-comment"># on darwin which calls this binary to find certificates. See</span>
    <span class="org-comment"># https://github.com/tweag/rules_haskell/commit/31171a520f49f263895112678ac93c7ed958ead1.</span>
    pkgs.writeScriptBin <span class="org-string">"security"</span> <span class="org-string">''exec /usr/bin/security "$@"''</span>;

  <span class="org-comment"># See https://nixos.wiki/wiki/TexLive for customizing texlive packages</span>
  <span class="org-comment"># (picking only those packages we need as in here).</span>
  <span class="org-nix-attribute">tex</span> = (pkgs.texlive.combine {
    <span class="org-nix-keyword">inherit</span> (pkgs.texlive) scheme-basic
      dvisvgm
      fontspec
      luatex85
      pgf
      sourcesanspro
      standalone
      xkeyval;
  });
<span class="org-nix-keyword">in</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">This is our development shell.</span>
pkgs.mkShell ({
  <span class="org-nix-attribute">buildInputs</span> = [
    <span class="org-comment"># Haskell</span>
    stack-wrapped
    <span class="org-comment"># Let stack use Nix with the Nix we version here.</span>
    pkgs.nix

    <span class="org-comment"># Rust</span>
    pkgs.rust-bin.stable.latest.default
    pkgs.rust-analyzer

    <span class="org-comment"># Elixir</span>
    pkgs.beam.packages.erlangR26.elixir
    pkgs.beam.packages.erlangR26.erlang <span class="org-comment"># erl, escript</span>
    pkgs.mix2nix

    <span class="org-comment"># gRPC and Protocol Buffers</span>
    pkgs.protobuf
    <span class="org-comment"># Needed for running Elixir plugin for protoc. E.g., "protoc</span>
    <span class="org-comment"># --elixir_out=plugins=grpc:. foo.proto". We need to install</span>
    <span class="org-comment"># protoc-gen-elixir.</span>
    protoc-gen-elixir

    <span class="org-comment"># Tangling and weaving for Literate Programming.</span>
    pkgs.emacs29-nox
    tex

    <span class="org-comment"># For updating Nix dependencies.</span>
    pkgs.niv

    <span class="org-comment"># Misc</span>
    pkgs.git
    pkgs.less
  ]
  <span class="org-comment"># For file_system on Linux.</span>
  ++ pkgs.lib.optional pkgs.stdenv.isLinux pkgs.inotify-tools
  <span class="org-comment"># For file_system on macOS. See</span>
  <span class="org-comment"># https://elixirforum.com/t/could-not-compile-file-system-watcher-for-mac/17432/10</span>
  <span class="org-comment"># for a discussion about getting a file system watcher working on Mac.</span>
  ++ pkgs.lib.optionals pkgs.stdenv.isDarwin (<span class="org-nix-keyword">with</span> pkgs.darwin.apple_sdk.frameworks; [
    CoreFoundation
    CoreServices
    Security
  ])
  ++ pkgs.lib.optionals pkgs.stdenv.isDarwin [
    <span class="org-comment"># This allows mix2nix to be able to download hex packages using HTTPS, in a</span>
    <span class="org-comment"># `nix-shell --pure` environment. See</span>
    <span class="org-comment"># https://github.com/NixOS/nixpkgs/issues/66716#issuecomment-883399373.</span>
    pkgs.cacert
    macOS-security
  ];

  <span class="org-comment"># FIXME: how to get the git version into the environment...???? The setting</span>
  <span class="org-comment"># below for MELBY_PROJECT_ROOT only works for the dev env, not the release env</span>
  <span class="org-nix-attribute">shellHook</span> = <span class="org-string">''</span>
<span class="org-string">    # Prefer to use melbyr and melbyc from the local development tree path.</span>
<span class="org-string">    export PATH=$PWD/daemon/test:$PWD/daemon/lib/melbyd/renderer:$PWD/client:$PATH</span>
<span class="org-string">    export KUBECONFIG=$PWD/daemon/test/fake_kube_config</span>
<span class="org-string">    export MELBY_DIR=$PWD/daemon/test/sample</span>
<span class="org-string">    export MELBY_PROJECT_ROOT=$PWD</span>
<span class="org-string">    export MELBYR_PATH=$PWD/daemon/lib/melbyd/renderer/melbyr</span>
<span class="org-string">    export LUA_PATH="$PWD/daemon/test/sample/?.lua"</span>
<span class="org-string">  ''</span>;

  <span class="org-comment"># Configure the Nix path to our own `pkgs`, to ensure Stack-with-Nix uses the</span>
  <span class="org-comment"># correct one rather than the global &lt;nixpkgs&gt; when looking for the right</span>
  <span class="org-comment"># `ghc` argument to pass in `nix/stack.nix`</span>
  <span class="org-comment">#</span>
  <span class="org-comment"># See https://nixos.org/nixos/nix-pills/nix-search-paths.html for more</span>
  <span class="org-comment"># information.</span>
  <span class="org-nix-attribute">NIX_PATH</span> = <span class="org-string">"nixpkgs="</span> + pkgs.path;

  <span class="org-comment"># Make Elixir not complain about using "latin1" encoding.</span>
  <span class="org-nix-attribute">LANG</span> = <span class="org-string">"en_US.UTF-8"</span>;
  <span class="org-nix-attribute">LOCALE_ARCHIVE</span> = pkgs.lib.optional pkgs.stdenv.isLinux
    <span class="org-string">"</span><span class="org-nix-antiquote">${</span>pkgs.glibcLocales<span class="org-nix-antiquote">}</span><span class="org-string">/lib/locale/locale-archive"</span>;
} // darwin-cargo-build-rustflags)
</pre></div></div>
</div>

<div id="outline-container-h-Make-Stack-understand-Nix" class="outline-5">
<h5 id="h-Make-Stack-understand-Nix"><span class="section-number-5">3.2.2.1.</span> Make Stack understand Nix</h5>
<div class="outline-text-5" id="text-h-Make-Stack-understand-Nix">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">package/nix/stack.nix</label><span class="lilac-caption-link-symbol"><a href="#package-nix-stack-nix">&#x1f517;</a></span></div><pre class="src src-nix" id="package-nix-stack-nix"><span class="org-nix-keyword">let</span>
  <span class="org-nix-attribute">sources</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">./sources.nix</span>;
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs { };
<span class="org-nix-keyword">in</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">See https://docs.haskellstack.org/en/stable/nix_integration/#using-a-custom-shellnix-file</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">But basically this tells stack to figure out the GHC version by looking at</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">stack.yaml (we have to have this file in $PWD from the current nix-shell</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">session).</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">This is really great because this means we can technically have different</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">tools use different versions of GHC. So maybe one of the smaller, simpler</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">tools can use the latest GHC with useful features and have that as a role</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">model for the other Haskell binaries that are lagging behind on older GHC</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">versions due to dependencies that have not yet upgraded to the newer version.</span>
{ ghc }:

pkgs.haskell.lib.buildStackProject {
  <span class="org-nix-keyword">inherit</span> ghc;
  <span class="org-nix-attribute">name</span> = <span class="org-string">"melby"</span>;
  <span class="org-comment"># System dependencies needed at compilation time</span>
  <span class="org-nix-attribute">buildInputs</span> = [
    pkgs.zlib
  ];
}
</pre></div></div>
</div>
</div>
</div>
</div>

<div id="outline-container-h-Packaging" class="outline-3">
<h3 id="h-Packaging"><span class="section-number-3">3.3.</span> Packaging</h3>
<div class="outline-text-3" id="text-h-Packaging">
</div>

<div id="outline-container-h-Releasing" class="outline-4">
<h4 id="h-Releasing"><span class="section-number-4">3.3.1.</span> Releasing</h4>
<div class="outline-text-4" id="text-h-Releasing">
<p>
We use Nix to package everything up. The main thing to note here is that we
reuse the shell environment's sources (in <code>nix/sources.nix</code>) to make sure that
the development environment's dependencies exactly match what we'll end up
shipping.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">package/build.nix</label><span class="lilac-caption-link-symbol"><a href="#package-build-nix">&#x1f517;</a></span></div><pre class="src src-nix" id="package-build-nix"><span class="org-nix-keyword">let</span>
  <span class="org-nix-attribute">sources</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">./nix/sources.nix</span>;
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs {};
  <span class="org-comment"># We have to explicitly choose GHC 8.10.7 because 9.0.2 is the default for</span>
  <span class="org-comment"># nixos-22.11 (which we don't want because the Stack version we use, LTS</span>
  <span class="org-comment"># 18.28, uses 8.10.7).</span>
  <span class="org-nix-attribute">hpg8107</span> = pkgs.haskell.packages.ghc8107;
  <span class="org-nix-attribute">hpg96</span> = pkgs.haskell.packages.ghc96;
  <span class="org-nix-attribute">melby-client</span> = hpg8107.callPackage <span class="org-nix-constant">../client/melby-client.nix</span> {};
  <span class="org-nix-attribute">melby-client-rust</span> = pkgs.callPackage <span class="org-nix-constant">../client-rust/melby-client-rust.nix</span> {};
  <span class="org-comment"># FIXME: We need to pass in a "version" attribute to all Haskell packages</span>
  <span class="org-comment"># because the default buildStackProject helper does not provide a version.</span>
  <span class="org-comment"># This means we need to start creating version strings, probably in the format</span>
  <span class="org-comment"># "YY.MM.DD-&lt;sha&gt;" to make it incremental.</span>
  <span class="org-comment">#melby-client-2 = (import melby-client-1) {};</span>
  <span class="org-comment">#melby-client-3 = pkgs.haskell.lib.addBuildTool melby-client-2 fakeGit;</span>
  <span class="org-nix-attribute">melby-renderer</span> = hpg8107.callPackage <span class="org-nix-constant">../daemon/lib/melbyd/renderer/melby-renderer.nix</span> {};
  <span class="org-nix-attribute">melby-daemon</span> = pkgs.callPackage <span class="org-nix-constant">../daemon/melby-daemon.nix</span> {};
  <span class="org-nix-attribute">melby-nifs</span> = pkgs.callPackage <span class="org-nix-constant">../daemon/lib/melbyd/nifs/melby-nifs.nix</span> {};
<span class="org-nix-keyword">in</span>
  {
    <span class="org-nix-keyword">inherit</span> melby-client melby-client-rust melby-renderer melby-daemon melby-nifs;
  }
</pre></div></div><p>
We can now install everything above with <code>nix-env -if ./release.nix</code>. Be sure to
run <code>systemctl --user daemon-reload</code> to load the <code>systemd</code> definition that comes
with <code>melby.service</code>, and run <code>systemctl --user start melby.service</code> to actually
start it.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">package/release.nix</label><span class="lilac-caption-link-symbol"><a href="#package-release-nix">&#x1f517;</a></span></div><pre class="src src-nix" id="package-release-nix"><span class="org-nix-keyword">let</span>
  <span class="org-nix-attribute">sources</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">./nix/sources.nix</span>;
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs {};
  <span class="org-nix-attribute">melby</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">./build.nix</span>;
<span class="org-nix-keyword">in</span>
  pkgs.symlinkJoin {
    <span class="org-nix-attribute">name</span> = <span class="org-string">"melby"</span>;
    <span class="org-nix-attribute">paths</span> = <span class="org-nix-keyword">with</span> melby; [
      melby-client
      melby-client-rust
      melby-renderer
      melby-daemon
    ];
    <span class="org-comment"># If users have already installed individual packages already, make the ones</span>
    <span class="org-comment"># we bundle here act as a fallback. Default priority is 5, and so by setting</span>
    <span class="org-comment"># it to 10, makes Nix treat the files of this derivation as a fallback if</span>
    <span class="org-comment"># there is a conflict.</span>
    <span class="org-nix-attribute">meta.priority</span> = 10;
  }
</pre></div></div><p>
Additional steps:
</p>

<p>
Create a <code>~/.melby/systemd/env</code> file with the contents
</p>

<p>
FIXME: Add in "prod" settings here for MELBYR_PATH, MELBYR_PORT, and so on so as
to not conflict with the dev environment. Even better, add these settings in our
Elixir code so that the user does not (normally) have to configure them.
</p>

<pre class="example" id="org0000018">
RELEASE_COOKIE=path/to/cookie
</pre>

<p>
Then populate <code>path/to/cookie</code> with a random text string like this:
</p>

<pre class="example" id="org0000019">
$ cd ~/.melby
$ openssl rand -base64 48 &gt; cookie
$ chmod 600 cookie
</pre>
</div>
</div>

<div id="outline-container-h-Makefile" class="outline-4">
<h4 id="h-Makefile"><span class="section-number-4">3.3.2.</span> Makefile</h4>
<div class="outline-text-4" id="text-h-Makefile">
<p>
FIXME: reduce repetition by using a build rule (akin to run_emacs)
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">package/Makefile</label><span class="lilac-caption-link-symbol"><a href="#package-Makefile">&#x1f517;</a></span></div><pre class="src src-makefile" id="package-Makefile">
define run_build
    nix-build build.nix --option sandbox relaxed --show-trace \
        -A $(<span class="org-variable-name">1</span>) --out-link $(<span class="org-variable-name">1</span>)
endef

<span class="org-makefile-targets">build</span>:
    nix-build build.nix --option sandbox relaxed --show-trace

<span class="org-makefile-targets">build-melby-client</span>:
    $(<span class="org-variable-name">call</span> run_build,melby-client)

<span class="org-makefile-targets">build-melby-client-rust</span>:
    $(<span class="org-variable-name">call</span> run_build,melby-client-rust)

<span class="org-makefile-targets">build-melby-daemon</span>:
    $(<span class="org-variable-name">call</span> run_build,melby-daemon)

<span class="org-makefile-targets">build-melby-nifs</span>:
    $(<span class="org-variable-name">call</span> run_build,melby-nifs)

<span class="org-makefile-targets">build-melby-renderer</span>:
    $(<span class="org-variable-name">call</span> run_build,melby-renderer)

<span class="org-makefile-targets">shell</span>:
    nix-shell --pure

<span class="org-comment-delimiter"># </span><span class="org-comment">Update nix/ folder to pin dependencies to nixos-24.05.</span>
<span class="org-makefile-targets">update-nix</span>:
    niv update nixpkgs --branch nixos-24.05

<span class="org-makefile-targets">.PHONY</span>: build
<span class="org-makefile-targets">.PHONY</span>: build-melby-client
<span class="org-makefile-targets">.PHONY</span>: build-melby-client-rust
<span class="org-makefile-targets">.PHONY</span>: build-melby-renderer
<span class="org-makefile-targets">.PHONY</span>: build-melby-daemon
<span class="org-makefile-targets">.PHONY</span>: build-melby-nifs
<span class="org-makefile-targets">.PHONY</span>: shell
<span class="org-makefile-targets">.PHONY</span>: update-nix
</pre></div></div>
</div>
</div>

<div id="outline-container-h-gitignore-1" class="outline-4">
<h4 id="h-gitignore-1"><span class="section-number-4">3.3.3.</span> .gitignore</h4>
<div class="outline-text-4" id="text-h-gitignore-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">package/.gitignore</label><span class="lilac-caption-link-symbol"><a href="#package--gitignore">&#x1f517;</a></span></div><pre class="src src-gitignore" id="package--gitignore"># These links can get created if we build individual targets.
melby-client
melby-client-rust
melby-nifs
melby-renderer
melby-daemon

# These result-NUMBER links get created automatically by Nix.
result*
</pre></div></div>
</div>
</div>
</div>
</div>
<div id="outline-container-h-How-to-hack-on-this-project" class="outline-2">
<h2 id="h-How-to-hack-on-this-project"><span class="section-number-2">4.</span> How to hack on this project</h2>
<div class="outline-text-2" id="text-h-How-to-hack-on-this-project">
<p>
First realize that this project uses literate programming. Because of this, you
must ensure that you can edit the Org files and make sure that those changes (to
the source code) can get tangled into source code locations for the various
compilers (<code>ghc</code>, <code>elixir</code>, etc) can consume.
</p>

<p>
The next most important thing is making sure that the <code>shell.nix</code> file at the
project root works (such that running <code>make shell</code> works). Run <code>make shell</code> to
enter the development environment.
</p>

<p>
You then need to stand up each individual Melby component.
</p>
</div>

<div id="outline-container-h-Building-each-component" class="outline-3">
<h3 id="h-Building-each-component"><span class="section-number-3">4.1.</span> Building each component</h3>
<div class="outline-text-3" id="text-h-Building-each-component">
</div>

<div id="outline-container-h-melbyr---renderer--required-by-daemon" class="outline-4">
<h4 id="h-melbyr---renderer--required-by-daemon"><span class="section-number-4">4.1.1.</span> <code>melbyr</code> (renderer; required by daemon)</h4>
<div class="outline-text-4" id="text-h-melbyr---renderer--required-by-daemon">
<pre class="example" id="org000001e">
cd daemon/lib/melbyd/renderer; make
</pre>
</div>
</div>

<div id="outline-container-h-melbyd---daemon" class="outline-4">
<h4 id="h-melbyd---daemon"><span class="section-number-4">4.1.2.</span> <code>melbyd</code> (daemon)</h4>
<div class="outline-text-4" id="text-h-melbyd---daemon">
<pre class="example" id="org000001f">
cd daemon &amp;&amp; make
</pre>

<p>
And then to run the daemon, do
</p>

<pre class="example" id="org0000020">
cd daemon &amp;&amp; make run_dev
</pre>

<p>
There is also a <code>run-prod</code> rule but this won't work if you are already running a
packaged version of <code>melbyd</code> in your system, because they will both try to use
the same TCP port. So in that case you have to first stop the packaged version
you are running.
</p>
</div>
</div>
</div>

<div id="outline-container-h-melbyc---client" class="outline-3">
<h3 id="h-melbyc---client"><span class="section-number-3">4.2.</span> <code>melbyc</code> (client)</h3>
<div class="outline-text-3" id="text-h-melbyc---client">
<pre class="example" id="org0000021">
cd client; make
</pre>

<p>
For invoking <code>melbyc</code> after building it, the simplest thing to do is to use the
provided <code>preview.sh</code> script in <a href="daemon/test/preview.sh"><code>daemon/test/preview.sh</code></a>. This script sets up
all necessary environment variables.
</p>

<p>
Note that currently the script uses a fake <code>kubectl</code>, because we don't want to
bother standing up a real Kubernetes instance in order to just test how
the real <code>kubectl</code> would behave. The script hardcodes the path to <code>melbyc</code> so
that it refers to the one that has been compiled inside the development
environment.
</p>
</div>
</div>

<div id="outline-container-h-Testing-local-changes" class="outline-3">
<h3 id="h-Testing-local-changes"><span class="section-number-3">4.3.</span> Testing local changes</h3>
<div class="outline-text-3" id="text-h-Testing-local-changes">
<p>
FIXME: How to do testing? What about integration tests? How to invoke tests? <code>mix test</code>?
</p>
</div>
</div>

<div id="outline-container-h-Common-scenarios" class="outline-3">
<h3 id="h-Common-scenarios"><span class="section-number-3">4.4.</span> Common scenarios</h3>
<div class="outline-text-3" id="text-h-Common-scenarios">
</div>

<div id="outline-container-h-Hacking-on-the-Lua-config" class="outline-4">
<h4 id="h-Hacking-on-the-Lua-config"><span class="section-number-4">4.4.1.</span> Hacking on the Lua config</h4>
<div class="outline-text-4" id="text-h-Hacking-on-the-Lua-config">
<p>
Make sure to use fakes, and to add validation tests. FIXME show examples.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-h-melbyc" class="outline-2">
<h2 id="h-melbyc"><span class="section-number-2">5.</span> melbyc</h2>
<div class="outline-text-2" id="text-h-melbyc">
<p>
We first examine the client to get a sense of how things work from the
perspective of the human user, who is expected to invoke <code>melbyc</code> somewhere in
their shell prompt generation logic. We then look at the pieces in the daemon to
see how it all works.
</p>
</div>

<div id="outline-container-h-Purpose" class="outline-3">
<h3 id="h-Purpose"><span class="section-number-3">5.1.</span> Purpose</h3>
<div class="outline-text-3" id="text-h-Purpose">
<p>
<code>melby-client</code> is a client for Melby. It allows users to interact with melby (the
daemon).
</p>
</div>
</div>

<div id="outline-container-h-Design-by-contract" class="outline-3">
<h3 id="h-Design-by-contract"><span class="section-number-3">5.2.</span> Design by contract</h3>
<div class="outline-text-3" id="text-h-Design-by-contract">
<p>
We would like our client to observe the following behaviors.
</p>

<ol class="org-ol">
<li>Allow users to talk to the daemon.</li>

<li>Run very quickly (the synchronous call to the daemon should finish in under
500 milliseconds).</li>

<li>Have basic command-line argument handling.</li>
</ol>

<p>
These points are the main things (or problems) that our program has to worry
about. We look at each of these requirements below.
</p>
</div>

<div id="outline-container-h-Talking-to-the-daemon" class="outline-4">
<h4 id="h-Talking-to-the-daemon"><span class="section-number-4">5.2.1.</span> Talking to the daemon</h4>
<div class="outline-text-4" id="text-h-Talking-to-the-daemon">
<p>
We talk to melbyd using gRPC. This is rather straightforward as it just involves
a single unary (that is, non-streaming) gRPC call.
</p>
</div>

<div id="outline-container-h-Lua-1" class="outline-5">
<h5 id="h-Lua-1"><span class="section-number-5">5.2.1.1.</span> Lua</h5>
<div class="outline-text-5" id="text-h-Lua-1">
<p>
The more interesting thing here is that we send melbyd some Lua code to give the
user the flexibility of determining exactly how to construct the prompt. This
way, the user is not stuck with only the default "look" of the pieces of the
prompt (the user can do more than just rearrange these pieces &#x2014; they can
customizes the pieces themselves). To this
</p>
</div>
</div>

<div id="outline-container-h-Proto" class="outline-5">
<h5 id="h-Proto"><span class="section-number-5">5.2.1.2.</span> Proto</h5>
<div class="outline-text-5" id="text-h-Proto">
<p>
For concreteness, this is the actual protobuf file we use to define melbyc's
behavior when it talks to the daemon.
</p>

<p>
This is the protobuf definition that we need to generate the Haskell client
stub. We also use it to generate the Elixir server stubs (used by the daemon).
FIXME: add link to where it's used in Elixir.
</p>

<div class="org-src-container"><pre class="src src-protobuf" id="nil-5">syntax = <span class="org-string">"proto3"</span>;

<span class="org-keyword">package</span> <span class="org-type">melby_client</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">melbyc &lt;-&gt; melbyd communication</span>
<span class="org-keyword">service</span> <span class="org-type">View</span> {
  <span class="org-keyword">rpc</span> <span class="org-function-name">GetView</span> (ViewRequest) <span class="org-keyword">returns</span> (ViewResponse);
}

<span class="org-keyword">message</span> <span class="org-type">ViewRequest</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Path to Lua configuration. Delegates reading the config to the daemon.</span>
  <span class="org-type">string</span> <span class="org-variable-name">config_path</span> = 1;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Lua configuration that is given directly. Currently unusued by the daemon.</span>
  <span class="org-type">string</span> <span class="org-variable-name">config</span> = 2;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Environment variables ((name, value) pairs) of interest.</span>
  map&lt;<span class="org-type">string</span>, <span class="org-type">string</span>&gt; env_vars = 3;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Process ID number of the running (interactive) shell program. (FIXME: move</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">this to env var)</span>
  <span class="org-type">string</span> <span class="org-variable-name">shell_pid</span> = 4;
}

<span class="org-keyword">message</span> <span class="org-type">ViewResponse</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Status of this response message.</span>
  <span class="org-type">ViewStatus</span> <span class="org-variable-name">status</span> = 1;

  <span class="org-comment-delimiter">// </span><span class="org-comment">String result of running Lua script.</span>
  <span class="org-type">string</span> <span class="org-variable-name">view</span> = 2;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Error message from melbyd, if any.</span>
  <span class="org-type">string</span> <span class="org-variable-name">error</span> = 3;
}

<span class="org-keyword">enum</span> <span class="org-type">ViewStatus</span> {
  VIEW_STATUS_UNSPECIFIED = 0;
  VIEW_STATUS_ERROR = 1;
  VIEW_STATUS_OK = 2;
}
</pre></div>
</div>
</div>
</div>

<div id="outline-container-h-Running-very-quickly" class="outline-4">
<h4 id="h-Running-very-quickly"><span class="section-number-4">5.2.2.</span> Running very quickly</h4>
<div class="outline-text-4" id="text-h-Running-very-quickly">
<p>
We don't want the client to block too long, because it is expected to be called
as often as every second (or even more often if Zsh ever offers sub-1-second
delay with the <code>TMOUT</code> variable).
</p>

<p>
The basic way we ensure this is that we make melbyd return whatever it has
without waiting for any of its internal calculations to finish.
</p>

<p>
Because this is a daemon-side concern, there isn't much for us to do here.
</p>
</div>
</div>

<div id="outline-container-h-Command-line-argument-handling" class="outline-4">
<h4 id="h-Command-line-argument-handling"><span class="section-number-4">5.2.3.</span> Command line argument handling</h4>
<div class="outline-text-4" id="text-h-Command-line-argument-handling">
<p>
This is somewhat "boring" and we actually don't have much to design here. Much
of the choices here depend heavily on the command line argument parsing library
that we will be using.
</p>
</div>
</div>
</div>

<div id="outline-container-h-Code-overview" class="outline-3">
<h3 id="h-Code-overview"><span class="section-number-3">5.3.</span> Code overview</h3>
<div class="outline-text-3" id="text-h-Code-overview">
<p>
This walk-through is written for the future maintainers of this codebase.
</p>
</div>

<div id="outline-container-h-Overall-structure" class="outline-4">
<h4 id="h-Overall-structure"><span class="section-number-4">5.3.1.</span> Overall structure</h4>
<div class="outline-text-4" id="text-h-Overall-structure">
<p>
All of the business logic lies in the <code>melby-client.hs</code> file, which has the
following structure:
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Layout of <code>melby-client.hs</code></label><span class="lilac-caption-link-symbol"><a href="#Layout-of--code-melby-client-hs--code">&#x1f517;</a></span></div><pre class="src src-haskell" id="Layout-of--code-melby-client-hs--code"><span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_pragmas">melbyc_pragmas</a></span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">Main</span> <span class="org-haskell-keyword">where</span>

<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_imports">melbyc_imports</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_business_logic">melbyc_business_logic</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_option_handling">melbyc_option_handling</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_main">melbyc_main</a></span>
</pre></div></div><p>
The more interesting bits are in the <code>&lt;&lt;business-logic&gt;&gt;</code> section, which
actually performs the gRPC call to melbyd. Everything else is mostly boilerplate
code.
</p>

<p>
We'll look at the business logic first, and then all of the other boilerplate
code.
</p>
</div>
</div>
</div>

<div id="outline-container-h-Business-logic" class="outline-3">
<h3 id="h-Business-logic"><span class="section-number-3">5.4.</span> Business logic</h3>
<div class="outline-text-3" id="text-h-Business-logic">
<p>
Recall in section FIXME that we said we wanted to pass in some Lua code. So
that's basically what we do here &#x2014; we pass in a gRPC connection and a filepath
to the Lua script we want to send to melbyd. We do this in the <code>getView</code>
function.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Layout-of--code-melby-client-hs--code">melbyc_business_logic</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_business_logic">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_business_logic"><span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_getView">melbyc_getView</a></span>
</pre></div></div><p>
Now let's construct the <code>getView</code> function.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyc_business_logic">melbyc_getView</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_getView">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_getView"><span class="org-haskell-definition">getView</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">GRpcConnection</span> <span class="org-haskell-type">View</span> '<span class="org-haskell-type">MsgProtoBuf</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">FilePath</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">getView</span> conn configPath' config' shell_pid' <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_getView_construct_payload">melbyc_getView_construct_payload</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_getView_call_melbyd">melbyc_getView_call_melbyd</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_getView_handle_payload">melbyc_getView_handle_payload</a></span>
</pre></div></div><p>
Below we construct a gRPC message payload (request) for melbyd.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyc_getView">melbyc_getView_construct_payload</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_getView_construct_payload">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_getView_construct_payload">env_vars_str <span class="org-haskell-operator">&lt;-</span> getEnvironment
<span class="org-haskell-keyword">let</span> env_vars' <span class="org-haskell-operator">=</span> M.fromList <span class="org-haskell-operator">$</span> map (<span class="org-haskell-operator">\</span>(k, v) <span class="org-haskell-operator">-&gt;</span> (T.pack k, T.pack v)) env_vars_str
    req <span class="org-haskell-operator">=</span> toSchema <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MViewRequest</span>
      { config_path <span class="org-haskell-operator">=</span> T.pack configPath'
      , config <span class="org-haskell-operator">=</span> config'
      , env_vars <span class="org-haskell-operator">=</span> env_vars'
      , shell_pid <span class="org-haskell-operator">=</span> T.pack <span class="org-haskell-operator">$</span> show shell_pid'
      }
</pre></div></div><p>
We then make the remote procedure call. There's some lens magic here, but the
important thing is that we call the <code>GetView</code> method by passing it the <code>req</code> as
an argument. We use the capitalized <code>GetView</code> instead of <code>getView</code> because the
capitalized version is the suggested style for protocol buffers according to
<a href="https://developers.google.com/protocol-buffers/docs/style#services">https://developers.google.com/protocol-buffers/docs/style#services</a>.
Unfortunately, we cannot use <code>#GetVrompt</code> (just like we would use <code>#getVrompt</code>,
the non-capitalized version) and so must instead do <code>fromLabel @"GetView"</code>
because capitalized words have a special meaning in Haskell. See
<a href="https://github.com/higherkindness/mu-haskell/issues/337#issuecomment-1243874126">https://github.com/higherkindness/mu-haskell/issues/337#issuecomment-1243874126</a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyc_getView">melbyc_getView_call_melbyd</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_getView_call_melbyd">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_getView_call_melbyd">response <span class="org-haskell-operator">&lt;-</span> conn <span class="org-haskell-operator">^.</span> fromLabel <span class="org-haskell-operator">@</span><span class="org-string">"GetView"</span> <span class="org-haskell-operator">$</span> req
</pre></div></div><p>
For now we don't really care if the call to melbyd did not succeed and crash if
the response was not successfully completed. That's why we only pattern match
against <code>GRpcOk</code>.
</p>

<p>
<code>term</code> here is a mu-haskell type that can be converted into a Haskell type, as
below. However, the term itself is useful because we can use various "optics"
functions, such as <code>^.</code>.
</p>

<p>
Lastly we need to render the view to the user from the response.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyc_getView">melbyc_getView_handle_payload</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_getView_handle_payload">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_getView_handle_payload"><span class="org-haskell-keyword">let</span> term <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> response <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor">GRpcOk</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Right</span> a
      x <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> T.pack (<span class="org-string">"unrecognized daemon response: "</span> <span class="org-haskell-operator">&lt;&gt;</span> (show x))
<span class="org-haskell-keyword">case</span> term <span class="org-haskell-keyword">of</span>
  <span class="org-haskell-constructor">Left</span> err <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
    T.hPutStrLn stderr err
    exitFailure
  <span class="org-haskell-constructor">Right</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
    <span class="org-haskell-keyword">let</span> viewResponse <span class="org-haskell-operator">=</span> fromSchema a <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MViewResponse</span>
    <span class="org-haskell-keyword">case</span> status viewResponse <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor">VIEW_STATUS_UNSPECIFIED</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
        T.hPutStrLn stderr (<span class="org-string">"VIEW_STATUS_UNSPECIFIED"</span>)
        exitFailure
      <span class="org-haskell-constructor">VIEW_STATUS_ERROR</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
        T.hPutStrLn stderr (<span class="org-string">"encountered error: "</span> <span class="org-haskell-operator">&lt;&gt;</span> getField <span class="org-haskell-operator">@</span><span class="org-string">"error"</span> viewResponse)
        exitFailure
      <span class="org-haskell-constructor">VIEW_STATUS_OK</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
        T.putStrLn <span class="org-haskell-operator">$</span> getField <span class="org-haskell-operator">@</span><span class="org-string">"view"</span> viewResponse
</pre></div></div><p>
That's it! We are done printing to STDOUT and the shell program (or whatever
else) that is calling us can make use of this information. A primary use case is
making <code>getView</code> output a shell script itself (such as variable assignments)
that can be sourced by the shell. This way all that the shell has to do is
something like:
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Example usage of <code>melbyc</code> from your shell's configuration.</label><span class="lilac-caption-link-symbol"><a href="#Example-usage-of--code-melbyc--code--from-your-shell-s-configuration">&#x1f517;</a></span></div><pre class="src src-shell" id="Example-usage-of--code-melbyc--code--from-your-shell-s-configuration"><span class="org-builtin">source</span> <span class="org-string">"$(melbyc view PATH_TO_LUA_CONFIG)"</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Boilerplate" class="outline-3">
<h3 id="h-Boilerplate"><span class="section-number-3">5.5.</span> Boilerplate</h3>
<div class="outline-text-3" id="text-h-Boilerplate">
</div>

<div id="outline-container-h-Option-handling" class="outline-4">
<h4 id="h-Option-handling"><span class="section-number-4">5.5.1.</span> Option handling</h4>
<div class="outline-text-4" id="text-h-Option-handling">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Layout-of--code-melby-client-hs--code">melbyc_option_handling</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_option_handling">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_option_handling"><span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_option_handling_types">melbyc_option_handling_types</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_option_handling_parsers">melbyc_option_handling_parsers</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_option_handling_dispatcher">melbyc_option_handling_dispatcher</a></span>
</pre></div></div><p>
The types here are what we read in from the command line.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyc_option_handling">melbyc_option_handling_types</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_option_handling_types">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_option_handling_types"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Opts</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Opts</span>
  { subcommand <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Subcommand</span>
  , oMelbydPort <span class="org-haskell-operator">::</span> <span class="org-haskell-type">PortNumber</span>
  }

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Subcommand</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">View</span> <span class="org-haskell-constructor">ViewOpts</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Ping</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Shutdown</span>

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">ViewOpts</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ViewOpts</span>
  { oConfigPath <span class="org-haskell-operator">::</span> <span class="org-haskell-type">FilePath</span>
  , oConfig <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  , oShellPid <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span>
  }
</pre></div></div><p>
The parsers here determine how the types we defined above are accepted on the
command line. For the user, this is the help message they see so that they know
how to provide the right arguments to ensure that we get the correct types.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyc_option_handling">melbyc_option_handling_parsers</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_option_handling_parsers">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_option_handling_parsers"><span class="org-haskell-definition">optionsP</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Parser</span> <span class="org-haskell-type">Opts</span>
<span class="org-haskell-definition">optionsP</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Opts</span>
  <span class="org-haskell-operator">&lt;$&gt;</span> subcommandP
  <span class="org-haskell-operator">&lt;*&gt;</span> (option auto (long <span class="org-string">"melbyd-port"</span>
                    <span class="org-haskell-operator">&lt;&gt;</span> help <span class="org-string">"port for melbyd (e.g., 50052 for dev environmont))"</span>
                    <span class="org-haskell-operator">&lt;&gt;</span> showDefault <span class="org-haskell-operator">&lt;&gt;</span> value 50051 <span class="org-haskell-operator">&lt;&gt;</span> metavar <span class="org-string">"PORT"</span>))

<span class="org-haskell-definition">subcommandP</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Parser</span> <span class="org-haskell-type">Subcommand</span>
<span class="org-haskell-definition">subcommandP</span> <span class="org-haskell-operator">=</span> hsubparser
  (  command <span class="org-string">"view"</span> (info
                     (<span class="org-haskell-constructor">View</span> <span class="org-haskell-operator">&lt;$&gt;</span> viewOptsP)
                     (progDesc <span class="org-string">"get prompt information with Lua"</span>))
  <span class="org-haskell-operator">&lt;&gt;</span> command <span class="org-string">"ping"</span> (info
                     (pure <span class="org-haskell-constructor">Ping</span>) (progDesc <span class="org-string">"Check melbyd connectivity"</span>))
  <span class="org-haskell-operator">&lt;&gt;</span> command <span class="org-string">"shutdown"</span> (info
                         (pure <span class="org-haskell-constructor">Shutdown</span>)
                         (progDesc <span class="org-string">"Shut down melbyd instance"</span>))
  <span class="org-haskell-operator">&lt;&gt;</span> metavar <span class="org-string">"SUBCOMMAND"</span>
  )

<span class="org-haskell-definition">viewOptsP</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Parser</span> <span class="org-haskell-type">ViewOpts</span>
<span class="org-haskell-definition">viewOptsP</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ViewOpts</span>
  <span class="org-haskell-operator">&lt;$&gt;</span> (argument str (metavar <span class="org-string">"FILEPATH"</span>))
  <span class="org-haskell-operator">&lt;*&gt;</span> (option auto (long <span class="org-string">"config"</span>
                    <span class="org-haskell-operator">&lt;&gt;</span> help <span class="org-string">"raw Lua string"</span> <span class="org-haskell-operator">&lt;&gt;</span> showDefault <span class="org-haskell-operator">&lt;&gt;</span> value <span class="org-string">""</span>
                    <span class="org-haskell-operator">&lt;&gt;</span> metavar <span class="org-string">"LUA_CONFIG_RAW"</span>))
  <span class="org-haskell-operator">&lt;*&gt;</span> (option auto (long <span class="org-string">"shell-pid"</span>
                    <span class="org-haskell-operator">&lt;&gt;</span> help <span class="org-string">"PID of invoking shell (in most shells this is '$$')"</span>
                    <span class="org-haskell-operator">&lt;&gt;</span> showDefault <span class="org-haskell-operator">&lt;&gt;</span> value 0 <span class="org-haskell-operator">&lt;&gt;</span> metavar <span class="org-string">"PID"</span>))

</pre></div></div><p>
Lastly, <code>optsHandler</code> is where we send the types that we've constructed (after a
successful parse of command line arguments) to the business logic.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyc_option_handling">melbyc_option_handling_dispatcher</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_option_handling_dispatcher">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_option_handling_dispatcher"><span class="org-haskell-definition">optsHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Opts</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">optsHandler</span> (<span class="org-haskell-constructor">Opts</span> subcommand' oMelbydPort') <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">FIXME: configure the domain and port to be configurable through TOML or</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">yaml in a shared location with the daemon. The daemon should configure its</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">port with it. The precedence of settings (where later mechanisms override</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">earlier ones) is: (1) the configuration file (in TOML) converted to a</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">native Haskell type (with sane defaults) with tomland</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">(https://kowainik.github.io/posts/2019-01-14-tomland), (2) command-line</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">options that are passed in at runtime.</span>
  <span class="org-haskell-constructor">Right</span> viewClient <span class="org-haskell-operator">&lt;-</span> initGRpc (grpcClientConfigSimple
                                 <span class="org-string">"127.0.0.1"</span> oMelbydPort' <span class="org-haskell-constructor">False</span>) msgProtoBuf
  <span class="org-comment-delimiter">--</span><span class="org-comment">home &lt;- T.pack &lt;$&gt; getEnv "HOME"</span>
  <span class="org-haskell-keyword">case</span> subcommand' <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">View</span> o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      getView viewClient (oConfigPath o) (oConfig o) (oShellPid o)
    <span class="org-haskell-constructor">Ping</span> <span class="org-haskell-operator">-&gt;</span> putStrLn <span class="org-string">"not implemented"</span>
    <span class="org-haskell-constructor">Shutdown</span> <span class="org-haskell-operator">-&gt;</span> putStrLn <span class="org-string">"not implemented"</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Main" class="outline-4">
<h4 id="h-Main"><span class="section-number-4">5.5.2.</span> Main</h4>
<div class="outline-text-4" id="text-h-Main">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Layout-of--code-melby-client-hs--code">melbyc_main</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_main">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_main"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  opts <span class="org-haskell-operator">&lt;-</span> customExecParser (prefs showHelpOnEmpty) optsP
  optsHandler opts
  <span class="org-haskell-keyword">where</span>
  optsP <span class="org-haskell-operator">=</span> info parserProgramOptions infoMod
  parserProgramOptions <span class="org-haskell-operator">=</span> helper
    <span class="org-haskell-operator">&lt;*&gt;</span> versionOption
    <span class="org-haskell-operator">&lt;*&gt;</span> optionsP
  infoMod <span class="org-haskell-operator">=</span> fullDesc
    <span class="org-haskell-operator">&lt;&gt;</span> header <span class="org-string">"melbyc - CLI for interacting with the melby daemon (melbyd)"</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyc_gitVersion">melbyc_gitVersion</a></span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-gRPC-schema" class="outline-4">
<h4 id="h-gRPC-schema"><span class="section-number-4">5.5.3.</span> gRPC schema</h4>
<div class="outline-text-4" id="text-h-gRPC-schema">
<p>
This is the code that helps melbyc understand how to encode and decode the raw
bytes that are used for communication with melbyd (an Elixir application). This
is usually autogenerated when you're using a gRPC stack (via built-in language
support from the <code>protoc</code> binary, a.k.a. the protobuf compiler). However the
Haskell library we use asks us to define these types, so we do that here. This
isn't that much work, and although it reads like autogenerated code, it is easy
enough to understand (thanks to how terse Haskell can be).
</p>

<p>
We define this in a separate file so that it can be reused by other programs,
namely the <code>melbyd-lens</code> Haskell service that runs as part of melbyd.
</p>

<p>
FIXME: break this up into smaller chunks
</p>

<div class="org-src-container"><pre class="src src-haskell" id="nil-6"><span class="org-haskell-pragma">{-# language CPP                   #-}</span>
<span class="org-haskell-pragma">{-# language DataKinds             #-}</span>
<span class="org-haskell-pragma">{-# language DeriveAnyClass        #-}</span>
<span class="org-haskell-pragma">{-# language DeriveGeneric         #-}</span>
<span class="org-haskell-pragma">{-# language DerivingVia           #-}</span>
<span class="org-haskell-pragma">{-# language DuplicateRecordFields #-}</span>
<span class="org-haskell-pragma">{-# language FlexibleContexts      #-}</span>
<span class="org-haskell-pragma">{-# language FlexibleInstances     #-}</span>
<span class="org-haskell-pragma">{-# language MultiParamTypeClasses #-}</span>
<span class="org-haskell-pragma">{-# language OverloadedLabels      #-}</span>
<span class="org-haskell-pragma">{-# language PolyKinds             #-}</span>
<span class="org-haskell-pragma">{-# language TemplateHaskell       #-}</span>
<span class="org-haskell-pragma">{-# language TypeFamilies          #-}</span>
<span class="org-haskell-pragma">{-# language TypeOperators         #-}</span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">MelbyClient.Schema</span> <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Text</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">T</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Map.Strict</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">M</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">GHC.Generics</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.Quasi.GRpc</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.Schema</span>

<span class="org-haskell-definition">grpc</span> <span class="org-string">"MelbyClientSchema"</span> id <span class="org-string">"lib/MelbyClient/melby_client.proto"</span>

<span class="org-comment-delimiter">-- </span><span class="org-comment">The "M" prefix for the types here is for "Message" as in a gRPC "message"</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">type.</span>

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MViewRequest</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MViewRequest</span>
  { config_path <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  , config <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  , env_vars <span class="org-haskell-operator">::</span> <span class="org-haskell-type">M.Map</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-type">T.Text</span>
  , shell_pid <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyClientSchema</span> <span class="org-string">"ViewRequest"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyClientSchema</span> <span class="org-string">"ViewRequest"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MViewResponse</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MViewResponse</span>
  { status <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MViewStatus</span>
  , view <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  , error <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyClientSchema</span> <span class="org-string">"ViewResponse"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyClientSchema</span> <span class="org-string">"ViewResponse"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MViewStatus</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">VIEW_STATUS_UNSPECIFIED</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">VIEW_STATUS_ERROR</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">VIEW_STATUS_OK</span>
  <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyClientSchema</span> <span class="org-string">"ViewStatus"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyClientSchema</span> <span class="org-string">"ViewStatus"</span>)
</pre></div>
</div>
</div>

<div id="outline-container-h-Other" class="outline-4">
<h4 id="h-Other"><span class="section-number-4">5.5.4.</span> Other</h4>
<div class="outline-text-4" id="text-h-Other">
</div>

<div id="outline-container-h-Pragmas" class="outline-5">
<h5 id="h-Pragmas"><span class="section-number-5">5.5.4.1.</span> Pragmas</h5>
<div class="outline-text-5" id="text-h-Pragmas">
<p>
The language pragmas are not that interesting, as their purpose is to basically
turn on the various GHC extensions that allow us to use the libraries we use.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Layout-of--code-melby-client-hs--code">melbyc_pragmas</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_pragmas">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_pragmas"><span class="org-haskell-pragma">{-# language DataKinds #-}</span>
<span class="org-haskell-pragma">{-# language OverloadedLabels #-}</span>
<span class="org-haskell-pragma">{-# language OverloadedStrings #-}</span>
<span class="org-haskell-pragma">{-# language ScopedTypeVariables #-}</span>
<span class="org-haskell-pragma">{-# language TemplateHaskell #-}</span>
<span class="org-haskell-pragma">{-# language TypeApplications #-}</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Imports" class="outline-5">
<h5 id="h-Imports"><span class="section-number-5">5.5.4.2.</span> Imports</h5>
<div class="outline-text-5" id="text-h-Imports">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Layout-of--code-melby-client-hs--code">melbyc_imports</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_imports">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_imports"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Map.Strict</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">M</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Text</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">T</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Text.IO</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">T</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Version</span> (showVersion)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">GHC.OverloadedLabels</span> (fromLabel)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">GHC.Records</span> (getField)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.GRpc.Client.Optics</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.Schema</span> (fromSchema, toSchema)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Network.Socket</span> (<span class="org-haskell-constructor">PortNumber</span>)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Options.Applicative</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Environment</span> (getEnvironment)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Exit</span> (exitFailure)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.IO</span> (stderr)

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Paths_melby_client</span> (version)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyClient.GitVersion</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyClient.Schema</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Git-versioning" class="outline-5">
<h5 id="h-Git-versioning"><span class="section-number-5">5.5.4.3.</span> Git versioning</h5>
<div class="outline-text-5" id="text-h-Git-versioning">
<p>
We want to store the git hash of the project into the melbyc binary itself (this
is just good practice). The part we do the storing in the binary is done below,
as part of the <code>&lt;&lt;main&gt;&gt;</code> block of code:
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyc_main">melbyc_gitVersion</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyc_gitVersion">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyc_gitVersion"><span class="org-haskell-definition">versionOption</span> <span class="org-haskell-operator">=</span> infoOption
  (concat [showVersion version, <span class="org-string">"-g"</span>, <span class="org-haskell-operator">$</span>(gitVersion)])
  (long <span class="org-string">"version"</span> <span class="org-haskell-operator">&lt;&gt;</span> short <span class="org-string">'v'</span> <span class="org-haskell-operator">&lt;&gt;</span> help <span class="org-string">"Show version"</span>)
</pre></div></div><p>
The underlying plumbing that handles this is done in FIXME path:
</p>

<div class="org-src-container"><pre class="src src-haskell" id="nil-7"><span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">MelbyClient.GitVersion</span>
  ( gitVersion
  ) <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Time.LocalTime</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Language.Haskell.TH</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Environment</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Process</span>

<span class="org-comment-delimiter">-- </span><span class="org-comment">Adapted from</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">https://stackoverflow.com/questions/5713418/templatehaskell-and-io#comment7962237_5713551</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">and https://stackoverflow.com/a/20871010/437583.</span>

<span class="org-haskell-definition">gitVersion</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Q</span> <span class="org-haskell-type">Exp</span>
<span class="org-haskell-definition">gitVersion</span> <span class="org-haskell-operator">=</span> stringE <span class="org-haskell-operator">=&lt;&lt;</span> runIO getCombinedInfo

<span class="org-haskell-definition">getCombinedInfo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-definition">getCombinedInfo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  gi <span class="org-haskell-operator">&lt;-</span> getGitInfo
  ti <span class="org-haskell-operator">&lt;-</span> getTimeInfo
  pure <span class="org-haskell-operator">$</span> concat [gi, <span class="org-string">"  ("</span>, ti, <span class="org-string">")"</span>]

<span class="org-haskell-definition">getGitInfo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-definition">getGitInfo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">We can't use the convenient "tGitInfoCwd" function from the GitHash package</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">because it uses the current directory (and if we are built by cabal, we're</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">not in the actual source directory but a copy of it in a sandboxed folder).</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">The "tGitInfo" function is parameterized to take arbitrary paths, but it's</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">difficult to customize its behavior. Because of this we just invoke git</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">with our own flags, because it's pretty easy to do so.</span>
  <span class="org-comment-delimiter">--</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">Anyway, the point of MELBY_PROJECT_ROOT is so that we can set this</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">environment variable when we invoke cabal, so that we can read it back out</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">here. This way we can pass in environment variables to Template Haskell</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">(compile-time code).</span>
  maybeProjectRoot <span class="org-haskell-operator">&lt;-</span> lookupEnv <span class="org-string">"MELBY_PROJECT_ROOT"</span>
  <span class="org-haskell-keyword">case</span> maybeProjectRoot <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Just</span> projectRoot <span class="org-haskell-operator">-&gt;</span> readProcess <span class="org-string">"git"</span>
      [ <span class="org-string">"-C"</span>
      , projectRoot
      , <span class="org-string">"describe"</span>
      , <span class="org-string">"--abbrev=10"</span>
      , <span class="org-string">"--always"</span>
      , <span class="org-string">"--dirty"</span>
      ] <span class="org-string">""</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-string">"-unknown"</span>

<span class="org-haskell-definition">getTimeInfo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-definition">getTimeInfo</span> <span class="org-haskell-operator">=</span> show <span class="org-haskell-operator">&lt;$&gt;</span> getZonedTime
</pre></div>
</div>
</div>
</div>
</div>

<div id="outline-container-h-Build-system" class="outline-3">
<h3 id="h-Build-system"><span class="section-number-3">5.6.</span> Build system</h3>
<div class="outline-text-3" id="text-h-Build-system">
</div>

<div id="outline-container-h-Makefile-1" class="outline-4">
<h4 id="h-Makefile-1"><span class="section-number-4">5.6.1.</span> Makefile</h4>
<div class="outline-text-4" id="text-h-Makefile-1">
<div class="org-src-container"><pre class="src src-makefile" id="nil-8"><span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Below is an installation rule for a Nix + Cabal workflow. It may be</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">useful to do this in case stack doesn't work for some reason. Originally we</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">wanted to use this workflow instead but ran up against a Nix + MacOS breakage</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">(https://github.com/NixOS/nixpkgs/pull/149942). Currently only stack works, so</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">that's what we use. It may be the case though that we end up using stack</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">long-term, because of its stability guarantees.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">MELBY_PROJECT_ROOT=$(</span><span class="org-comment"><span class="org-variable-name">PWD</span></span><span class="org-comment">) cabal install --overwrite-policy=always</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Let stack be aware of NixOS's non-standard library paths. This is an</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">alternative to specifying the `nix:` field in stack.yaml directly (we just</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">want to use a plain stack.yaml that is not aware of NixOS so that we can use</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">the same stack.yaml file on non-NixOS distributions including MacOS).</span>
<span class="org-variable-name">ZLIB_SO_DIR</span>=$(<span class="org-variable-name">shell</span> pkg-config --libs-only-L zlib)
<span class="org-variable-name">ZLIB_H_DIR</span>=$(<span class="org-variable-name">shell</span> pkg-config --cflags-only-I zlib)

<span class="org-makefile-targets">all</span>: melbyc

<span class="org-makefile-targets">melbyc</span>:
    <span class="org-variable-name">MELBY_PROJECT_ROOT</span>=$(<span class="org-variable-name">PWD</span>) stack build \
        --copy-bins \
        --local-bin-path $(<span class="org-variable-name">PWD</span>) \
        --no-nix-pure \
        <span class="org-variable-name">--extra-lib-dirs</span>=$(<span class="org-variable-name">ZLIB_SO_DIR</span>:<span class="org-variable-name">-L%</span>=%) \
        <span class="org-variable-name">--extra-include-dirs</span>=$(<span class="org-variable-name">ZLIB_H_DIR</span>:<span class="org-variable-name">-I%</span>=%)
<span class="org-makefile-targets">.PHONY</span>: melbyc

<span class="org-makefile-targets">ghci</span>:
    stack exec -- ghci
<span class="org-makefile-targets">.PHONY</span>: ghci
</pre></div><p>
It's OK if <code>MELBY_PROJECT_ROOT</code> isn't actually the Melby project root directory,
because Git will still figure out how to run <code>git describe</code>. We just use
<code>MELBY_PROJECT_ROOT</code> here to be consistent with the Makefile (FIXME: link) for
<code>melby-renderer</code>.
</p>
</div>
</div>

<div id="outline-container-h-Cabal" class="outline-4">
<h4 id="h-Cabal"><span class="section-number-4">5.6.2.</span> Cabal</h4>
<div class="outline-text-4" id="text-h-Cabal">
<div class="org-src-container"><pre class="src src-haskell-cabal" id="nil-9"><span class="org-keyword">name</span>: melby-client
<span class="org-keyword">version</span>: 1.0.0.0
<span class="org-keyword">author</span>: Linus Arver
<span class="org-keyword">maintainer</span>: linusa@google.com
<span class="org-keyword">category</span>: Utility
<span class="org-keyword">build-type</span>: Simple
<span class="org-keyword">cabal-version</span>: &gt;=1.10
<span class="org-keyword">license</span>: Apache-2.0
<span class="org-keyword">license-file</span>: LICENSE
<span class="org-keyword">data-files</span>: lib/MelbyClient/melby_client.proto

<span class="org-keyword">executable</span> <span class="org-function-name">melbyc</span>
  <span class="org-keyword">main-is</span>: melby-client.hs
  <span class="org-keyword">default-language</span>: Haskell2010
  <span class="org-keyword">other-modules</span>:
    Paths_melby_client
  <span class="org-keyword">default-extensions</span>:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  <span class="org-keyword">ghc-options</span>:
    -O2 -Werror -threaded -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  <span class="org-keyword">build-depends</span>:
      base &gt;= 4.8
    , melby-client
    , aeson
    , bytestring
    , conduit &gt;= 1.3.2 &amp;&amp; &lt;2
    , containers
    , http-client
    , mu-grpc-client &gt;=0.3.0.0
    , mu-optics &gt;=0.3.0.0
    , mu-protobuf &gt;= 0.4.0
    , mu-rpc &gt;= 0.4.0
    , mu-schema &gt;= 0.3.0
    , optparse-applicative &gt;= 0.16.1.0
    , network &gt;= 3.1.1.1
    , swagger2
    , text &gt;=1.2 &amp;&amp; &lt;2
    , unordered-containers &gt;= 0.2.16.0

<span class="org-keyword">library</span>
  <span class="org-keyword">default-language</span>: Haskell2010
  <span class="org-keyword">exposed-modules</span>:
    MelbyClient.GitVersion
    MelbyClient.Schema
  <span class="org-keyword">hs-source-dirs</span>:
    lib
  <span class="org-keyword">default-extensions</span>:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  <span class="org-keyword">ghc-options</span>:
    -O2 -Werror -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  <span class="org-keyword">build-depends</span>:
      base &gt;= 4.8
    , aeson
    , bytestring
    , containers
    , mu-protobuf &gt;= 0.4.0
    , mu-schema &gt;= 0.3.0
    , process
    , template-haskell
    , text &gt;=1.2 &amp;&amp; &lt;2
    , time
</pre></div><div class="org-src-container"><pre class="src src-haskell-cabal" id="nil-10"><span class="org-keyword">executable-stripping</span>: <span class="org-constant">True</span>
<span class="org-keyword">packages</span>:
  ./melby-client.cabal
</pre></div>
</div>
</div>

<div id="outline-container-h-melbyc-nix" class="outline-4">
<h4 id="h-melbyc-nix"><span class="section-number-4">5.6.3.</span> melbyc.nix</h4>
<div class="outline-text-4" id="text-h-melbyc-nix">
<p>
We use Stack for building our Haskell binaries. The biggest reason we do this is
simply because Stack's LTS snapshots stay frozen, whereas Nix keeps evolving to
support the latest and greatest packages.
</p>

<div class="org-src-container"><pre class="src src-nix" id="nil-11"><span class="org-nix-keyword">let</span>
  <span class="org-nix-attribute">sources</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">../package/nix/sources.nix</span>;
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs { };
  <span class="org-comment"># Nix never copies the .git directory as input to generate a derivation,</span>
  <span class="org-comment"># because Git's .git directory is not deterministic. So we never have a Git</span>
  <span class="org-comment"># directory, which means any "use git to derive the version" command will</span>
  <span class="org-comment"># fail. One way around this is to fetch a previous version of this repo (using</span>
  <span class="org-comment"># fetchGit) and then use the revision there as an output here using string</span>
  <span class="org-comment"># interpolation. We then make this fake Git script take precedence over the</span>
  <span class="org-comment"># vanilla git binary, tricking our version generation code. See</span>
  <span class="org-comment"># https://jeancharles.quillet.org/posts/2022-04-22-Embed-the-git-hash-into-a-binary-with-nix.html</span>
  <span class="org-comment"># and</span>
  <span class="org-comment"># https://discourse.nixos.org/t/accessing-git-directory-in-flake-with-local-source/17370/7.</span>
  <span class="org-nix-attribute">fakeGit</span> = pkgs.writeShellScriptBin <span class="org-string">"git"</span>
  <span class="org-string">''</span>
<span class="org-string">    echo -unknown</span>
<span class="org-string">  ''</span>;
  <span class="org-nix-attribute">files</span> = [
    <span class="org-nix-constant">./LICENSE</span>
    <span class="org-nix-constant">./cabal.project</span>
    <span class="org-nix-constant">./lib</span>
    <span class="org-nix-constant">./lib/MelbyClient</span>
    <span class="org-nix-constant">./lib/MelbyClient/GitVersion.hs</span>
    <span class="org-nix-constant">./lib/MelbyClient/melby_client.proto</span>
    <span class="org-nix-constant">./lib/MelbyClient/Schema.hs</span>
    <span class="org-nix-constant">./melby-client.cabal</span>
    <span class="org-nix-constant">./melby-client.hs</span>
    <span class="org-nix-constant">./melby-client.nix</span>
    <span class="org-nix-constant">./stack.yaml</span>
    <span class="org-nix-constant">./stack.yaml.lock</span>
  ];
  <span class="org-nix-attribute">macOS-security</span> =
    <span class="org-comment"># Make `/usr/bin/security` available in `PATH`, which is needed for stack</span>
    <span class="org-comment"># on darwin which calls this binary to find certificates. See</span>
    <span class="org-comment"># https://github.com/tweag/rules_haskell/commit/31171a520f49f263895112678ac93c7ed958ead1.</span>
    pkgs.writeScriptBin <span class="org-string">"security"</span> <span class="org-string">''exec /usr/bin/security "$@"''</span>;
<span class="org-nix-keyword">in</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">When we tell  See https://docs.haskellstack.org/en/stable/nix_integration/#using-a-custom-shellnix-file.</span>
{ ghc }:

pkgs.haskell.lib.buildStackProject {
  <span class="org-nix-keyword">inherit</span> ghc;
  <span class="org-nix-attribute">name</span> = <span class="org-string">"melby-client"</span>;
  <span class="org-nix-attribute">src</span> = builtins.path {
    <span class="org-nix-attribute">name</span> = <span class="org-string">"melby-client"</span>;
    <span class="org-nix-attribute">path</span> = <span class="org-nix-constant">./.</span>;
    <span class="org-nix-attribute">filter</span> = path: type: builtins.elem (<span class="org-nix-constant">/.</span> + path) files;
  };
  <span class="org-comment"># System dependencies needed at compilation time.</span>
  <span class="org-nix-attribute">buildInputs</span> = [
    pkgs.zlib
    fakeGit
  ]
  <span class="org-comment"># See</span>
  <span class="org-comment"># https://www.reddit.com/r/haskell/comments/rjm0x8/help_wanted_for_llvm_config_for_haskell_on_mac/</span>
  <span class="org-comment"># about needing a version of LLVM &lt; 13 on Mac.</span>
  ++ pkgs.lib.optionals pkgs.stdenv.isDarwin [pkgs.llvm_12 macOS-security];
}
</pre></div>
</div>
</div>

<div id="outline-container-h-Stack" class="outline-4">
<h4 id="h-Stack"><span class="section-number-4">5.6.4.</span> Stack</h4>
<div class="outline-text-4" id="text-h-Stack">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">client/stack.yaml</label><span class="lilac-caption-link-symbol"><a href="#client-stack-yaml">&#x1f517;</a></span></div><pre class="src src-yaml" id="client-stack-yaml"><span class="org-variable-name">resolver</span>: lts-18.28
<span class="org-variable-name">allow-newer</span>: <span class="org-constant">true</span>

<span class="org-variable-name">packages</span>:
- .

<span class="org-variable-name">extra-deps</span>:
- compendium-client-0.2.1.1@sha256:cd477438d507273b34b82581ade333921ae997c1618b48af0c1da2a4968623e0,1203
- graphql-1.0.3.0
- http2-2.0.6
- http2-client-0.10.0.0
- http2-client-grpc-0.8.0.0
- http2-grpc-proto3-wire-0.1.0.0
- http2-grpc-types-0.5.0.0
- hw-kafka-conduit-2.7.0
- mu-avro-0.4.0.4@sha256:10e317c633c5152a26e89becba749456b76f70eb640d1c0b2ccdc0e45a7ef5da,2096
- mu-grpc-client-0.4.0.2@sha256:cc98a09601b9634531772b270fa9509503048946f27fa47ef140bb8cccb544f2,2006
- mu-grpc-common-0.4.0.0@sha256:568b5879cd67c0bc0e956d53fb87552bb6d9a6287c5d1b09e2284ed5b04de418,1394
- mu-optics-0.3.0.1@sha256:c3494c71c6300e6a0dcb77c9782481150956e912c1b47fccd69cbb795e461d52,1068
- mu-protobuf-0.4.2.0@sha256:4787a2688abdda107e150736433b61448acdf0b71eb0c174232239b4c143f78b,2119
- mu-rpc-0.5.0.2@sha256:470f5bc372de1b212f625f9e7310cdf82b7fa41ddea03e092fccff0cd9e19db1,1430
- mu-schema-0.3.1.2@sha256:c05e58de29d50376638d19dd3357cd3644d39f984664484f3568d5305b3034d9,1933
- stm-containers-1.2
- stm-hamt-1.2.0.7
- tracing-0.0.7.2
- tracing-control-0.0.7.3
- warp-3.3.14
- warp-grpc-0.4.0.1
</pre></div></div>
</div>
</div>

<div id="outline-container-h-gitignore-2" class="outline-4">
<h4 id="h-gitignore-2"><span class="section-number-4">5.6.5.</span> .gitignore</h4>
<div class="outline-text-4" id="text-h-gitignore-2">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">client/.gitignore</label><span class="lilac-caption-link-symbol"><a href="#client--gitignore">&#x1f517;</a></span></div><pre class="src src-gitignore" id="client--gitignore">melbyc
.stack-work
</pre></div></div>
</div>
</div>
</div>


<div id="outline-container-h-Rust-client" class="outline-3">
<h3 id="h-Rust-client"><span class="section-number-3">5.7.</span> Rust client</h3>
<div class="outline-text-3" id="text-h-Rust-client">
</div>

<div id="outline-container-h-Code-overview-1" class="outline-4">
<h4 id="h-Code-overview-1"><span class="section-number-4">5.7.1.</span> Code overview</h4>
<div class="outline-text-4" id="text-h-Code-overview-1">
<p>
While the Haskell client above does work, the <a href="https://github.com/higherkindness/mu-haskell"><code>mu-haskell</code></a> library it depends on
appears to be abandoned. So we need a backup plan in case that library does turn
out to be abandoned forever.
</p>

<p>
Here we use Rust to build an equivalent client. We start with <code>Cargo.toml</code> for
defining dependencies.
</p>

<p>
See more keys and their definitions at <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">https://doc.rust-lang.org/cargo/reference/manifest.html</a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Cargo.toml for client-rust</label><span class="lilac-caption-link-symbol"><a href="#Cargo-toml-for-client-rust">&#x1f517;</a></span></div><pre class="src src-toml" id="Cargo-toml-for-client-rust">[<span class="org-type">package</span>]
<span class="org-variable-name">name</span> = <span class="org-string">"melbyc-rust"</span>
<span class="org-variable-name">description</span> = <span class="org-string">"melby client, written in Rust"</span>
<span class="org-variable-name">version</span> = <span class="org-string">"0.1.0"</span>
<span class="org-variable-name">edition</span> = <span class="org-string">"2021"</span>

[<span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type">dependencies</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>]
<span class="org-variable-name">tonic</span> = <span class="org-string">"0.11"</span>
<span class="org-variable-name">tokio</span> = { version = <span class="org-string">"1.0"</span>, features = [<span class="org-string">"macros"</span>, <span class="org-string">"rt-multi-thread"</span>] }
<span class="org-variable-name">prost</span> = <span class="org-string">"0.12"</span>
<span class="org-variable-name">clap</span> = { version = <span class="org-string">"4.5.4"</span>, features = [<span class="org-string">"derive"</span>]}
<span class="org-variable-name">config</span> = { version = <span class="org-string">"0.14"</span>, features = [<span class="org-string">"yaml"</span>]}

[<span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type">build-dependencies</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>]
<span class="org-variable-name">tonic-build</span> = <span class="org-string">"0.11"</span>

[[<span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type">bin</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>]]
<span class="org-variable-name">name</span> = <span class="org-string">"melbyc-rust"</span>
<span class="org-variable-name">path</span> = <span class="org-string">"src/main.rs"</span>

[<span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type">profile.release</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>]
<span class="org-comment-delimiter"># </span><span class="org-comment">Strip all symbols.</span>
<span class="org-variable-name">strip</span> = <span class="org-keyword">true</span>
</pre></div></div><p>
And here's the <code>.gitignore</code> for this client.
</p>

<div class="org-src-container"><pre class="src src-gitignore" id="nil-12">target
</pre></div><p>
Here's the <code>Makefile</code> for building and testing.
</p>

<div class="org-src-container"><pre class="src src-makefile" id="nil-13"><span class="org-makefile-targets">build_dev</span>:
    cargo build
<span class="org-makefile-targets">.PHONY</span>: build_dev

<span class="org-makefile-targets">build_prod</span>:
    cargo build --release
<span class="org-makefile-targets">.PHONY</span>: build_prod

<span class="org-makefile-targets">test</span>:
    cargo test
<span class="org-makefile-targets">.PHONY</span>: test
</pre></div><p>
Here's the file for protobuf code generation. The <code>build.rs</code> name is a special
name that Cargo recognizes automatically.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">build.rs for client-rust</label><span class="lilac-caption-link-symbol"><a href="#build-rs-for-client-rust">&#x1f517;</a></span></div><pre class="src src-rust" id="build-rs-for-client-rust"><span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;

<span class="org-keyword">fn</span> <span class="org-function-name">main</span>() -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Error</span>&gt;&gt; {
    <span class="org-constant">tonic_build</span>::compile_protos(<span class="org-string">"proto/melby_client.proto"</span>)<span class="org-rust-question-mark">?</span>;
    <span class="org-constant">tonic_build</span>::configure()
    .build_server(<span class="org-keyword">false</span>)
    .out_dir(<span class="org-string">"src/grpc_generated"</span>)  <span class="org-comment-delimiter">// </span><span class="org-comment">you can change the generated code's location</span>
    .compile(
        <span class="org-rust-ampersand">&amp;</span>[<span class="org-string">"proto/melby_client.proto"</span>],
        <span class="org-rust-ampersand">&amp;</span>[<span class="org-string">"proto"</span>], <span class="org-comment-delimiter">// </span><span class="org-comment">specify the root location to search proto dependencies</span>
    ).unwrap();

    <span class="org-type">Ok</span>(())
}
</pre></div></div><p>
The code above generates <code>src/grpc_generated/melby_client.rs</code>. In order to
import it as a module, we have to export it as part of the <code>grpc_generated</code>
package. We do that below.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">mod.rs for generated code</label><span class="lilac-caption-link-symbol"><a href="#mod-rs-for-generated-code">&#x1f517;</a></span></div><pre class="src src-rust" id="mod-rs-for-generated-code"><span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">melby_client</span>;
</pre></div></div>
</div>

<div id="outline-container-h-Main-function" class="outline-5">
<h5 id="h-Main-function"><span class="section-number-5">5.7.1.1.</span> Main function</h5>
<div class="outline-text-5" id="text-h-Main-function">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">main.rs for client-rust</label><span class="lilac-caption-link-symbol"><a href="#main-rs-for-client-rust">&#x1f517;</a></span></div><pre class="src src-rust" id="main-rs-for-client-rust"><span class="lilac-child-link-from-parent"><a href="#__NREF__client-rust--imports-1">client-rust--imports</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__client-rust--option-handling-1">client-rust--option-handling</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__client-rust--main">client-rust--main</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__client-rust--business-logic">client-rust--business-logic</a></span>
</pre></div></div><p>
Basic imports.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#main-rs-for-client-rust">client-rust--imports</a></span>(1/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__client-rust--imports-1">&#x1f517;</a></span></div><pre class="src src-rust" id="__NREF__client-rust--imports-1"><span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">HashMap</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">path</span>::<span class="org-type">PathBuf</span>;
<span class="org-keyword">use</span> <span class="org-constant">clap</span>::{<span class="org-type">Parser</span>, <span class="org-type">Subcommand</span>};
</pre></div></div><p>
Import generated gRPC code. These are built by <code>build.rs</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#main-rs-for-client-rust">client-rust--imports</a></span>(2/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__client-rust--imports-2">&#x1f517;</a></span></div><pre class="src src-rust" id="__NREF__client-rust--imports-2"><span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">grpc_generated</span>;
<span class="org-keyword">use</span> <span class="org-constant">grpc_generated</span>::<span class="org-constant">melby_client</span>::<span class="org-constant">view_client</span>::<span class="org-type">ViewClient</span>;
<span class="org-keyword">use</span> <span class="org-constant">grpc_generated</span>::<span class="org-constant">melby_client</span>::<span class="org-type">ViewRequest</span>;
</pre></div></div><p>
Global options.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#main-rs-for-client-rust">client-rust--option-handling</a></span>(1/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__client-rust--option-handling-1">&#x1f517;</a></span></div><pre class="src src-rust" id="__NREF__client-rust--option-handling-1"><span class="org-preprocessor">#[derive(Parser)]</span>
<span class="org-preprocessor">#[command(version, about, long_about = None)]</span>
<span class="org-doc">/// Global options (applies to all subcommands).</span>
<span class="org-keyword">struct</span> <span class="org-type">Cli</span> {
    <span class="org-doc">/// Config file path.</span>
    <span class="org-preprocessor">#[arg(short, long,</span>
<span class="org-preprocessor">          value_name = </span><span class="org-string">"LUA_CONFIG_FILE"</span><span class="org-preprocessor">, default_value = </span><span class="org-string">"~/.melby/melby.lua"</span><span class="org-preprocessor">)]</span>
    <span class="org-variable-name">config</span>: <span class="org-type">PathBuf</span>,

    <span class="org-doc">/// Inline Lua config if you want to test out small(er) snippets of code</span>
    <span class="org-doc">/// directly without having to write a LUA_CONFIG_FILE on disk somewhere.</span>
    <span class="org-doc">/// Currently ignored by the daemon.</span>
    <span class="org-preprocessor">#[arg(short = </span><span class="org-string">'r'</span><span class="org-preprocessor">, long,</span>
<span class="org-preprocessor">          value_name = </span><span class="org-string">"RAW_INLINE_LUA_CONFIG"</span><span class="org-preprocessor">, default_value = </span><span class="org-string">""</span><span class="org-preprocessor">)]</span>
    <span class="org-variable-name">config_raw</span>: <span class="org-type">String</span>,

    <span class="org-doc">/// Port of melbyd (presumed to be running on localhost).</span>
    <span class="org-preprocessor">#[arg(short, long, default_value_t = 50051)]</span>
    <span class="org-variable-name">melbyd_port</span>: <span class="org-type">u16</span>,

    <span class="org-doc">/// Subcommands.</span>
    <span class="org-preprocessor">#[command(subcommand)]</span>
    <span class="org-variable-name">command</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Commands</span>&gt;,
}
</pre></div></div><p>
Subcommands. There's only 1 right now, but we'll have more in the future.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#main-rs-for-client-rust">client-rust--option-handling</a></span>(2/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__client-rust--option-handling-2">&#x1f517;</a></span></div><pre class="src src-rust" id="__NREF__client-rust--option-handling-2"><span class="org-doc">/// Subcommands and their options.</span>
<span class="org-preprocessor">#[derive(Subcommand)]</span>
<span class="org-keyword">enum</span> <span class="org-type">Commands</span> {
    <span class="org-type">View</span> {
        <span class="org-preprocessor">#[arg(short, long, default_value_t = 0)]</span>
        <span class="org-variable-name">shell_pid</span>: <span class="org-type">u32</span>,
    },
}
</pre></div></div><p>
Entrypoint.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#main-rs-for-client-rust">client-rust--main</a></span>(1/1) <span class="lilac-caption-link-symbol"><a href="#__NREF__client-rust--main">&#x1f517;</a></span></div><pre class="src src-rust" id="__NREF__client-rust--main"><span class="org-preprocessor">#[tokio::main]</span>
<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">main</span>() -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Error</span>&gt;&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">cli</span> = <span class="org-type">Cli</span>::parse();

    <span class="org-keyword">match</span> <span class="org-rust-ampersand">&amp;</span>cli.command {
        <span class="org-type">Some</span>(<span class="org-type">Commands</span>::<span class="org-type">View</span> { shell_pid }) =&gt; {
            view(<span class="org-rust-ampersand">&amp;</span>cli, *shell_pid).<span class="org-keyword">await</span><span class="org-rust-question-mark">?</span>;
        }
        <span class="org-type">None</span> =&gt; {
            ()
        }
    }

    <span class="org-type">Ok</span>(())
}
</pre></div></div><p>
View the output of running the Lua configuration inside melbyd.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#main-rs-for-client-rust">client-rust--business-logic</a></span>(1/1) <span class="lilac-caption-link-symbol"><a href="#__NREF__client-rust--business-logic">&#x1f517;</a></span></div><pre class="src src-rust" id="__NREF__client-rust--business-logic"><span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">view</span>(<span class="org-variable-name">cli</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Cli</span>, <span class="org-variable-name">shell_pid</span>: <span class="org-type">u32</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Error</span>&gt;&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">url</span> = <span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"http://127.0.0.1:</span><span class="org-rust-string-interpolation">{0}</span><span class="org-string">"</span>, cli.melbyd_port);
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">client</span> = <span class="org-type">ViewClient</span>::connect(url).<span class="org-keyword">await</span><span class="org-rust-question-mark">?</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">FIXME: Instead of slurping up everything, only slurp up</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">an "allowlist" of known ENV vars we want to feed into the daemon. This</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">allowlist could be defined in settings.yml or even as an additive list of</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">flags. We could do the additive list of flags first and then move to</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">settings.yml in the future if there are just too many flags.</span>
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env_vars</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt; = <span class="org-type">HashMap</span>::new();
    <span class="org-keyword">for</span> (k, v) <span class="org-keyword">in</span> <span class="org-constant">std</span>::<span class="org-constant">env</span>::vars() {
        env_vars.insert(k, v);
    }

    <span class="org-keyword">let</span> <span class="org-variable-name">req</span> = <span class="org-type">ViewRequest</span> {
        <span class="org-variable-name">config_path</span>: cli.config.display().to_string(),
        <span class="org-variable-name">config</span>: cli.config_raw.to_string(),
        <span class="org-variable-name">env_vars</span>: env_vars,
        <span class="org-variable-name">shell_pid</span>: shell_pid.to_string(),
    };

    <span class="org-keyword">let</span> <span class="org-variable-name">request</span> = <span class="org-constant">tonic</span>::<span class="org-type">Request</span>::new(req);
    <span class="org-keyword">let</span> <span class="org-variable-name">response</span> = client.get_view(request).<span class="org-keyword">await</span><span class="org-rust-question-mark">?</span>;

    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, response.get_ref().view);

    <span class="org-type">Ok</span>(())
}
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Packaging-1" class="outline-4">
<h4 id="h-Packaging-1"><span class="section-number-4">5.7.2.</span> Packaging</h4>
<div class="outline-text-4" id="text-h-Packaging-1">
<div class="org-src-container"><pre class="src src-nix" id="nil-14">{ sources ? <span class="org-nix-builtin">import</span> <span class="org-nix-constant">../package/nix/sources.nix</span> }:
<span class="org-nix-keyword">let</span>
  <span class="org-comment"># Overlays</span>
  <span class="org-nix-attribute">oxalica-rust-overlay</span> = <span class="org-nix-builtin">import</span> sources.rust-overlay;
  <span class="org-comment"># Build rust crates.</span>
  <span class="org-nix-attribute">naersk</span> = pkgs.callPackage sources.naersk {
    <span class="org-nix-attribute">cargo</span> = pkgs.rust-bin.stable.latest.minimal;
    <span class="org-nix-attribute">rustc</span> = pkgs.rust-bin.stable.latest.minimal;
  };
  <span class="org-comment"># The final "pkgs" attribute with all the bells and whistles of our overlays.</span>
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs {
    <span class="org-nix-attribute">overlays</span> = [
      oxalica-rust-overlay
    ];
  };
<span class="org-nix-keyword">in</span>
  naersk.buildPackage {
    <span class="org-nix-attribute">src</span> = <span class="org-nix-constant">./.</span>;
    <span class="org-nix-attribute">copyBins</span> = <span class="org-nix-builtin">true</span>;
    <span class="org-nix-attribute">copyTarget</span> = <span class="org-nix-builtin">false</span>;
    <span class="org-comment"># See https://pyo3.rs/v0.14.2/building_and_distribution.html#macos (by way</span>
    <span class="org-comment"># of https://github.com/PyO3/pyo3/issues/1800#issuecomment-1071890916).</span>
    <span class="org-nix-attribute">CARGO_BUILD_RUSTFLAGS</span> = pkgs.lib.optional
      pkgs.stdenv.isDarwin
      <span class="org-string">"-C link-arg=-undefined -C link-arg=dynamic_lookup"</span>;
    <span class="org-nix-attribute">buildInputs</span> = [
      pkgs.protobuf
    ];
  }
</pre></div>
</div>
</div>
</div>
</div>

<div id="outline-container-h-melbyd" class="outline-2">
<h2 id="h-melbyd"><span class="section-number-2">6.</span> melbyd</h2>
<div class="outline-text-2" id="text-h-melbyd">
</div>

<div id="outline-container-h-Purpose-1" class="outline-3">
<h3 id="h-Purpose-1"><span class="section-number-3">6.1.</span> Purpose</h3>
<div class="outline-text-3" id="text-h-Purpose-1">
<p>
<code>melbyd</code> is the daemon for Melby. It is written in Elixir and serves requests to
<code>melbyc</code> (the client). The daemon is the heart of the project because it's where
most of the interesting things happen.
</p>
</div>
</div>

<div id="outline-container-h-Proto-1" class="outline-3">
<h3 id="h-Proto-1"><span class="section-number-3">6.2.</span> Proto</h3>
<div class="outline-text-3" id="text-h-Proto-1">
<div class="org-src-container"><pre class="src src-protobuf" id="nil-15">syntax = <span class="org-string">"proto3"</span>;

<span class="org-keyword">package</span> <span class="org-type">melby</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Client communication.</span>
<span class="org-keyword">import</span> <span class="org-string">"melby_client.proto"</span>;
<span class="org-keyword">import</span> <span class="org-string">"melby_daemon.proto"</span>;
<span class="org-keyword">import</span> <span class="org-string">"melby_renderer.proto"</span>;
</pre></div>
</div>
</div>

<div id="outline-container-h-Tech-stack-1" class="outline-3">
<h3 id="h-Tech-stack-1"><span class="section-number-3">6.3.</span> Tech stack</h3>
<div class="outline-text-3" id="text-h-Tech-stack-1">
<p>
The configuration language for shell prompts (the interface to using Melby for
end users) is Lua. This Lua configuration is used to set up Luerl VMs inside
Elixir, where one VM corresponds to one shell PID's prompt.
</p>

<p>
Elixir is the heart of the stack. There is a bit of Rust (as NIFs in Elixir), as
well as some Haskell for the renderer (melbyr). We use gRPC for all
communication across services.
</p>

<p>
The client (melbyc) communicates with the Elixir daemon (melbyd). Currently
there are two implementations of the client, one in Haskell and another in Rust.
As the client is rather thin, the choice of language doesn't matter so much
here.
</p>
</div>
</div>

<div id="outline-container-h-Life-of-a-request-to-render-a-shell-prompt" class="outline-3">
<h3 id="h-Life-of-a-request-to-render-a-shell-prompt"><span class="section-number-3">6.4.</span> Life of a request to render a shell prompt</h3>
<div class="outline-text-3" id="text-h-Life-of-a-request-to-render-a-shell-prompt">
<p>
Keep in mind that in order to create a request, the user must first define Lua
configuration that describes what sort of data we want in the prompt, as well as
how to present it (colors, padding, etc). We have sample configuration that the
user can use in our test folder.
</p>

<p>
With that out of the way, let's look at the flow of a request:
</p>

<ol class="org-ol">
<li><code>GetView</code> gRPC method called by melbyc (client): The client sends the path to
the main Lua configuration file on disk.</li>

<li>Melbyd (daemon) reads the Lua configuration and interprets it. The Lua code
contains calls to the Melby SDK. That is, the Lua code is allowed to call
into melbyd (Elixir) to <b>generate data</b> (melbyd), as well as <b>format/render</b>
that data (ultimately through melbyr).</li>

<li>The formatted data is returned as a <code>ViewResponse</code>. Currently the response is
just inline shell code which can be sourced directly by the shell. The
inline code assigns values to certain shell variables, and these shell
variables are meant to be combined into the user's <code>PS1</code> shell variable.</li>
</ol>
</div>
</div>

<div id="outline-container-h-Internals" class="outline-3">
<h3 id="h-Internals"><span class="section-number-3">6.5.</span> Internals</h3>
<div class="outline-text-3" id="text-h-Internals">
</div>

<div id="outline-container-h-Standard-Resource-Server" class="outline-4">
<h4 id="h-Standard-Resource-Server"><span class="section-number-4">6.5.1.</span> Standard Resource Server</h4>
<div class="outline-text-4" id="text-h-Standard-Resource-Server">
<p>
This section describes the implementation of the Standard Resource Server, a
generic <code>GenServer</code> that is designed to store arbitrary state from the output of
shell commands, all configured via Lua by the user. SRS is designed to be
generic enough to solve 80% of the problem of defining easily-tracked resources
which can be cached (stored in <code>GenServer</code> state) and retrieved for consumption,
typically for building shell prompts and/or status information.
</p>

<p>
The use of the cache is important because SRS will only execute the shell
command(s) needed to generate a new state if it detects possible staleness of
the existing data. Then, the new state (only if it is meaningfully different
than the existing one) will be used to compare against the previously-stored
state. Then a diffing function will run to compare these states, and store a
new message in the message inbox for this SRS if there is some interesting
difference worth noting.
</p>

<p>
In summary (FIXME: add diagram), we store 2 things:
</p>

<ol class="org-ol">
<li>the history of states (has at least the 2 most recent "readings"), and</li>

<li>a message box to store notable changes to the state history.</li>
</ol>

<p>
We keep track of a standard resource, where the state for this resource is
generated via shell commands and parsed via Lua configuration. This is a
general-purpose module designed for use with various shell commands.
</p>

<p>
If no clients request information from us for some TTL period of time, we shut
down this process.
</p>
</div>

<div id="outline-container-h-Proto-2" class="outline-5">
<h5 id="h-Proto-2"><span class="section-number-5">6.5.1.1.</span> Proto</h5>
<div class="outline-text-5" id="text-h-Proto-2">
<div class="org-src-container"><pre class="src src-protobuf" id="nil-16">syntax = <span class="org-string">"proto3"</span>;

<span class="org-keyword">package</span> <span class="org-type">melby_daemon</span>;

<span class="org-keyword">message</span> <span class="org-type">StandardResource</span> {
  <span class="org-type">StandardResourceStatus</span> <span class="org-variable-name">status</span> = 1;
  map&lt;<span class="org-type">string</span>, <span class="org-type">string</span>&gt; kvs = 2;
}

<span class="org-keyword">enum</span> <span class="org-type">StandardResourceStatus</span> {
  STANDARD_RESOURCE_STATUS_UNSPECIFIED = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Denotes that the basic resource was not able to be retrieved because it was</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">invoked wrongly (e.g., a non-git-repo given to a git command).</span>
  STANDARD_RESOURCE_STATUS_NOT_APPLICABLE = 1;

  STANDARD_RESOURCE_STATUS_LOADING = 2;
  STANDARD_RESOURCE_STATUS_LOADED = 3;
}
</pre></div>
</div>
</div>

<div id="outline-container-h-Implementation" class="outline-5">
<h5 id="h-Implementation"><span class="section-number-5">6.5.1.2.</span> Implementation</h5>
<div class="outline-text-5" id="text-h-Implementation">
<div class="org-src-container"><pre class="src src-elixir" id="nil-17"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.StandardResource</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">If a Standard Resource Service process dies, don't restart it, because it</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">will be restarted on the next use (when a client requests info for it).</span>
  <span class="org-keyword">use</span> <span class="org-type">GenServer</span>, <span class="org-elixir-atom">restart:</span> <span class="org-elixir-atom">:temporary</span>
  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">1 second. This is how quickly we can call the various reader functions</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">(which can be expensive). If we detect some possibility of staleness, we</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">re-execute the reader functions to retrieve the new state. If no staleness</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">is detected, then nothing happens in this tick.</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">In the case where staleness is detected, we run the "read" function which</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">re-reads state. After this function complete, we run tick() again. So the</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">"busiest" we can be is tick() -&gt; read() -&gt; tick() -&gt; read(), and so on. Or,</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">more realistically, it will be tick() -&gt; tick() -&gt; tick() -&gt; read() -&gt;</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">tick(), where there are multiple (possibly tens or hundreds) of ticks before</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">we need to call read().</span>
  <span class="org-elixir-attribute">@tick_interval</span> <span class="org-elixir-number">1000</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">This function is called to initiate a brand new process. The most important</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">part here is the id, which is passed into via_tuple/1 to generate a tuple</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">that can be used to look up this process in a globally unique way. This way</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">we can send messages to *existing* processes and work with them.</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Note that we pass the args_for_init tuple as the second argument to</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">GenServer.start_link/3, which in turn runs the init/1 callback by passing in</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">this same second argument.</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">An SRS instance is started by a gRPC call from melbyc, because only melbyc</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">knows which repo_id path to use (using "git"-flavored SRS as an example).</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Because melbyc is the entrypoint, we should store all Lua config for SRS in</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">the same config used by the user for prompt generation and widget rendering.</span>
  <span class="org-keyword">def</span> <span class="org-function-name">start_link</span>(
        %{
          <span class="org-elixir-atom">id:</span> {<span class="org-comment">_resource_type</span>, <span class="org-comment">_resource_id</span>} = id,
          <span class="org-elixir-atom">resource:</span> <span class="org-comment">_resource</span>,
          <span class="org-elixir-atom">resource_opts:</span> <span class="org-comment">_resource_opts</span>,
          <span class="org-elixir-atom">ttl:</span> <span class="org-comment">_ttl</span>,
          <span class="org-elixir-atom">notify_on_exit_pid:</span> <span class="org-comment">_notify_on_exit_pid</span>
        } = args_for_init
      ) <span class="org-keyword">do</span>
    <span class="org-type">GenServer</span>.start_link(<span class="org-constant">__MODULE__</span>, args_for_init, <span class="org-elixir-atom">name:</span> via_tuple(id))
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Used to identify this process uniquely in the entire Elixir system. We use</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">the gproc library for this.</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">via_tuple</span>(id) <span class="org-keyword">do</span>
    <span class="org-variable-name">key</span> = {<span class="org-elixir-atom">:n</span>, <span class="org-elixir-atom">:l</span>, {<span class="org-constant">__MODULE__</span>, id}}
    {<span class="org-elixir-atom">:via</span>, <span class="org-elixir-atom">:gproc</span>, key}
  <span class="org-keyword">end</span>

  <span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
  <span class="org-keyword">def</span> <span class="org-function-name">init</span>(
        %{
          <span class="org-elixir-atom">id:</span> id,
          <span class="org-elixir-atom">resource:</span> resource,
          <span class="org-elixir-atom">resource_opts:</span> resource_opts,
          <span class="org-elixir-atom">ttl:</span> ttl,
          <span class="org-elixir-atom">notify_on_exit_pid:</span> notify_on_exit_pid
        } = <span class="org-comment">_args</span>
      ) <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Trap exits so that we can terminate gracefully (such as not logging an</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">error due to an intentional shutdown).</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Note that this will result in receiving all exits from all other linked</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">processes --- in our case this happens rather frequently from our use of</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">System.cmd/3 when the shell processes we start exit normally after</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">finishing execution (with a ":normal" reason).</span>
    <span class="org-type">Process</span>.flag(<span class="org-elixir-atom">:trap_exit</span>, <span class="org-elixir-atom">true</span>)

    <span class="org-type">Logger</span>.info(<span class="org-string">"Starting SRS </span><span class="org-variable-name">#{inspect(id)}</span><span class="org-string">; ttl=</span><span class="org-variable-name">#{inspect(ttl)}</span><span class="org-string">"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">We have to subscribe to the fake_* topic ASAP (in init/1 here, not in</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">handle_continue/2), because it may be the case that handle_continue/2 will</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">not finish running by the time we broadcast the message to shut down this</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">GenServer on this fake_* topic.</span>
    <span class="org-keyword">if</span> resource_opts[<span class="org-string">"fake"</span>] <span class="org-keyword">do</span>
      <span class="org-type">Logger</span>.debug(<span class="org-string">"</span><span class="org-variable-name">#{inspect(id)}</span><span class="org-string">: subscribing to fake_"</span> &lt;&gt; resource_opts[<span class="org-string">"vm_fingerprint"</span>])
      <span class="org-comment-delimiter"># </span><span class="org-comment">Listen to the topic dedicated for all fakes created for a particular</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">vm_fingerprint. Then later when we're done with using this fake</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">(validation phase is over), we can delete all fakes by sending a message</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">here.</span>
      <span class="org-type">Phoenix.PubSub</span>.subscribe(<span class="org-type">Melbyd.PubSub</span>, <span class="org-string">"fake_"</span> &lt;&gt; resource_opts[<span class="org-string">"vm_fingerprint"</span>])
    <span class="org-keyword">end</span>

    <span class="org-variable-name">initial_state</span> = %{
      <span class="org-elixir-atom">id:</span> id,
      <span class="org-elixir-atom">resource:</span> resource,
      <span class="org-elixir-atom">resource_opts:</span> resource_opts,
      <span class="org-elixir-atom">state_hist:</span> [],
      <span class="org-comment-delimiter"># </span><span class="org-comment">This is stale because we haven't read any information yet.</span>
      <span class="org-elixir-atom">stale:</span> <span class="org-elixir-atom">true</span>,
      <span class="org-elixir-atom">ttl:</span> ttl,
      <span class="org-elixir-atom">ttl_max:</span> ttl,
      <span class="org-elixir-atom">notify_on_exit_pid:</span> notify_on_exit_pid,
      <span class="org-elixir-atom">reads:</span> <span class="org-elixir-number">0</span>
    }

    <span class="org-comment-delimiter"># </span><span class="org-comment">Return quickly, so that we don't block the creation of this GenServer. We</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">handle additional setup in the handle_continue/2 below.</span>
    {<span class="org-elixir-atom">:ok</span>, initial_state, {<span class="org-elixir-atom">:continue</span>, <span class="org-elixir-atom">:initial_read</span>}}
  <span class="org-keyword">end</span>

  <span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
  <span class="org-keyword">def</span> <span class="org-function-name">handle_continue</span>(
        <span class="org-elixir-atom">:initial_read</span>,
        %{
          <span class="org-elixir-atom">id:</span> id,
          <span class="org-elixir-atom">resource:</span> resource,
          <span class="org-elixir-atom">resource_opts:</span> resource_opts,
          <span class="org-elixir-atom">ttl:</span> ttl,
          <span class="org-elixir-atom">ttl_max:</span> ttl,
          <span class="org-elixir-atom">notify_on_exit_pid:</span> notify_on_exit_pid,
          <span class="org-elixir-atom">reads:</span> reads
        } = state
      ) <span class="org-keyword">do</span>
    {resource_type, resource_id} = id

    <span class="org-comment-delimiter"># </span><span class="org-comment">Do an initial read to populate state. Note that this assumes that melbyd is</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">running on the same machine as the client.</span>
    <span class="org-variable-name">t1</span> = <span class="org-type">Timex</span>.local()
    <span class="org-variable-name">state_current</span> = run_readers(resource, resource_opts, reads)
    <span class="org-variable-name">t2</span> = <span class="org-type">Timex</span>.local()

    <span class="org-comment-delimiter"># </span><span class="org-comment">Give diagnostic report about how long it took to run all the commands to</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">generate the initial state.</span>
    <span class="org-variable-name">seconds_float</span> = <span class="org-type">DateTime</span>.diff(t2, t1, <span class="org-elixir-number">10</span>) / <span class="org-elixir-number">10</span>

    <span class="org-variable-name">message</span> = %{
      <span class="org-elixir-atom">topic:</span> <span class="org-string">"srs_</span><span class="org-variable-name">#{resource_type}</span><span class="org-string">"</span>,
      <span class="org-elixir-atom">from:</span> <span class="org-string">"</span><span class="org-variable-name">#{resource_id}</span><span class="org-string">"</span>,
      <span class="org-elixir-atom">payload:</span> %{
        <span class="org-elixir-atom">level:</span> <span class="org-string">"info"</span>,
        <span class="org-elixir-atom">time:</span> <span class="org-type">Calendar</span>.strftime(t2, <span class="org-string">"%H:%M:%S"</span>),
        <span class="org-elixir-atom">text:</span> <span class="org-string">"Initial read took </span><span class="org-variable-name">#{seconds_float}</span><span class="org-string">s."</span>
      }
    }

    <span class="org-type">Phoenix.PubSub</span>.broadcast(<span class="org-type">Melbyd.PubSub</span>, <span class="org-string">"srs_"</span> &lt;&gt; resource_type, message)

    <span class="org-comment-delimiter"># </span><span class="org-comment">History of states to store. This could be 1 or 100, depending on how much</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">recency data we want to retain. It may be that we want to store 100</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">(unique) states because we want to keep short-term-memory that we want to</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">retrieve, such as "what are the names of all git branches I have checked</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">out in the current session?" to be able to switch to them easily without</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">having to remember the exact names. Another example is providing users a</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">list of all unique SHAs that were visited in the current session.</span>
    <span class="org-variable-name">state_hist</span> = [state_current]

    <span class="org-variable-name">new_state</span> = %{
      state
      | <span class="org-elixir-atom">state_hist:</span> state_hist,
        <span class="org-elixir-atom">stale:</span> <span class="org-elixir-atom">false</span>,
        <span class="org-elixir-atom">reads:</span> reads + <span class="org-elixir-number">1</span>
    }

    <span class="org-comment-delimiter"># </span><span class="org-comment">Activate staleness detectors. For the FileSystem, we set up an</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">fs_event_handler.</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">For fake resources, we skip setting up filesystem-based staleness</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">detection because we want to stop SRS from reading state on its own</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">initiative. Instead for fake resources, their states should only be</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">refreshed when the caller calls read().</span>
    <span class="org-variable-name">new_state</span> =
      <span class="org-keyword">if</span> resource_opts[<span class="org-string">"fake"</span>] <span class="org-keyword">do</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">For "fake" resources, skip filesystem flaggers because we could be</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">working with fake filesystem folders that don't actually exist. In</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">exchange, it's up to the rest of the fake handling code to understand</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">how to make up for this (make the user send in fake filesystem events</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">that SRS can still react to).</span>
        new_state
      <span class="org-keyword">else</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Move all of this to a "setup_staleness_flaggers" function.</span>
        [staleness_flaggers_luerl_array] = resource[<span class="org-string">"staleness_flaggers"</span>].([resource_id])

        <span class="org-variable-name">staleness_flaggers_luerl_tables</span> =
          <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list(staleness_flaggers_luerl_array)

        <span class="org-variable-name">staleness_flaggers</span> =
          staleness_flaggers_luerl_tables <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-type">&amp;Melbyd.LuerlUtil</span>.table_to_native_map/<span class="org-elixir-number">1</span>)

        <span class="org-type">Enum</span>.reduce(staleness_flaggers, new_state, &amp;setup_staleness_flagger/<span class="org-elixir-number">2</span>)
      <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Start up the tick process to detect staleness and subsequent re-reading of</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">state. Only do this if we are a real resource.</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> resource_opts[<span class="org-string">"fake"</span>] <span class="org-keyword">do</span>
      tick(ttl, notify_on_exit_pid)
    <span class="org-keyword">end</span>

    {<span class="org-elixir-atom">:noreply</span>, new_state}
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">run_readers</span>(resource, resource_opts, reads) <span class="org-keyword">do</span>
    [readers_luerl_array] = resource[<span class="org-string">"readers"</span>].([resource_opts])
    <span class="org-variable-name">readers</span> = <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list(readers_luerl_array)

    <span class="org-variable-name">kvs</span> =
      <span class="org-keyword">if</span> resource_opts[<span class="org-string">"fake"</span>] <span class="org-keyword">do</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Run the fake readers instead of the real ones.</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">For the time_idx, we can use a new "reads" field in the state that</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">starts at 0 and is incremented by 1 every time that run_readers()</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">completes. We don't care about overflows because Elixir uses arbitrary</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">precision integers (and btw it'll take billions of years of continuous</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">incrementation until we need to use more than 64 bits so even if</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Elixir did not use arbitrary precision, we would virtually never</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">overflow).</span>

        <span class="org-variable-name">time_idx</span> = reads

        <span class="org-comment-delimiter"># </span><span class="org-comment">The fake readers generate data. We still need the regular readers</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">because we need to know which readers need which parsers.</span>
        [fake_readers_luerl_table] = resource[<span class="org-string">"fake"</span>][<span class="org-string">"readers"</span>].([resource_opts, time_idx])
        <span class="org-variable-name">fake_readers</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(fake_readers_luerl_table)
        <span class="org-keyword">case</span> read_fakes(readers, resource, resource_opts, fake_readers, time_idx) <span class="org-keyword">do</span>
          {[], kvs} <span class="org-keyword">-&gt;</span>
            kvs

          {errors, <span class="org-comment">_kvs</span>} <span class="org-keyword">-&gt;</span>
            <span class="org-type">Logger</span>.warning(<span class="org-string">"got </span><span class="org-variable-name">#{Kernel.length(errors)}</span><span class="org-string"> errors reading fake readers"</span>)
            errors <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-keyword">fn</span> e <span class="org-keyword">-&gt;</span> <span class="org-type">Logger</span>.warning(e) <span class="org-keyword">end</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Still return those kvs that were successfully parsed as expected.</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Or should we not crash here?</span>
            <span class="org-keyword">raise</span> <span class="org-string">"failed validation"</span>
        <span class="org-keyword">end</span>
      <span class="org-keyword">else</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Optionally run the readers concurrently for cases where we do</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">want the concurrency (e.g., we're hitting N different IP targets over</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">the network). E.g., for kubernetes contexts, most likely we should run</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">them all in parallel because they are talking to different clusters</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">with different IPs.</span>
        <span class="org-comment-delimiter">#</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">We should by default read serially because it is "safer". E.g., for</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">git we definitely do not want to run everything in parallel because</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">each git command could block on a global lockfile located in the .git</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">folder of a repo.</span>
        <span class="org-keyword">if</span> resource_opts[<span class="org-string">"read_parallel"</span>] <span class="org-keyword">do</span>
          read_parallel(readers, resource)
        <span class="org-keyword">else</span>
          read_serial(readers, resource)
        <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>

    <span class="org-type">%MelbyDaemon.StandardResource</span>{<span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:STANDARD_RESOURCE_STATUS_LOADED</span>, <span class="org-elixir-atom">kvs:</span> kvs}
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">For fake readers, check that the parser's output matches the expected output</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">in the fake.</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">read_fakes</span>(readers, resource, resource_opts, fake_readers, time_idx) <span class="org-keyword">do</span>
    <span class="org-type">Enum</span>.reduce(readers, {[], %{}}, <span class="org-keyword">fn</span> reader_table, {errors, kvs} <span class="org-keyword">-&gt;</span>
      <span class="org-variable-name">reader</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(reader_table)
      <span class="org-variable-name">fake_reader_table</span> = fake_readers[reader[<span class="org-string">"parser"</span>]]
      <span class="org-variable-name">fake_reader</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(fake_reader_table)
      <span class="org-variable-name">parser_func</span> = resource[<span class="org-string">"parser"</span>][reader[<span class="org-string">"parser"</span>]]
      <span class="org-variable-name">src</span> = fake_reader[<span class="org-string">"input"</span>]
      <span class="org-variable-name">kvs_subset</span> = parser_func.([src]) <span class="org-keyword">|&gt;</span> <span class="org-type">Kernel</span>.hd() <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()

      <span class="org-comment-delimiter"># </span><span class="org-comment">If the output does not match what we actually parsed, raise an error.</span>
      <span class="org-variable-name">expected</span> = fake_reader[<span class="org-string">"output"</span>] <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()

      <span class="org-variable-name">errors</span> = <span class="org-keyword">if</span> kvs_subset != expected <span class="org-keyword">do</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Maybe use a map diffing library, like</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">https://hexdocs.pm/map_diff/MapDiff.html to get a shorter "diff" of</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">any key/value differences.</span>
        [<span class="org-string">"resource type </span><span class="org-variable-name">#{resource["type"]}</span><span class="org-string">: "</span> &lt;&gt;
          <span class="org-string">"resource_opts </span><span class="org-variable-name">#{inspect(resource_opts)}</span><span class="org-string">: "</span> &lt;&gt;
          <span class="org-string">"time_idx </span><span class="org-variable-name">#{time_idx}</span><span class="org-string">: "</span> &lt;&gt;
          <span class="org-string">"expected </span><span class="org-variable-name">#{inspect(expected)}</span><span class="org-string">, got </span><span class="org-variable-name">#{inspect(kvs_subset)}</span><span class="org-string">"</span> | errors]
      <span class="org-keyword">else</span>
        errors
      <span class="org-keyword">end</span>

      <span class="org-comment-delimiter"># </span><span class="org-comment">Merge the data we've collected into acc.</span>
      {errors, <span class="org-type">Map</span>.merge(kvs, kvs_subset)}
    <span class="org-keyword">end</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">read_single</span>(reader_table, resource) <span class="org-keyword">do</span>
    <span class="org-variable-name">reader</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(reader_table)
    <span class="org-variable-name">invocation</span> = <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list(reader[<span class="org-string">"invocation"</span>])
    <span class="org-variable-name">cmd_head</span> = <span class="org-type">Kernel</span>.hd(invocation)
    <span class="org-variable-name">cmd_args</span> = <span class="org-type">Enum</span>.drop(invocation, <span class="org-elixir-number">1</span>)
    <span class="org-variable-name">cd</span> = reader[<span class="org-string">"cd"</span>]

    <span class="org-variable-name">cmd_opts_cd</span> =
      <span class="org-keyword">if</span> cd != <span class="org-elixir-atom">nil</span> <span class="org-keyword">do</span>
        [<span class="org-elixir-atom">cd:</span> cd]
      <span class="org-keyword">else</span>
        []
      <span class="org-keyword">end</span>

    <span class="org-variable-name">cmd_opts_env</span> =
      <span class="org-keyword">if</span> reader[<span class="org-string">"env"</span>] != <span class="org-elixir-atom">nil</span> <span class="org-keyword">do</span>
        <span class="org-variable-name">env</span> =
          <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(reader[<span class="org-string">"env"</span>])
          <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-keyword">fn</span> {k, v} <span class="org-keyword">-&gt;</span> {k, v} <span class="org-keyword">end</span>)

        [<span class="org-elixir-atom">env:</span> env]
      <span class="org-keyword">else</span>
        []
      <span class="org-keyword">end</span>

    <span class="org-variable-name">cmd_opts</span> = cmd_opts_cd ++ cmd_opts_env

    <span class="org-variable-name">parser_func_name</span> = reader[<span class="org-string">"parser"</span>]
    <span class="org-variable-name">parser_func</span> = resource[<span class="org-string">"parser"</span>][parser_func_name]

    <span class="org-variable-name">src</span> =
      <span class="org-keyword">try</span> <span class="org-keyword">do</span>
        <span class="org-keyword">case</span> <span class="org-type">System</span>.cmd(cmd_head, cmd_args, cmd_opts) <span class="org-keyword">do</span>
          {stdout, <span class="org-elixir-number">0</span>} <span class="org-keyword">-&gt;</span>
            stdout

          {<span class="org-comment">_stdout</span>, error_code} <span class="org-keyword">-&gt;</span>
            <span class="org-type">Logger</span>.warning(<span class="org-string">"Command </span><span class="org-variable-name">#{inspect(invocation)}</span><span class="org-string"> failed with error code </span><span class="org-variable-name">#{error_code}</span><span class="org-string">"</span>)

            <span class="org-comment-delimiter"># </span><span class="org-comment">Return empty string. Parsers should know how to deal with the</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">empty string (and accept that no output means that we should</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">return a default value).</span>
            <span class="org-string">""</span>
        <span class="org-keyword">end</span>
      <span class="org-keyword">rescue</span>
        e <span class="org-keyword">-&gt;</span>
          <span class="org-type">Logger</span>.warning(<span class="org-string">"Command </span><span class="org-variable-name">#{inspect(invocation)}</span><span class="org-string"> failed: </span><span class="org-variable-name">#{Exception.message(e)}</span><span class="org-string">"</span>)
          <span class="org-string">""</span>
      <span class="org-keyword">end</span>

    <span class="org-type">Logger</span>.debug(<span class="org-string">"Running parser_func </span><span class="org-variable-name">#{inspect(parser_func_name)}</span><span class="org-string">"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Now parse the output with the custom function to generate some keys and</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">values (a map). For simplicity both the keys and values here should not be</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">a collection type (map, array, etc) and instead be a primitive like a</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">string or number.</span>
    parser_func.([src]) <span class="org-keyword">|&gt;</span> <span class="org-type">Kernel</span>.hd() <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">read_serial</span>(readers, resource) <span class="org-keyword">do</span>
    <span class="org-type">Enum</span>.reduce(readers, %{}, <span class="org-keyword">fn</span> reader_table, acc <span class="org-keyword">-&gt;</span>
      <span class="org-variable-name">kvs_subset</span> = read_single(reader_table, resource)
      <span class="org-comment-delimiter"># </span><span class="org-comment">Merge the data we've collected into acc.</span>
      <span class="org-type">Map</span>.merge(acc, kvs_subset)
    <span class="org-keyword">end</span>)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">async tasks can crash the caller (and vice versa)</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">https://hexdocs.pm/elixir/1.14.2/Task.html#module-async-and-await. Also,</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">note that this function may take minutes, or even hours, to return. But it's</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">OK because we're not blocking anyone else.</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">read_parallel</span>(readers, resource) <span class="org-keyword">do</span>
    <span class="org-variable-name">tasks</span> =
      <span class="org-type">Enum</span>.reduce(readers, [], <span class="org-keyword">fn</span> reader_table, acc <span class="org-keyword">-&gt;</span>
        <span class="org-variable-name">task</span> = <span class="org-type">Task</span>.async(<span class="org-keyword">fn</span> <span class="org-keyword">-&gt;</span> read_single(reader_table, resource) <span class="org-keyword">end</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Collect this task.</span>
        [task | acc]
      <span class="org-keyword">end</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Each task returns a map. We need to merge all of these maps into each</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">other.</span>
    <span class="org-variable-name">maps</span> = <span class="org-type">Task</span>.await_many(tasks, <span class="org-elixir-atom">:infinity</span>)
    <span class="org-type">Enum</span>.reduce(maps, <span class="org-type">&amp;Map</span>.merge/<span class="org-elixir-number">2</span>)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: put this inside the callbacks section for handle_call.</span>
  <span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
  <span class="org-keyword">def</span> <span class="org-function-name">handle_call</span>(
        <span class="org-elixir-atom">:read</span>,
        <span class="org-comment">_from</span>,
        %{<span class="org-elixir-atom">state_hist:</span> state_hist, <span class="org-elixir-atom">ttl:</span> ttl, <span class="org-elixir-atom">ttl_max:</span> ttl_max} = state
      ) <span class="org-keyword">do</span>
    <span class="org-variable-name">response</span> =
      <span class="org-keyword">case</span> state_hist <span class="org-keyword">do</span>
        [] <span class="org-keyword">-&gt;</span> <span class="org-type">%MelbyDaemon.StandardResource</span>{<span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:STANDARD_RESOURCE_STATUS_LOADING</span>}
        [current | <span class="org-constant">_</span>] <span class="org-keyword">-&gt;</span> current
      <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">If ttl is &lt; 1, then this means that either the ttl naturally expired (ttl</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">== 0) or that we set this ttl manually to -1 because the fs watcher died.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">In either case, do not change the ttl.</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Otherwise, reset the ttl because a client actually needed this</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">information.</span>
    <span class="org-variable-name">ttl_new</span> =
      <span class="org-keyword">if</span> ttl &lt; <span class="org-elixir-number">1</span> <span class="org-keyword">do</span>
        ttl
      <span class="org-keyword">else</span>
        ttl_max
      <span class="org-keyword">end</span>

    {
      <span class="org-elixir-atom">:reply</span>,
      <span class="org-comment-delimiter"># </span><span class="org-comment">Response to the caller.</span>
      response,
      <span class="org-comment-delimiter"># </span><span class="org-comment">New state of this GenServer.</span>
      %{state | <span class="org-elixir-atom">ttl:</span> ttl_new}
    }
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">GenServer callbacks.</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_handle_call-1">melbyd_srs_handle_call</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_handle_cast">melbyd_srs_handle_cast</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_handle_info-1">melbyd_srs_handle_info</a></span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Tick</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_tick">melbyd_srs_tick</a></span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Mark staleness</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_staleness">melbyd_srs_staleness</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_staleness_detector_setup-1">melbyd_srs_staleness_detector_setup</a></span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Filesystem-based staleness</span>
  __NREF__melbyd_srs_staleness_filesystem_boilerplate
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_staleness_filesystem_helpers">melbyd_srs_staleness_filesystem_helpers</a></span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Client interface</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_client_interface">melbyd_srs_client_interface</a></span>
<span class="org-keyword">end</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Supervisor.</span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_supervisor">melbyd_srs_supervisor</a></span>
</pre></div>
</div>
</div>

<div id="outline-container-h-Tick" class="outline-5">
<h5 id="h-Tick"><span class="section-number-5">6.5.1.3.</span> Tick</h5>
<div class="outline-text-5" id="text-h-Tick">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_tick</a></span>(1/1) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_tick">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_tick"><span class="org-comment-delimiter"># </span><span class="org-comment">Send a "tick" message to our GenServer in 1 second. See</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">https://stackoverflow.com/a/32097971/437583.</span>
<span class="org-keyword">defp</span> <span class="org-function-name">tick</span>(ttl, notify_on_exit_pid) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> ttl <span class="org-keyword">do</span>
    n <span class="org-keyword">when</span> n <span class="org-keyword">in</span> -<span class="org-elixir-number">1</span>..<span class="org-elixir-number">0</span> <span class="org-keyword">-&gt;</span>
      <span class="org-keyword">if</span> n == <span class="org-elixir-number">0</span> <span class="org-keyword">do</span>
        <span class="org-type">Logger</span>.info(<span class="org-string">"TTL expired; shutting down this GenServer due to client neglect"</span>)
      <span class="org-keyword">else</span>
        <span class="org-type">Logger</span>.info(
          <span class="org-string">"TTL expired manually; shutting down this GenServer"</span>
        )
      <span class="org-keyword">end</span>

      <span class="org-comment-delimiter"># </span><span class="org-comment">Used for testing, where we assert that we can receive this</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">":shutting_down" message after the ttl expires.</span>
      <span class="org-keyword">if</span> notify_on_exit_pid <span class="org-keyword">do</span>
        <span class="org-keyword">send</span>(notify_on_exit_pid, <span class="org-elixir-atom">:shutting_down</span>)
      <span class="org-keyword">end</span>

      <span class="org-type">Process</span>.exit(self(), <span class="org-elixir-atom">:ttl_deadline_exceeded</span>)
    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Send after 1 second. We could alternatively use :timer.send_interval</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">(Erlang function) in init/1 and avoid calling this function manually in</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">handle_info/2, but then that would send the tick at a constant rate,</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">regardless of how long it takes to process the tick. This runs the risk of</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">growing the message queue at a faster rate than it can be processed</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">(unbounded growth).</span>
      <span class="org-type">Process</span>.send_after(self(), <span class="org-elixir-atom">:tick</span>, <span class="org-elixir-attribute">@tick_interval</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_info</a></span>(1/7) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_info-1">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_info-1"><span class="org-comment-delimiter"># </span><span class="org-comment">Process tick. The tick must handle the true and false cases for the "stale"</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">key of the state. First we handle the case where stale is true (we must</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">re-read data).</span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_srs_tick_do_work">melbyd_srs_tick_do_work</a></span>

<span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      <span class="org-elixir-atom">:tick</span>,
      %{<span class="org-elixir-atom">ttl:</span> ttl, <span class="org-elixir-atom">notify_on_exit_pid:</span> notify_on_exit_pid} = state
    ) <span class="org-keyword">do</span>
  <span class="org-variable-name">new_state</span> = maybe_refresh_state_and_notify(state)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Continue ticking for the future. But optionally die if ttl is too low.</span>
  tick(ttl, notify_on_exit_pid)

  {<span class="org-elixir-atom">:noreply</span>, new_state}
<span class="org-keyword">end</span>
</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_srs_handle_info-1">melbyd_srs_tick_do_work</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_tick_do_work">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_tick_do_work"><span class="org-keyword">defp</span> <span class="org-function-name">maybe_refresh_state_and_notify</span>(
       %{
         <span class="org-elixir-atom">id:</span> id,
         <span class="org-elixir-atom">resource:</span> resource,
         <span class="org-elixir-atom">resource_opts:</span> resource_opts,
         <span class="org-elixir-atom">state_hist:</span> state_hist,
         <span class="org-elixir-atom">stale:</span> stale,
         <span class="org-elixir-atom">ttl:</span> ttl,
         <span class="org-elixir-atom">reads:</span> reads
       } = state
     ) <span class="org-keyword">do</span>
  <span class="org-keyword">if</span> stale <span class="org-keyword">do</span>
    <span class="org-type">Logger</span>.info(<span class="org-string">"Re-reading state for </span><span class="org-variable-name">#{inspect(id)}</span><span class="org-string">"</span>)
    <span class="org-variable-name">new</span> = run_readers(resource, resource_opts, reads)
    <span class="org-type">Logger</span>.info(<span class="org-string">"Finished re-reading state for </span><span class="org-variable-name">#{inspect(id)}</span><span class="org-string">"</span>)

    <span class="org-variable-name">new_state_hist</span> =
      <span class="org-keyword">case</span> state_hist <span class="org-keyword">do</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">This list is always populated with at least 1 element because we</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">populate it as a singleton list in init/1.</span>
        [old | <span class="org-constant">_</span>] <span class="org-keyword">-&gt;</span>
          <span class="org-keyword">if</span> old == new <span class="org-keyword">do</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">NOP because there is no change between the currnt reading and the</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">last reading we did.</span>
            <span class="org-type">Logger</span>.info(<span class="org-string">"skipping addition of new state; NOP"</span>)
            state_hist
          <span class="org-keyword">else</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Generate any new messages for any diff between the old and new</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">states.</span>
            <span class="org-type">Logger</span>.info(<span class="org-string">"checking for any new messages to broadcast"</span>)
            {<span class="org-constant">_</span>, resource_id} = id
            resource[<span class="org-string">"notify"</span>].([resource_id, old, new])

            <span class="org-comment-delimiter"># </span><span class="org-comment">Drop oldest state from state_hist if adding (prepending) to it</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">would exceed our history size.</span>
            [new | state_hist] <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.take(resource[<span class="org-string">"history_size"</span>])
          <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>

    %{state | <span class="org-elixir-atom">state_hist:</span> new_state_hist,
              <span class="org-elixir-atom">stale:</span> <span class="org-elixir-atom">false</span>,
              <span class="org-elixir-atom">ttl:</span> ttl - <span class="org-elixir-number">1</span>,
              <span class="org-elixir-atom">reads:</span> reads + <span class="org-elixir-number">1</span>}
  <span class="org-keyword">else</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Now handle the case where staleness is false (no need to read new data).</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">In this case the only thing that happens is the ttl age getting older (1</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">unit closer to 0).</span>

    %{state | <span class="org-elixir-atom">ttl:</span> ttl - <span class="org-elixir-number">1</span>}
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_call</a></span>(1/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_call-1">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_call-1"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_call</span>(
      <span class="org-elixir-atom">:tick</span>,
      <span class="org-comment">_from</span>,
      state
    ) <span class="org-keyword">do</span>
  <span class="org-variable-name">new_state</span> = maybe_refresh_state_and_notify(state)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Unlike for the handle_info version, we do not tick again on our own, because</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">this is meant to be used only as a way for fake resources to get updated</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">manually in a synchronized fashion. If we were to tick ourselves now, then</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">we would essentially start updating our state asynchronously, missing the</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">point.</span>
  {<span class="org-elixir-atom">:reply</span>, <span class="org-elixir-atom">:ok</span>, new_state}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Marking-staleness" class="outline-5">
<h5 id="h-Marking-staleness"><span class="section-number-5">6.5.1.4.</span> Marking staleness</h5>
<div class="outline-text-5" id="text-h-Marking-staleness">
<p>
If we mark an SRS GenServer as stale, this forces the re-reading of state such
that it is loaded as the newest element in the <code>state_hist</code> queue.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_staleness</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_staleness">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_staleness"><span class="org-keyword">defp</span> <span class="org-function-name">mark_stale</span>(id) <span class="org-keyword">do</span>
  <span class="org-type">GenServer</span>.cast(via_tuple(id), <span class="org-elixir-atom">:mark_stale</span>)
<span class="org-keyword">end</span>
</pre></div></div><p>
For production, we don't care about being synchronous. We also can't use
<code>self()</code> because we might have to mark other SRS GenServers as stale (e.g., for
filesystem-based staleness flaggers that walk up the filesystem tree and mark
everyone there as stale).
</p>

<p>
In our GenServer callback <code>handle_cast(:mark_stale, ...)</code> below, we also set
<code>status</code> of the current (head) element in <code>state_hist</code> to
<code>:STANDARD_RESOURCE_STATUS_LOADING</code>. This is so that any client reads of our
state between now and the next tick() will know that we've recognized the need
to refresh the state on the next tick().
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_cast</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_cast">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_cast"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_cast</span>(<span class="org-elixir-atom">:mark_stale</span>, %{<span class="org-elixir-atom">stale:</span> <span class="org-constant">_</span>, <span class="org-elixir-atom">state_hist:</span> [current | rest]} = state) <span class="org-keyword">do</span>
  {<span class="org-elixir-atom">:noreply</span>,
   %{
     state
     | <span class="org-elixir-atom">stale:</span> <span class="org-elixir-atom">true</span>,
       <span class="org-elixir-atom">state_hist:</span> [%{current | <span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:STANDARD_RESOURCE_STATUS_LOADING</span>} | rest]
   }}
<span class="org-keyword">end</span>
</pre></div></div><p>
For fake resources, we want to make this function block with a <code>call</code> so that we
can be more precise with how its state is updated with a followup coordinated
<code>:tick</code> message (also a <code>call</code>).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_call</a></span>(2/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_call-2">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_call-2"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_call</span>(<span class="org-elixir-atom">:mark_stale</span>, <span class="org-comment">_from</span>, %{<span class="org-elixir-atom">stale:</span> <span class="org-constant">_</span>, <span class="org-elixir-atom">state_hist:</span> [current | rest]} = state) <span class="org-keyword">do</span>
  {<span class="org-elixir-atom">:reply</span>,
   <span class="org-elixir-atom">:ok</span>,
   %{
     state
     | <span class="org-elixir-atom">stale:</span> <span class="org-elixir-atom">true</span>,
       <span class="org-elixir-atom">state_hist:</span> [%{current | <span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:STANDARD_RESOURCE_STATUS_LOADING</span>} | rest]
   }}
<span class="org-keyword">end</span>
</pre></div></div>
</div>

<div id="outline-container-h-Filesystem-based-staleness" class="outline-6">
<h6 id="h-Filesystem-based-staleness"><span class="section-number-6">6.5.1.4.1.</span> Filesystem-based staleness</h6>
<div class="outline-text-6" id="text-h-Filesystem-based-staleness">
<p>
We want to be able to automatically mark for staleness based on filesystem
events. This is the reason for this section. Note that this notion of
filesystem-based staleness is completely optional &#x2014; if an SRS GenServer is
configured so that it doesn't "register" for filesystem-based staleness, none of
the code here will get used (because no one will send the <code>{:file_event, ...}</code>
tuple to us).
</p>

<p>
Regarding implementation, the key here is to forward filesystem events (detected
as <code>{path, events}</code> tuples) to the Lua function that the user defines. It's up
to that function to return a True or False boolean. If it returns True, then we
mark the current SRS GenServer as <b>stale</b>, as well as all parent SRS GenServers
as stale (if any), by calling <code>mark_all_stale_from/1</code>.
</p>

<p>
The original reason why we mark all parents as stale is for the case where we
have Git submodules and we delete/edit some files in the submodule. In this
scenario it could be that the superproject Git repo needs to update its
information, and so we need to mark it as stale as well. And because submodules
can technically be nested, we need to go all the way up to the filesystem root.
</p>

<p>
Conceivably, other SRS GenServers that rely on filesystem staleness probably
want the same <code>mark_all_stale_from/1</code> behavior.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_info</a></span>(2/7) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_info-2">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_info-2"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      {<span class="org-elixir-atom">:file_event</span>, <span class="org-comment">_watcher_pid</span>, {path, events}},
      %{
        <span class="org-elixir-atom">id:</span> id,
        <span class="org-elixir-atom">fs_event_handler:</span> fs_event_handler,
        <span class="org-elixir-atom">stale:</span> <span class="org-elixir-atom">false</span>
      } = state
    ) <span class="org-keyword">do</span>
  {resource_type, <span class="org-comment">_resource_id</span>} = id
  <span class="org-comment-delimiter"># </span><span class="org-comment">Now translate our path and events arguments to send into the Lua function,</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">and call it.</span>
  [should_mark_stale] = fs_event_handler.([path, events])

  <span class="org-keyword">if</span> should_mark_stale <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Invalidate the cache entry for all current and parent SRS GenServers</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">between / and path. This includes us (our particular SRS GenServer</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">instance) as well.</span>
    mark_all_paths_stale_from({resource_type, path})
  <span class="org-keyword">else</span>
    <span class="org-type">Logger</span>.debug(
      <span class="org-string">"ignoring Git index path </span><span class="org-variable-name">#{path}</span><span class="org-string">; events:</span><span class="org-variable-name">#{inspect(events)}</span><span class="org-string">"</span>
    )
  <span class="org-keyword">end</span>

  {<span class="org-elixir-atom">:noreply</span>, state}
<span class="org-keyword">end</span>
</pre></div></div>
</div>

<ol class="org-ol">
<li><a id="h-Boilerplate--FIXME--rename-this-heading-and-avoid--boilerplate--because-it-means-nothing"></a>Boilerplate (FIXME: rename this heading and avoid "boilerplate" because it means nothing)<br>
<div class="outline-text-7" id="text-h-Boilerplate--FIXME--rename-this-heading-and-avoid--boilerplate--because-it-means-nothing">
<p>
This section captures universally-applicable filesystem events which are
independent of what the user specifies in their Lua configuration.
</p>

<p>
First, if the filesystem watcher dies, we set the time-to-live (TTL) value for
our GenServer to -1 so that it will exit itself on the next tick. Setting this
to -1 is important because it signals to the other <code>handle_call</code> callback which
accepts the <code>:read</code> atom that it should not reset the TTL back up to <code>ttl_max</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_info</a></span>(3/7) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_info-3">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_info-3"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      {<span class="org-elixir-atom">:file_event</span>, watcher_pid, <span class="org-elixir-atom">:stop</span>},
      %{
        <span class="org-elixir-atom">id:</span> id
      } = state
    ) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.info(<span class="org-string">"SRS id </span><span class="org-variable-name">#{inspect(id)}</span><span class="org-string">, fs watcher </span><span class="org-variable-name">#{inspect(watcher_pid)}</span><span class="org-string">: FileSystem monitor stopped"</span>)

  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Use {:stop, reason, new_state} here to stop the process instead of</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">(ab)using ttl. See pages 174-175 of Elixir In Action.</span>
  {<span class="org-elixir-atom">:noreply</span>, %{state | <span class="org-elixir-atom">ttl:</span> -<span class="org-elixir-number">1</span>}}
<span class="org-keyword">end</span>
</pre></div></div><p>
The second is to ignore all filesystem events if the GenServer state has already
been marked as <b>stale</b>. This is because the only thing that a filesystem event
can do is to flag for staleness; if we're already stale, then any additional
filesystem event is redundant as far as staleness is concerned. On the next
tick, when we see that we're in a stale state, we will regenerate the state and
mark ourselves as being fresh (<code>stale: false</code>) again.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_info</a></span>(4/7) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_info-4">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_info-4"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      {<span class="org-elixir-atom">:file_event</span>, <span class="org-comment">_watcher_pid</span>, {<span class="org-comment">_path</span>, <span class="org-comment">_events</span>}},
      %{
        <span class="org-elixir-atom">stale:</span> <span class="org-elixir-atom">true</span>
      } = state
    ) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.debug(<span class="org-string">"Ignoring filesystem event because state is already stale"</span>)
  {<span class="org-elixir-atom">:noreply</span>, state}
<span class="org-keyword">end</span>
</pre></div></div>
</div>

<ol class="org-ol">
<li><a id="h-Setup"></a>Setup<br>
<div class="outline-text-8" id="text-h-Setup">
<p>
Setting up a filesystem-based staleness detector requires calling out to the
<code>FileSystem</code> library, so that we can subscribe to filesystem events in the first
place. We do this if we see that the resource has a configuration specified for
it.
</p>

<p>
When the user specifies a directory to watch, we watch it and all of it
subdirectories for changes.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_staleness_detector_setup</a></span>(1/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_staleness_detector_setup-1">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_staleness_detector_setup-1"><span class="org-keyword">defp</span> <span class="org-function-name">setup_staleness_flagger</span>(
       %{<span class="org-string">"type"</span> <span class="org-keyword">=&gt;</span> <span class="org-string">"filesystem"</span>,
         <span class="org-string">"watch_paths"</span> <span class="org-keyword">=&gt;</span> watch_paths_lua_array,
         <span class="org-string">"fs_event_handler"</span> <span class="org-keyword">=&gt;</span> fs_event_handler} =
         <span class="org-comment">_staleness_flagger</span>,
       initial_state
     ) <span class="org-keyword">do</span>

  <span class="org-variable-name">watch_paths</span> = <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list(watch_paths_lua_array)
  <span class="org-type">Logger</span>.info(<span class="org-string">"Watching filesystem directory </span><span class="org-variable-name">#{inspect(watch_paths)}</span><span class="org-string">"</span>)
  {<span class="org-elixir-atom">:ok</span>, watcher_pid} = <span class="org-type">FileSystem</span>.start_link(<span class="org-elixir-atom">dirs:</span> watch_paths)
  <span class="org-type">FileSystem</span>.subscribe(watcher_pid)

  <span class="org-comment-delimiter"># </span><span class="org-comment">We need to save this info about fs, because we need to run the fs event</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">handler (we can do the full lookup using get_resources but this is slightly</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">cheaper).</span>
  <span class="org-type">Map</span>.put(initial_state, <span class="org-elixir-atom">:fs_event_handler</span>, fs_event_handler)
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>
</ol>
</li>

<li><a id="h-Helpers"></a>Helpers<br>
<div class="outline-text-7" id="text-h-Helpers">
<p>
Here are some helper functions. The main workhorse here is
<code>mark_all_stale_from/1</code>, which marks all SRS GenServers from the given path to
the root directory (<code>/</code>) as stale.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_staleness_filesystem_helpers</a></span>(1/1) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_staleness_filesystem_helpers">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_staleness_filesystem_helpers"><span class="org-comment-delimiter"># </span><span class="org-comment">Mark the given path as stale, as well as all other SRS GenServers whose id's</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">are of the form "{resource_type, path}" where "path" is a parent path.</span>
<span class="org-keyword">defp</span> <span class="org-function-name">mark_all_paths_stale_from</span>({resource_type, path}) <span class="org-keyword">do</span>
  get_all_parents(path)
  <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-keyword">fn</span> p <span class="org-keyword">-&gt;</span> mark_stale({resource_type, p}) <span class="org-keyword">end</span>)
<span class="org-keyword">end</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Given "/a/b/c", return ["/", "/a", "/a/b", "/a/b/c"]</span>
<span class="org-keyword">defp</span> <span class="org-function-name">get_all_parents</span>(path) <span class="org-keyword">do</span>
  <span class="org-variable-name">parts</span> = <span class="org-type">Path</span>.split(path)
  <span class="org-variable-name">parts_len</span> = length(parts)

  <span class="org-elixir-number">1</span>..parts_len
  <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(&amp;(<span class="org-type">Enum</span>.take(parts, &amp;1) <span class="org-keyword">|&gt;</span> <span class="org-type">Path</span>.join()))
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>
</ol>
</div>

<div id="outline-container-h-Duration-based-staleness--polling" class="outline-6">
<h6 id="h-Duration-based-staleness--polling"><span class="section-number-6">6.5.1.4.2.</span> Duration-based staleness (polling)</h6>
<div class="outline-text-6" id="text-h-Duration-based-staleness--polling">
<p>
Some resources should be re-read every few seconds or so. One example is
whenever we want to scrape information from another service, which may or may
not have changed state. For these things, we can use a duration-based staleness
flagger. It is very simple &#x2014; whenever some duration of time has passed, we
mark the resource as stale, and repeat again after the same duration, forever.
This is also known as polling. One common, basic example in the Kubernetes world
is when users invoke <code>watch kubectl get ...</code> to poll Kubernetes state every 2
seconds.
</p>

<p>
Compared to filesystem-based staleness, duration-based staleness does not
require an event handling function (to detect whether to accept or reject the
event) to be implemented in Lua. This is because an elapsed duration of time is
a universal truth (for all intents and purposes) and does not require additional
checking.
</p>

<p>
See <a href="https://elixirforum.com/t/multiple-intervals-for-genserver/6026">https://elixirforum.com/t/multiple-intervals-for-genserver/6026</a> for a
discussion about timers and durations. There they mention
<a href="https://hex.pm/packages/quantum">https://hex.pm/packages/quantum</a> which is basically cron but for Elixir.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_info</a></span>(5/7) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_info-5">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_info-5"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      <span class="org-elixir-atom">:duration_event</span>,
      %{
        <span class="org-elixir-atom">id:</span> id,
        <span class="org-elixir-atom">stale:</span> <span class="org-elixir-atom">false</span>
      } = state
    ) <span class="org-keyword">do</span>
  {resource_type, <span class="org-comment">_resource_id</span>} = id
  mark_stale({resource_type, id})

  {<span class="org-elixir-atom">:noreply</span>, state}
<span class="org-keyword">end</span>
</pre></div></div><p>
Similar to filesystem-based staleness, we ignore the <code>:duration_event</code> if our
state has already been marked stale (because it is redundant).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_info</a></span>(6/7) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_info-6">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_info-6"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      <span class="org-elixir-atom">:duration_event</span>,
      %{
        <span class="org-elixir-atom">stale:</span> <span class="org-elixir-atom">true</span>
      } = state
    ) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.debug(<span class="org-string">"Ignoring duration event because state is already stale"</span>)
  {<span class="org-elixir-atom">:noreply</span>, state}
<span class="org-keyword">end</span>
</pre></div></div><p>
Finally, we need to set up a timer to generate these <code>:duration_event</code> atoms to
send them to our SRS GenServer. Thankfully, Erlang ships with a <code>:timer</code> module
which has everything we need. The duration must be set using ISO 8601 notation,
and is only precise to 1 whole second (sub-second durations are ignored).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_staleness_detector_setup</a></span>(2/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_staleness_detector_setup-2">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_staleness_detector_setup-2"><span class="org-keyword">defp</span> <span class="org-function-name">setup_staleness_flagger</span>(
       %{<span class="org-string">"type"</span> <span class="org-keyword">=&gt;</span> <span class="org-string">"duration"</span>, <span class="org-string">"duration"</span> <span class="org-keyword">=&gt;</span> duration} = <span class="org-comment">_staleness_flagger</span>,
       initial_state
     ) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.info(<span class="org-string">"Setting up duration-based staleness flagger, with duration </span><span class="org-variable-name">#{duration}</span><span class="org-string">"</span>)
  <span class="org-elixir-atom">:timer</span>.send_interval(<span class="org-elixir-atom">:timer</span>.seconds(duration_to_seconds(duration)), self(), <span class="org-elixir-atom">:duration_event</span>)

  <span class="org-type">Map</span>.put(initial_state, <span class="org-elixir-atom">:duration</span>, duration)
<span class="org-keyword">end</span>

<span class="org-keyword">defp</span> <span class="org-function-name">duration_to_seconds</span>(s) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> <span class="org-type">Elixir.Timex.Parse.Duration.Parsers.ISO8601Parser</span>.parse(s) <span class="org-keyword">do</span>
    {<span class="org-elixir-atom">:ok</span>, d} <span class="org-keyword">-&gt;</span>
      <span class="org-variable-name">seconds</span> = <span class="org-type">Timex.Duration</span>.to_seconds(d, <span class="org-elixir-atom">truncate:</span> <span class="org-elixir-atom">true</span>)

      <span class="org-keyword">if</span> seconds == <span class="org-elixir-number">0</span> <span class="org-keyword">do</span>
        <span class="org-type">Logger</span>.warning(<span class="org-string">"duration </span><span class="org-variable-name">#{s}</span><span class="org-string"> was parsed as 0 seconds; using 2 seconds as fallback"</span>)
        <span class="org-elixir-number">2</span>
      <span class="org-keyword">else</span>
        seconds
      <span class="org-keyword">end</span>

    {<span class="org-elixir-atom">:error</span>, err} <span class="org-keyword">-&gt;</span>
      <span class="org-type">Logger</span>.warning(<span class="org-string">"failed to parse duration </span><span class="org-variable-name">#{s}</span><span class="org-string">: </span><span class="org-variable-name">#{inspect(err)}</span><span class="org-string">; using 2 seconds as fallback"</span>)
      <span class="org-elixir-number">2</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Graceful-shutdown" class="outline-5">
<h5 id="h-Graceful-shutdown"><span class="section-number-5">6.5.1.5.</span> Graceful shutdown</h5>
<div class="outline-text-5" id="text-h-Graceful-shutdown">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_handle_info</a></span>(7/7) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_handle_info-7">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_handle_info-7"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      {<span class="org-elixir-atom">:EXIT</span>, from_pid, reason},
      %{
        <span class="org-elixir-atom">id:</span> id
      } = state
    ) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.debug(<span class="org-string">"SRS </span><span class="org-variable-name">#{inspect(id)}</span><span class="org-string">: Got exit reason </span><span class="org-variable-name">#{inspect(reason)}</span><span class="org-string"> from pid </span><span class="org-variable-name">#{inspect(from_pid)}</span><span class="org-string">"</span>)
  <span class="org-keyword">case</span> reason <span class="org-keyword">do</span>
    <span class="org-elixir-atom">:normal</span> <span class="org-keyword">-&gt;</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">This can happen if, e.g., a System.cmd/3 finishes running successfully.</span>
      {<span class="org-elixir-atom">:noreply</span>, state}
      <span class="org-comment-delimiter"># </span><span class="org-comment">This is when we are asked to shut down immediately (e.g., for a fake SRS</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">that is no longer needed).</span>
    <span class="org-elixir-atom">:release_fake_resource</span> <span class="org-keyword">-&gt;</span>
      {<span class="org-elixir-atom">:stop</span>, <span class="org-elixir-atom">:normal</span>, state}
    <span class="org-elixir-atom">:ttl_deadline_exceeded</span> <span class="org-keyword">-&gt;</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Invoke our terminate/2 callback by returning with the ":stop" atom.</span>
      {<span class="org-elixir-atom">:stop</span>, <span class="org-elixir-atom">:normal</span>, state}
    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
      {<span class="org-elixir-atom">:stop</span>, reason, state}
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">terminate</span>(
      reason,
      %{
        <span class="org-elixir-atom">id:</span> id
      } = <span class="org-comment">_state</span>
    ) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.info(<span class="org-string">"SRS </span><span class="org-variable-name">#{inspect(id)}</span><span class="org-string">: Got exit reason </span><span class="org-variable-name">#{inspect(reason)}</span><span class="org-string">; shutting down"</span>)
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Client-interface" class="outline-5">
<h5 id="h-Client-interface"><span class="section-number-5">6.5.1.6.</span> Client interface</h5>
<div class="outline-text-5" id="text-h-Client-interface">
<p>
The client interface is rather simple: there is just <code>read/2</code> which either
retrieves the current state from the SRS GenServer, or creates a new one if it
doesn't exist and returns an empty state. Note that <code>read/2</code> itself has no idea
how to actually generate the state from scratch &#x2014; instead it can only read
whatever is already in the GenServer's state (if any). The job of actually
generating the state from scratch, based on the Lua configuration, is left to
the <code>run_readers/2</code> private method.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_client_interface</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_client_interface">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_client_interface"><span class="org-keyword">def</span> <span class="org-function-name">read</span>(resource, resource_opts) <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">At this point we have all the information we need in order to instantiate a</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">new SRS GenServer. We need to start it up (if necessary) and get information</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">out of it. This optional startup can be handled by the DynamicSupervisor,</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">which can do a call into gproc (process registry) to determine if the</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">GenServer of the type and options exists.</span>

  <span class="org-variable-name">resource_id</span> =
    <span class="org-keyword">cond</span> <span class="org-keyword">do</span>
      resource_opts[<span class="org-string">"fake"</span>] <span class="org-keyword">-&gt;</span>
        resource[<span class="org-string">"fake"</span>][<span class="org-string">"resource_id_func"</span>].([resource_opts]) <span class="org-keyword">|&gt;</span> <span class="org-type">Kernel</span>.hd()

      resource[<span class="org-string">"resource_id_command"</span>] != <span class="org-elixir-atom">nil</span> <span class="org-keyword">-&gt;</span>
        run_resource_id_command(resource, resource_opts)

      resource[<span class="org-string">"resource_id_func"</span>] != <span class="org-elixir-atom">nil</span> <span class="org-keyword">-&gt;</span>
        resource[<span class="org-string">"resource_id_func"</span>].([resource_opts]) <span class="org-keyword">|&gt;</span> <span class="org-type">Kernel</span>.hd()

      <span class="org-elixir-atom">true</span> <span class="org-keyword">-&gt;</span>
        <span class="org-string">""</span>
    <span class="org-keyword">end</span>

  <span class="org-keyword">if</span> resource_id == <span class="org-string">""</span> <span class="org-keyword">do</span>
    <span class="org-type">Logger</span>.warning(
      <span class="org-string">"resource_id cannot be empty: failed to generate srs_id for resource "</span> &lt;&gt;
        <span class="org-string">"</span><span class="org-variable-name">#{inspect({resource, resource_opts}</span><span class="org-string">)} --- if this is a fake, then "</span> &lt;&gt;
        <span class="org-string">"it means that your resource_id_func could be returning an empty string"</span>
    )

    <span class="org-type">%MelbyDaemon.StandardResource</span>{<span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:STANDARD_RESOURCE_STATUS_NOT_APPLICABLE</span>}
  <span class="org-keyword">else</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Warn users about misbehaving resource_ids for non-fake resources.</span>
    <span class="org-keyword">if</span> <span class="org-type">String</span>.starts_with?(resource_id, <span class="org-string">"fake-&gt;"</span>) &amp;&amp; !resource_opts[<span class="org-string">"fake"</span>] <span class="org-keyword">do</span>
      <span class="org-type">Logger</span>.warning(
        <span class="org-string">"resource_id starts with 'fake-&gt;' but 'fake' key is not set in"</span>
          &lt;&gt; <span class="org-string">"resource_opts: </span><span class="org-variable-name">#{inspect({resource, resource_opts}</span><span class="org-string">)}"</span>
      )

      <span class="org-type">%MelbyDaemon.StandardResource</span>{<span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:STANDARD_RESOURCE_STATUS_NOT_APPLICABLE</span>}
    <span class="org-keyword">else</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Prepend "fake-&gt;" to the resource_id so that it is in a different</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">"namespace" and does not clash with real resource ids. It could be the</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">case that the real resource's id command or function would also output a</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">leading "fake-&gt;" string, but this is very unlikely.</span>
      <span class="org-variable-name">resource_id</span> =
        <span class="org-keyword">if</span> resource_opts[<span class="org-string">"fake"</span>] <span class="org-keyword">do</span>
          <span class="org-string">"fake-&gt;</span><span class="org-variable-name">#{resource_id}</span><span class="org-string">"</span>
        <span class="org-keyword">else</span>
          resource_id
        <span class="org-keyword">end</span>

      <span class="org-comment-delimiter"># </span><span class="org-comment">We need to encode the resource type as well into the id because it may</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">be the case that other resource types also end up generating the same</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">id, such as when both resource types depend on the same filesystem</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">path.</span>
      <span class="org-variable-name">srs_id</span> = {resource[<span class="org-string">"type"</span>], resource_id}

      <span class="org-keyword">case</span> <span class="org-elixir-atom">:gproc</span>.lookup_pids({<span class="org-elixir-atom">:n</span>, <span class="org-elixir-atom">:l</span>, {<span class="org-type">Melbyd.StandardResource</span>, srs_id}}) <span class="org-keyword">do</span>
        [pid] <span class="org-keyword">-&gt;</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">This StandardResource with the given id already exists.</span>
          <span class="org-type">Logger</span>.info(<span class="org-string">"Found existing pid for </span><span class="org-variable-name">#{inspect(srs_id)}</span><span class="org-string">: </span><span class="org-variable-name">#{inspect(pid)}</span><span class="org-string">"</span>)

          <span class="org-comment-delimiter"># </span><span class="org-comment">If it's a fake resource, we manually mark it stale first, then force</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">a read (with a tick).</span>
          <span class="org-keyword">if</span> resource_opts[<span class="org-string">"fake"</span>] <span class="org-keyword">do</span>
            <span class="org-type">GenServer</span>.call(pid, <span class="org-elixir-atom">:mark_stale</span>)
            <span class="org-type">GenServer</span>.call(pid, <span class="org-elixir-atom">:tick</span>)
          <span class="org-keyword">end</span>

          <span class="org-type">GenServer</span>.call(pid, <span class="org-elixir-atom">:read</span>)

        <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">Start the StandardResource with the given id. This is idempotent and</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">will not spawn a new GenServer if one already exists with the given</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">id.</span>
          <span class="org-comment-delimiter">#</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">Because we wrap the start_watcher() call inside a Task, it also runs</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">asynchronously (so that we don't block until the startup is finished</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">before returning the "LOADING" status below).</span>
          <span class="org-type">Task.Supervisor</span>.start_child(<span class="org-type">Melbyd.TaskSupervisor</span>, <span class="org-keyword">fn</span> <span class="org-keyword">-&gt;</span>
            <span class="org-type">Melbyd.StandardResourceSupervisor</span>.start_srs(srs_id, resource, resource_opts)
          <span class="org-keyword">end</span>)

          <span class="org-comment-delimiter"># </span><span class="org-comment">We started the watcher just above asynchronously. For now return a</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">blank struct with the "LOADING" status so that the caller can know</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">that the given repo is indeed a Git repo but that we just don't have</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">any data yet.</span>
          <span class="org-type">%MelbyDaemon.StandardResource</span>{<span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:STANDARD_RESOURCE_STATUS_LOADING</span>}
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Return a resource_id by running the given command. Also return the appropriate</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">StandardResourceStatus atom.</span>
<span class="org-keyword">def</span> <span class="org-function-name">run_resource_id_command</span>(resource, resource_opts) <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">When we call a luerl-decoded function, we have to pass in arguments as a</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">list, as in [resource_opts] below.</span>
  [resource_id_command_luerl_table] = resource[<span class="org-string">"resource_id_command"</span>].([resource_opts])
  <span class="org-variable-name">resource_id_command</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(resource_id_command_luerl_table)
  <span class="org-variable-name">invocation</span> = resource_id_command[<span class="org-string">"invocation"</span>] <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list()
  <span class="org-variable-name">cmd_head</span> = <span class="org-type">Kernel</span>.hd(invocation)
  <span class="org-variable-name">cmd_args</span> = <span class="org-type">Enum</span>.drop(invocation, <span class="org-elixir-number">1</span>)
  <span class="org-variable-name">cd</span> = resource_id_command[<span class="org-string">"cd"</span>]

  <span class="org-variable-name">cmd_opts</span> =
    <span class="org-keyword">if</span> cd != <span class="org-elixir-atom">nil</span> <span class="org-keyword">do</span>
      [<span class="org-elixir-atom">cd:</span> cd]
    <span class="org-keyword">else</span>
      []
    <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">If the resource id command requirse some additional processing (the command</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">itself does not return a unique, simple string), we can construct our final</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">format with the help of the parser.</span>
  <span class="org-variable-name">parser_func_name</span> = resource_id_command[<span class="org-string">"parser"</span>]
  <span class="org-variable-name">parser_func</span> = resource[<span class="org-string">"parser"</span>][parser_func_name] || (<span class="org-type">&amp;Function</span>.identity/<span class="org-elixir-number">1</span>)

  <span class="org-keyword">case</span> <span class="org-type">System</span>.cmd(cmd_head, cmd_args, cmd_opts) <span class="org-keyword">do</span>
    {stdout, <span class="org-elixir-number">0</span>} <span class="org-keyword">-&gt;</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">For example, "git rev-parse ..." can output a trailing newline, which we</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">need to remove.</span>
      <span class="org-variable-name">stdout_trimmed</span> = <span class="org-type">String</span>.trim_trailing(stdout)
      <span class="org-variable-name">resource_id</span> = stdout_trimmed

      <span class="org-keyword">if</span> resource_id == <span class="org-string">""</span> <span class="org-keyword">do</span>
        <span class="org-type">Logger</span>.warning(
          <span class="org-string">"command returned successfully, but had no output: failed to "</span> &lt;&gt;
            <span class="org-string">"generate srs_id for resource </span><span class="org-variable-name">#{inspect({resource, resource_opts}</span><span class="org-string">)}"</span>
        )
      <span class="org-keyword">end</span>

      <span class="org-comment-delimiter"># </span><span class="org-comment">If we have an associated parser function, use it to help construct the</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">final ID format. Otherwise (or if it errors out due to an invalid</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">input), just use the output we got from above.</span>
      <span class="org-variable-name">parsed_resource_id</span> =
        <span class="org-keyword">if</span> parser_func != <span class="org-elixir-atom">nil</span> <span class="org-keyword">do</span>
          parser_func.([stdout_trimmed]) <span class="org-keyword">|&gt;</span> <span class="org-type">Kernel</span>.hd()
        <span class="org-keyword">end</span>

      <span class="org-variable-name">resource_id</span> =
        <span class="org-keyword">if</span> parsed_resource_id != <span class="org-elixir-atom">nil</span> &amp;&amp; <span class="org-type">String</span>.trim(parsed_resource_id) != <span class="org-string">""</span> <span class="org-keyword">do</span>
          parsed_resource_id
        <span class="org-keyword">end</span>

      resource_id

    {<span class="org-comment">_stdout</span>, error_code} <span class="org-keyword">-&gt;</span>
      <span class="org-type">Logger</span>.warning(
        <span class="org-string">"resource_id_command failed with error code </span><span class="org-variable-name">#{error_code}</span><span class="org-string">: failed to "</span> &lt;&gt;
          <span class="org-string">"generate srs_id for resource </span><span class="org-variable-name">#{inspect({resource, resource_opts}</span><span class="org-string">)}"</span>
      )

      <span class="org-string">""</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Supervisor" class="outline-5">
<h5 id="h-Supervisor"><span class="section-number-5">6.5.1.7.</span> Supervisor</h5>
<div class="outline-text-5" id="text-h-Supervisor">
<p>
Note that <code>Melbyd.StandardResource.read/4</code>, the standard client function, is the
one that reaches out to <code>Melbyd.StandardResourceSupervisor</code> to start the
<code>Melbyd.StandardResource</code> GenServer under a Supervisor. That is,
<code>Melbyd.StandardResource</code> knows how to supervise itself.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-17">melbyd_srs_supervisor</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_srs_supervisor">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_srs_supervisor"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.StandardResourceSupervisor</span> <span class="org-keyword">do</span>
  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-doc">"""</span>
<span class="org-doc">  StandardResource GenServers are created dynamically during runtime. This</span>
<span class="org-doc">  module supervises these servers so that they are restarted if they fail</span>
<span class="org-doc">  unexpectedly.</span>
<span class="org-doc">  """</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">This automatically defines child_spec/1</span>
  <span class="org-keyword">use</span> <span class="org-type">DynamicSupervisor</span>

  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-keyword">def</span> <span class="org-function-name">start_link</span>(init_arg) <span class="org-keyword">do</span>
    <span class="org-type">Logger</span>.info(<span class="org-string">"Starting SRS dynamic supervisor"</span>)
    <span class="org-type">DynamicSupervisor</span>.start_link(<span class="org-constant">__MODULE__</span>, init_arg, <span class="org-elixir-atom">name:</span> <span class="org-constant">__MODULE__</span>)
  <span class="org-keyword">end</span>

  <span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
  <span class="org-keyword">def</span> <span class="org-function-name">init</span>(<span class="org-comment">_init_arg</span>) <span class="org-keyword">do</span>
    <span class="org-type">DynamicSupervisor</span>.init(<span class="org-elixir-atom">strategy:</span> <span class="org-elixir-atom">:one_for_one</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">start_srs</span>(srs_id, resource, resource_opts) <span class="org-keyword">do</span>
    <span class="org-keyword">case</span> start_child(srs_id, resource, resource_opts) <span class="org-keyword">do</span>
      {<span class="org-elixir-atom">:ok</span>, pid} <span class="org-keyword">-&gt;</span> pid
      {<span class="org-elixir-atom">:error</span>, {<span class="org-elixir-atom">:already_started</span>, pid}} <span class="org-keyword">-&gt;</span> pid
      unknown <span class="org-keyword">-&gt;</span> <span class="org-type">Logger</span>.warning(<span class="org-string">"start_srs failed: </span><span class="org-variable-name">#{inspect(unknown)}</span><span class="org-string">"</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">start_child</span>(srs_id, resource, resource_opts) <span class="org-keyword">do</span>
    <span class="org-variable-name">ttl</span> = <span class="org-type">Application</span>.get_env(<span class="org-elixir-atom">:melbyd</span>, <span class="org-elixir-atom">:melbyd_srs_ttl</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">We pass in the srs_id ({resource_type, resource_id}) and ttl as an</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">argument to the start_link/1 function of Melbyd.StandardResource.</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">IOW, start_child() invokes the start_link() function of</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Melbyd.StandardResource.</span>
    <span class="org-type">DynamicSupervisor</span>.start_child(
      <span class="org-constant">__MODULE__</span>,
      {<span class="org-type">Melbyd.StandardResource</span>, %{<span class="org-elixir-atom">id:</span> srs_id,
                                 <span class="org-elixir-atom">resource:</span> resource,
                                 <span class="org-elixir-atom">resource_opts:</span> resource_opts,
                                 <span class="org-elixir-atom">ttl:</span> ttl,
                                 <span class="org-elixir-atom">notify_on_exit_pid:</span> <span class="org-elixir-atom">nil</span>}}
    )
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Shell-Logger-GenServer--SLG" class="outline-4">
<h4 id="h-Shell-Logger-GenServer--SLG"><span class="section-number-4">6.5.2.</span> Shell Logger GenServer (SLG)</h4>
<div class="outline-text-4" id="text-h-Shell-Logger-GenServer--SLG">
<p>
The purpose of the Shell Logger GenServer (SLG) is to subscribe to various
PubSub topics. That is, this is the consumer and the SRS GenServers are the
producers.
</p>

<p>
The idea is to let SRS GenServers publish messages to topics that they control
whenever anything interesting happens (where the determination of "interesting"
is up to the user's Lua configuration). And then it's up to SLGs to
subscribe to these topics and display these messages to the user.
</p>

<div class="org-src-container"><pre class="src src-elixir" id="nil-18"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.ShellLogger</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">GenServer</span>, <span class="org-elixir-atom">restart:</span> <span class="org-elixir-atom">:temporary</span>
  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-elixir-attribute">@tick_interval</span> <span class="org-elixir-number">1000</span>

  <span class="org-keyword">def</span> <span class="org-function-name">start_link</span>(
        %{
          <span class="org-elixir-atom">shell_pid:</span> shell_pid,
          <span class="org-elixir-atom">topic_handlers:</span> <span class="org-comment">_topic_handlers</span>,
          <span class="org-elixir-atom">env_vars:</span> <span class="org-comment">_env_vars</span>,
          <span class="org-elixir-atom">ttl:</span> <span class="org-comment">_ttl</span>,
          <span class="org-elixir-atom">notify_on_exit_pid:</span> <span class="org-comment">_notify_on_exit_pid</span>
        } = args_for_init
      ) <span class="org-keyword">do</span>
    <span class="org-type">GenServer</span>.start_link(<span class="org-constant">__MODULE__</span>, args_for_init, <span class="org-elixir-atom">name:</span> via_tuple(shell_pid))
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">via_tuple</span>(shell_pid) <span class="org-keyword">do</span>
    <span class="org-variable-name">key</span> = {<span class="org-elixir-atom">:n</span>, <span class="org-elixir-atom">:l</span>, {<span class="org-constant">__MODULE__</span>, shell_pid}}
    {<span class="org-elixir-atom">:via</span>, <span class="org-elixir-atom">:gproc</span>, key}
  <span class="org-keyword">end</span>

  <span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
  <span class="org-keyword">def</span> <span class="org-function-name">init</span>(
        %{
          <span class="org-elixir-atom">shell_pid:</span> shell_pid,
          <span class="org-elixir-atom">topic_handlers:</span> topic_handlers,
          <span class="org-elixir-atom">env_vars:</span> env_vars,
          <span class="org-elixir-atom">ttl:</span> ttl,
          <span class="org-elixir-atom">notify_on_exit_pid:</span> notify_on_exit_pid
        } = <span class="org-comment">_args</span>
      ) <span class="org-keyword">do</span>
    <span class="org-type">Process</span>.flag(<span class="org-elixir-atom">:trap_exit</span>, <span class="org-elixir-atom">true</span>)
    <span class="org-type">Logger</span>.info(<span class="org-string">"Starting Shell Logger </span><span class="org-variable-name">#{inspect(shell_pid)}</span><span class="org-string">; ttl=</span><span class="org-variable-name">#{inspect(ttl)}</span><span class="org-string">"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Subscribe to topics.</span>
    <span class="org-variable-name">topics</span> = <span class="org-type">Enum</span>.map(topic_handlers, <span class="org-keyword">fn</span> {topic, <span class="org-comment">_handler</span>} <span class="org-keyword">-&gt;</span> topic <span class="org-keyword">end</span>)
    <span class="org-type">Enum</span>.map(topics, <span class="org-keyword">fn</span> topic <span class="org-keyword">-&gt;</span> <span class="org-type">Phoenix.PubSub</span>.subscribe(<span class="org-type">Melbyd.PubSub</span>, topic) <span class="org-keyword">end</span>)
    <span class="org-type">Logger</span>.info(<span class="org-string">"Subscribed to these topics: </span><span class="org-variable-name">#{inspect(topics)}</span><span class="org-string">"</span>)

    <span class="org-variable-name">initial_state</span> = %{
      <span class="org-elixir-atom">shell_pid:</span> shell_pid,
      <span class="org-elixir-atom">messages:</span> [],
      <span class="org-elixir-atom">topic_handlers:</span> topic_handlers,
      <span class="org-elixir-atom">topics:</span> topics,
      <span class="org-elixir-atom">env_vars:</span> env_vars,
      <span class="org-elixir-atom">ttl:</span> ttl,
      <span class="org-elixir-atom">ttl_max:</span> ttl,
      <span class="org-elixir-atom">notify_on_exit_pid:</span> notify_on_exit_pid
    }

    <span class="org-comment-delimiter"># </span><span class="org-comment">Start up the tick process to detect TTL deadlines.</span>
    tick(ttl, notify_on_exit_pid)

    {<span class="org-elixir-atom">:ok</span>, initial_state}
  <span class="org-keyword">end</span>

  <span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
  <span class="org-keyword">def</span> <span class="org-function-name">handle_call</span>(
        {<span class="org-elixir-atom">:get_messages</span>, topic_handlers},
        <span class="org-comment">_from</span>,
        %{<span class="org-elixir-atom">shell_pid:</span> shell_pid,
          <span class="org-elixir-atom">messages:</span> messages,
          <span class="org-elixir-atom">topics:</span> already_subscribed_topics, <span class="org-elixir-atom">ttl_max:</span> ttl_max} = state
      ) <span class="org-keyword">do</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">If there are topics of interest that have not yet been subscribed to,</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">subscribe to them as well. But also unsubscribe from topics that we don't</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">care about any more.</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: In practice, because our Lua config is essentially immutable, we</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">never unsubscribe from topics because the topics list never changes.</span>
    <span class="org-variable-name">topics</span> = <span class="org-type">Enum</span>.map(topic_handlers, <span class="org-keyword">fn</span> {topic, <span class="org-comment">_handler</span>} <span class="org-keyword">-&gt;</span> topic <span class="org-keyword">end</span>)
    <span class="org-variable-name">topics_new</span> = topics -- already_subscribed_topics
    <span class="org-type">Enum</span>.map(topics_new, <span class="org-keyword">fn</span> topic <span class="org-keyword">-&gt;</span> <span class="org-type">Phoenix.PubSub</span>.subscribe(<span class="org-type">Melbyd.PubSub</span>, topic) <span class="org-keyword">end</span>)
    <span class="org-variable-name">topics_obsolete</span> = already_subscribed_topics -- topics
    <span class="org-type">Enum</span>.map(topics_obsolete, <span class="org-keyword">fn</span> topic <span class="org-keyword">-&gt;</span> <span class="org-type">Phoenix.PubSub</span>.unsubscribe(<span class="org-type">Melbyd.PubSub</span>, topic) <span class="org-keyword">end</span>)

    <span class="org-keyword">if</span> length(messages) &gt; <span class="org-elixir-number">0</span> <span class="org-keyword">do</span>
      <span class="org-type">Logger</span>.info(<span class="org-string">"Shell Logger </span><span class="org-variable-name">#{shell_pid}</span><span class="org-string">: sending messages to client: </span><span class="org-variable-name">#{inspect(messages)}</span><span class="org-string">"</span>)
    <span class="org-keyword">end</span>

    {
      <span class="org-elixir-atom">:reply</span>,
      <span class="org-comment-delimiter"># </span><span class="org-comment">Reverse the messages, because we store the newest one first.</span>
      <span class="org-type">Enum</span>.reverse(messages),
      <span class="org-comment-delimiter"># </span><span class="org-comment">Erase messages buffer because we've just dumped it to the client.</span>
      %{state | <span class="org-elixir-atom">messages:</span> [], <span class="org-elixir-atom">ttl:</span> ttl_max}
    }
  <span class="org-keyword">end</span>

  <span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
  <span class="org-keyword">def</span> <span class="org-function-name">handle_call</span>(
        {<span class="org-elixir-atom">:update_env_vars</span>, env_vars_new},
        <span class="org-comment">_from</span>,
        %{<span class="org-elixir-atom">shell_pid:</span> shell_pid, <span class="org-elixir-atom">env_vars:</span> env_vars_old} = state
      ) <span class="org-keyword">do</span>

    <span class="org-keyword">if</span> env_vars_new != env_vars_old <span class="org-keyword">do</span>
      <span class="org-type">Logger</span>.info(<span class="org-string">"Shell Logger </span><span class="org-variable-name">#{shell_pid}</span><span class="org-string">: updating env_vars from </span><span class="org-variable-name">#{inspect(env_vars_old)}</span><span class="org-string"> "</span> &lt;&gt;
        <span class="org-string">"to </span><span class="org-variable-name">#{inspect(env_vars_new)}</span><span class="org-string">"</span>)
    <span class="org-keyword">end</span>

    {
      <span class="org-elixir-atom">:reply</span>,
      <span class="org-elixir-atom">nil</span>,
      %{state | <span class="org-elixir-atom">env_vars:</span> env_vars_new}
    }
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">GenServer callbacks.</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_sps_handle_info-1">melbyd_sps_handle_info</a></span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Tick</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_sps_tick">melbyd_sps_tick</a></span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Client interface</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_sps_client_interface">melbyd_sps_client_interface</a></span>
<span class="org-keyword">end</span>


<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_sps_supervisor">melbyd_sps_supervisor</a></span>
</pre></div>
</div>

<div id="outline-container-h-Tick-1" class="outline-5">
<h5 id="h-Tick-1"><span class="section-number-5">6.5.2.1.</span> Tick</h5>
<div class="outline-text-5" id="text-h-Tick-1">
<p>
This is modeled after <code>Melbyd.StandardResource.tick/2</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-18">melbyd_sps_tick</a></span>(1/1) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_sps_tick">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_sps_tick"><span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: This code is identical to the one in Melbyd.StandardResource.tick/2. Can</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">we make it DRY somehow?</span>
<span class="org-keyword">defp</span> <span class="org-function-name">tick</span>(ttl, notify_on_exit_pid) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> ttl <span class="org-keyword">do</span>
    n <span class="org-keyword">when</span> n <span class="org-keyword">in</span> -<span class="org-elixir-number">1</span>..<span class="org-elixir-number">0</span> <span class="org-keyword">-&gt;</span>
      <span class="org-keyword">if</span> n == <span class="org-elixir-number">0</span> <span class="org-keyword">do</span>
        <span class="org-type">Logger</span>.info(<span class="org-string">"TTL expired; shutting down this GenServer due to client neglect"</span>)
      <span class="org-keyword">else</span>
        <span class="org-type">Logger</span>.info(
          <span class="org-string">"TTL expired manually; shutting down this GenServer"</span>
        )
      <span class="org-keyword">end</span>

      <span class="org-comment-delimiter"># </span><span class="org-comment">Used for testing, where we assert that we can receive this</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">":shutting_down" message after the ttl expires.</span>
      <span class="org-keyword">if</span> notify_on_exit_pid <span class="org-keyword">do</span>
        <span class="org-keyword">send</span>(notify_on_exit_pid, <span class="org-elixir-atom">:shutting_down</span>)
      <span class="org-keyword">end</span>

      <span class="org-type">Process</span>.exit(self(), <span class="org-elixir-atom">:ttl_deadline_exceeded</span>)
    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
      <span class="org-type">Process</span>.send_after(self(), <span class="org-elixir-atom">:tick</span>, <span class="org-elixir-attribute">@tick_interval</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-18">melbyd_sps_handle_info</a></span>(1/3) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_sps_handle_info-1">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_sps_handle_info-1"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      <span class="org-elixir-atom">:tick</span>,
      %{
        <span class="org-elixir-atom">ttl:</span> ttl,
        <span class="org-elixir-atom">notify_on_exit_pid:</span> notify_on_exit_pid
      } = state
    ) <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Continue ticking for the future. But optionally die if ttl is too low.</span>
  tick(ttl, notify_on_exit_pid)
  {<span class="org-elixir-atom">:noreply</span>, %{state | <span class="org-elixir-atom">ttl:</span> ttl - <span class="org-elixir-number">1</span>}}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Handle-PubSub-messages" class="outline-5">
<h5 id="h-Handle-PubSub-messages"><span class="section-number-5">6.5.2.2.</span> Handle PubSub messages</h5>
<div class="outline-text-5" id="text-h-Handle-PubSub-messages">
<p>
We filter out messages that don't apply to us. For example, if the message is
about a Git repo at <code>/a/b/c</code> where <code>c</code> is the repo root, but we (the shell
process) is currently located at <code>/a/b</code>, then we need to discard this message.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-18">melbyd_sps_handle_info</a></span>(2/3) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_sps_handle_info-2">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_sps_handle_info-2"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      %{<span class="org-elixir-atom">topic:</span> topic, <span class="org-elixir-atom">from:</span> <span class="org-comment">_from</span>, <span class="org-elixir-atom">payload:</span> <span class="org-comment">_payload</span>} = message,
      %{
        <span class="org-elixir-atom">shell_pid:</span> shell_pid,
        <span class="org-elixir-atom">messages:</span> messages,
        <span class="org-elixir-atom">topic_handlers:</span> topic_handlers,
        <span class="org-elixir-atom">env_vars:</span> env_vars
      } = state
    ) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.info(<span class="org-string">"Shell Logger </span><span class="org-variable-name">#{shell_pid}</span><span class="org-string">: Handling PubSub message: </span><span class="org-variable-name">#{inspect(message)}</span><span class="org-string">"</span>)

  <span class="org-variable-name">keep_message</span> =
    <span class="org-keyword">if</span> <span class="org-type">Map</span>.has_key?(topic_handlers, topic) <span class="org-keyword">do</span>
      <span class="org-variable-name">should_keep_message</span> = topic_handlers[topic]
      should_keep_message.([message, env_vars]) <span class="org-keyword">|&gt;</span> <span class="org-type">Kernel</span>.hd()
    <span class="org-keyword">else</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">If we can't find an associated filter function for this topic, discard it</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">but log a warning.</span>
      <span class="org-type">Logger</span>.warning(<span class="org-string">"could not find filter function for PubSub message </span><span class="org-variable-name">#{inspect(message)}</span><span class="org-string">"</span>)

      <span class="org-elixir-atom">false</span>
    <span class="org-keyword">end</span>

  <span class="org-keyword">if</span> keep_message <span class="org-keyword">do</span>
    <span class="org-type">Logger</span>.info(<span class="org-string">"Shell Logger </span><span class="org-variable-name">#{shell_pid}</span><span class="org-string">: Keeping message </span><span class="org-variable-name">#{inspect(message)}</span><span class="org-string">"</span>)
    {<span class="org-elixir-atom">:noreply</span>, %{state | <span class="org-elixir-atom">messages:</span> [message | messages]}}
  <span class="org-keyword">else</span>
    <span class="org-type">Logger</span>.info(<span class="org-string">"Shell Logger </span><span class="org-variable-name">#{shell_pid}</span><span class="org-string">: Dropping message </span><span class="org-variable-name">#{inspect(message)}</span><span class="org-string">"</span>)
    {<span class="org-elixir-atom">:noreply</span>, state}
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Graceful-shutdown-1" class="outline-5">
<h5 id="h-Graceful-shutdown-1"><span class="section-number-5">6.5.2.3.</span> Graceful shutdown</h5>
<div class="outline-text-5" id="text-h-Graceful-shutdown-1">
<p>
This is identical to the graceful shutdown logic for SRS.
</p>

<p>
FIXME: Can we make it DRY? Maybe use a macro, or some new utility functions? Or
a behaviour or protocol&#x2026;?
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-18">melbyd_sps_handle_info</a></span>(3/3) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_sps_handle_info-3">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_sps_handle_info-3"><span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">handle_info</span>(
      {<span class="org-elixir-atom">:EXIT</span>, from_pid, reason},
      %{<span class="org-elixir-atom">shell_pid:</span> shell_pid} = state
    ) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.debug(<span class="org-string">"Shell Logger </span><span class="org-variable-name">#{shell_pid}</span><span class="org-string">: Got exit reason </span><span class="org-variable-name">#{inspect(reason)}</span><span class="org-string"> from pid </span><span class="org-variable-name">#{inspect(from_pid)}</span><span class="org-string">; exiting"</span>)
  <span class="org-keyword">case</span> reason <span class="org-keyword">do</span>
    <span class="org-elixir-atom">:normal</span> <span class="org-keyword">-&gt;</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">This can happen if, e.g., a System.cmd/3 finishes running successfully.</span>
      {<span class="org-elixir-atom">:noreply</span>, state}
    <span class="org-elixir-atom">:ttl_deadline_exceeded</span> <span class="org-keyword">-&gt;</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Invoke our terminate/2 callback by returning with the ":stop" atom.</span>
      {<span class="org-elixir-atom">:stop</span>, <span class="org-elixir-atom">:normal</span>, state}
    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
      {<span class="org-elixir-atom">:stop</span>, reason, state}
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
<span class="org-keyword">def</span> <span class="org-function-name">terminate</span>(
      reason,
      %{<span class="org-elixir-atom">shell_pid:</span> shell_pid} = <span class="org-comment">_state</span>
    ) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.info(<span class="org-string">"Shell Logger </span><span class="org-variable-name">#{shell_pid}</span><span class="org-string">: Got exit reason </span><span class="org-variable-name">#{inspect(reason)}</span><span class="org-string">; shutting down"</span>)
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Client-interface-1" class="outline-5">
<h5 id="h-Client-interface-1"><span class="section-number-5">6.5.2.4.</span> Client interface</h5>
<div class="outline-text-5" id="text-h-Client-interface-1">
<p>
The <code>get_messages/2</code> function either retrieves all messages from this SLG's
<code>messages</code> field, or if there isn't a GenServer that has started
yet, just creates one.
</p>

<p>
The internals here mirror the design in <code>Melbyd.StandardResource.read/2</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-18">melbyd_sps_client_interface</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_sps_client_interface">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_sps_client_interface"><span class="org-keyword">def</span> <span class="org-function-name">get_messages</span>(shell_pid, topic_handlers, env_vars) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> <span class="org-elixir-atom">:gproc</span>.lookup_pids({<span class="org-elixir-atom">:n</span>, <span class="org-elixir-atom">:l</span>, {<span class="org-type">Melbyd.ShellLogger</span>, shell_pid}}) <span class="org-keyword">do</span>
    [pid] <span class="org-keyword">-&gt;</span>
      <span class="org-type">Logger</span>.info(<span class="org-string">"Found existing pid for </span><span class="org-variable-name">#{inspect(shell_pid)}</span><span class="org-string">: </span><span class="org-variable-name">#{inspect(pid)}</span><span class="org-string">"</span>)
      <span class="org-comment-delimiter"># </span><span class="org-comment">We update the env_vars in the GenServer state, because otherwise it will</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">always keep the same env_vars that it was created with.</span>
      <span class="org-type">GenServer</span>.call(pid, {<span class="org-elixir-atom">:update_env_vars</span>, env_vars})
      <span class="org-type">GenServer</span>.call(pid, {<span class="org-elixir-atom">:get_messages</span>, topic_handlers})

    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
      <span class="org-type">Task.Supervisor</span>.start_child(<span class="org-type">Melbyd.TaskSupervisor</span>, <span class="org-keyword">fn</span> <span class="org-keyword">-&gt;</span>
        <span class="org-type">Melbyd.ShellLoggerSupervisor</span>.start_sps(shell_pid, topic_handlers, env_vars)
      <span class="org-keyword">end</span>)

      <span class="org-comment-delimiter"># </span><span class="org-comment">Return empty list (no messages) for now.</span>
      []
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Supervisor-1" class="outline-5">
<h5 id="h-Supervisor-1"><span class="section-number-5">6.5.2.5.</span> Supervisor</h5>
<div class="outline-text-5" id="text-h-Supervisor-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-18">melbyd_sps_supervisor</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_sps_supervisor">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_sps_supervisor"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.ShellLoggerSupervisor</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">DynamicSupervisor</span>

  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-keyword">def</span> <span class="org-function-name">start_link</span>(init_arg) <span class="org-keyword">do</span>
    <span class="org-type">Logger</span>.info(<span class="org-string">"Starting SLG dynamic supervisor"</span>)
    <span class="org-type">DynamicSupervisor</span>.start_link(<span class="org-constant">__MODULE__</span>, init_arg, <span class="org-elixir-atom">name:</span> <span class="org-constant">__MODULE__</span>)
  <span class="org-keyword">end</span>

  <span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
  <span class="org-keyword">def</span> <span class="org-function-name">init</span>(<span class="org-comment">_init_arg</span>) <span class="org-keyword">do</span>
    <span class="org-type">DynamicSupervisor</span>.init(<span class="org-elixir-atom">strategy:</span> <span class="org-elixir-atom">:one_for_one</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">start_sps</span>(shell_pid, topic_handlers, env_vars) <span class="org-keyword">do</span>
    <span class="org-keyword">case</span> start_child(shell_pid, topic_handlers, env_vars) <span class="org-keyword">do</span>
      {<span class="org-elixir-atom">:ok</span>, pid} <span class="org-keyword">-&gt;</span> pid
      {<span class="org-elixir-atom">:error</span>, {<span class="org-elixir-atom">:already_started</span>, pid}} <span class="org-keyword">-&gt;</span> pid
      unknown <span class="org-keyword">-&gt;</span> <span class="org-type">Logger</span>.warning(<span class="org-string">"start_sps failed: </span><span class="org-variable-name">#{inspect(unknown)}</span><span class="org-string">"</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">start_child</span>(shell_pid, topic_handlers, env_vars) <span class="org-keyword">do</span>
    <span class="org-variable-name">ttl</span> = <span class="org-type">Application</span>.get_env(<span class="org-elixir-atom">:melbyd</span>, <span class="org-elixir-atom">:melbyd_sps_ttl</span>)

    <span class="org-type">DynamicSupervisor</span>.start_child(
      <span class="org-constant">__MODULE__</span>,
      {<span class="org-type">Melbyd.ShellLogger</span>, %{<span class="org-elixir-atom">shell_pid:</span> shell_pid,
                             <span class="org-elixir-atom">topic_handlers:</span> topic_handlers,
                             <span class="org-elixir-atom">env_vars:</span> env_vars,
                             <span class="org-elixir-atom">ttl:</span> ttl,
                             <span class="org-elixir-atom">notify_on_exit_pid:</span> <span class="org-elixir-atom">nil</span>}}
    )
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Current-path--path-shortening" class="outline-4">
<h4 id="h-Current-path--path-shortening"><span class="section-number-4">6.5.3.</span> Current path (path shortening)</h4>
<div class="outline-text-4" id="text-h-Current-path--path-shortening">
</div>

<div id="outline-container-h-Path" class="outline-5">
<h5 id="h-Path"><span class="section-number-5">6.5.3.1.</span> Path</h5>
<div class="outline-text-5" id="text-h-Path">
<div class="org-src-container"><pre class="src src-elixir" id="nil-19"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.Path</span> <span class="org-keyword">do</span>
  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-doc">"""</span>
<span class="org-doc">  Caching wrapper around path shortening function.</span>
<span class="org-doc">  """</span>

  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-keyword">def</span> <span class="org-function-name">get_path_pretty</span>(path, aliases, env_vars, shorten_threshold) <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">The aliases and env_vars are lists. We leave them as such for acting as</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">keys to Cachex entries. But we do a conversion to a Map before calling the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Rust NIF, because the Rust functions expect a HashMap.</span>
    {status, path_pretty} = <span class="org-type">Cachex</span>.get(
      <span class="org-elixir-atom">:path_pretty_cache</span>,
      {path, aliases, env_vars})

    <span class="org-keyword">if</span> status == <span class="org-elixir-atom">:error</span> || path_pretty == <span class="org-elixir-atom">nil</span> <span class="org-keyword">do</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Optionally colorize path depth. Maybe take in something like</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">keyword args...? Ideally user should be able to define a list of colors</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">to use for each directory depth (using modulo for cyclicness), as well</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">as the color of the slash and leading tilde (aliases).</span>
      <span class="org-variable-name">path_pretty</span> =
        <span class="org-type">Melbyd.Nifs</span>.path_shorten(
          path,
          aliases,
          env_vars,
          shorten_threshold
        )

      <span class="org-type">Cachex</span>.put(<span class="org-elixir-atom">:path_pretty_cache</span>, {path, aliases, env_vars}, path_pretty)

      <span class="org-type">Logger</span>.info(%{<span class="org-elixir-atom">msg:</span> <span class="org-string">"cache miss"</span>, <span class="org-elixir-atom">path:</span> path})
      path_pretty
    <span class="org-keyword">else</span>
      path_pretty
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div><div class="org-src-container"><pre class="src src-rust" id="nil-20"><span class="org-keyword">use</span> <span class="org-constant">envsubst</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">HashMap</span>;

<span class="org-preprocessor">#[cfg_attr(feature = </span><span class="org-string">"elixir_support"</span><span class="org-preprocessor">, rustler::nif)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">path_shorten</span>(
    <span class="org-variable-name">path</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>,
    <span class="org-variable-name">aliases</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt;,
    <span class="org-variable-name">env_vars</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt;,
    <span class="org-variable-name">shorten_threshold</span>: <span class="org-type">u8</span>,
) -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">path_canonical</span> = make_canonical_path(path, <span class="org-rust-ampersand">&amp;</span>aliases, <span class="org-rust-ampersand">&amp;</span>env_vars);
    _path_shorten(<span class="org-rust-ampersand">&amp;</span>path_canonical, shorten_threshold)
}

<span class="org-keyword">fn</span> <span class="org-function-name">_path_shorten</span>(<span class="org-variable-name">path_canonical</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">shorten_threshold</span>: <span class="org-type">u8</span>) -&gt; <span class="org-type">String</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Don't shorten if the shorten_threshold is disabled.</span>
    <span class="org-keyword">if</span> shorten_threshold == 0 {
        <span class="org-keyword">return</span> path_canonical.to_string();
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Don't shorten paths that are `shorten_threshold` characters or less in</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">length.</span>
    <span class="org-keyword">if</span> path_canonical.chars().count() &lt;= shorten_threshold.into() {
        <span class="org-keyword">return</span> path_canonical.to_string();
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Don't bother shortening anything if there is only 1 directory.</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">parts_count</span> = path_canonical.split(<span class="org-string">"/"</span>).count();
    <span class="org-keyword">if</span> parts_count == 1 {
        <span class="org-keyword">return</span> path_canonical.to_string();
    }
    <span class="org-keyword">let</span> <span class="org-variable-name">first_char</span> = path_canonical.chars().next().unwrap();
    <span class="org-keyword">if</span> first_char == <span class="org-string">'/'</span> &amp;&amp; parts_count == 2 {
        <span class="org-keyword">return</span> path_canonical.to_string();
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Determine overall "search" area of possible directories within the path</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">to shorten to 1 character. We exclude from the search the very first and</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">last directories.</span>
    <span class="org-keyword">let</span> (j, shortenable_dirs) = <span class="org-keyword">match</span> first_char {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Do not shorten leading directories that start with '~', and also do</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">not consider the root directory '/'.</span>
        <span class="org-string">'/'</span> | <span class="org-string">'~'</span> =&gt; (1, 1..(parts_count - 1)),
        _ =&gt; (0, 0..(parts_count - 1)),
    };

    <span class="org-comment-delimiter">// </span><span class="org-comment">Construct a set of ranges, using shortenable_dirs. E.g., if</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">shortenable_dirs is (1..3), then construct:</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(1..2)</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(1..3)</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(1..4).</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">We use these ranges to denote directories that should be shortened. As</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">these ranges include more and more numbers, we shorten more and more</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">directories until we are satisified with how much we've shortened</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">path_canonical.</span>
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">ranges</span>: <span class="org-type">Vec</span>&lt;<span class="org-constant">std</span>::<span class="org-constant">ops</span>::<span class="org-type">Range</span>&lt;<span class="org-type">usize</span>&gt;&gt; = <span class="org-type">Vec</span>::new();

    <span class="org-keyword">for</span> <span class="org-variable-name">i</span> <span class="org-keyword">in</span> shortenable_dirs {
        ranges.push(j..i + 1);
    }

    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">candidate_best</span>: <span class="org-type">Option</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">None</span>;
    <span class="org-keyword">for</span> <span class="org-variable-name">range</span> <span class="org-keyword">in</span> ranges {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Construct shortened path candidate with all directories in the range</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">shortened.</span>
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">candidate</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Vec</span>::new();
        <span class="org-keyword">for</span> (part_idx, part) <span class="org-keyword">in</span> path_canonical.split(<span class="org-string">"/"</span>).enumerate() {
            <span class="org-keyword">if</span> range.contains(<span class="org-rust-ampersand">&amp;</span>part_idx) {
                <span class="org-comment-delimiter">// </span><span class="org-comment">Add shortened version.</span>
                candidate.push(part.chars().next().unwrap().to_string());
            } <span class="org-keyword">else</span> {
                <span class="org-comment-delimiter">// </span><span class="org-comment">Add as-is.</span>
                candidate.push(part.to_string());
            }
        }
        <span class="org-keyword">let</span> <span class="org-variable-name">shortened</span> = candidate.join(<span class="org-string">"/"</span>);
        <span class="org-comment-delimiter">// </span><span class="org-comment">If a better (shorter) candidate is found, prefer it over the previous</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">candidate.</span>
        <span class="org-keyword">if</span> candidate_best.is_none()
            || shortened.chars().count() &lt; candidate_best.as_ref().unwrap().chars().count()
        {
            candidate_best = <span class="org-type">Some</span>(shortened);
        };

        <span class="org-comment-delimiter">// </span><span class="org-comment">If a candidate is already under 30 characters, stop searching.</span>
        <span class="org-keyword">if</span> candidate_best.is_some() &amp;&amp; candidate_best.as_ref().unwrap().chars().count() &lt;= 30 {
            <span class="org-keyword">break</span>;
        }
    }

    <span class="org-keyword">if</span> candidate_best.is_none() {
        path_canonical.to_string()
    } <span class="org-keyword">else</span> {
        candidate_best.unwrap().to_string()
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">make_canonical_path</span>(
    <span class="org-variable-name">path</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>,
    <span class="org-variable-name">aliases</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt;,
    <span class="org-variable-name">env_vars</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt;,
) -&gt; <span class="org-type">String</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">For every aliased path, replace all matching environment variable</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">references in the path with their actual runtime values. For example, if</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">aliases has an entry like "${HOME}/foo/bar" and "${HOME}" is set to</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">"/home/alice", then replace the name entry with</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">"/home/alice/foo/bar".</span>
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">aliases_expanded</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt; = <span class="org-type">HashMap</span>::new();

    <span class="org-comment-delimiter">// </span><span class="org-comment">Remove env vars that have invalid values, because otherwise the envsubst</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">library chokes (even if we aren't trying to use the invalid values).</span>
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env_vars_cleaned</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt; = <span class="org-type">HashMap</span>::new();
    <span class="org-keyword">for</span> (k, v) <span class="org-keyword">in</span> env_vars {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">context</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt; = <span class="org-type">HashMap</span>::new();
        context.insert(k.to_string(), v.to_string());
        <span class="org-keyword">if</span> <span class="org-constant">envsubst</span>::validate_vars(<span class="org-rust-ampersand">&amp;</span>context).is_ok() {
            env_vars_cleaned.insert(k.to_string(), v.to_string());
        }
    }

    <span class="org-keyword">for</span> (path_maybe_has_env_vars, name) <span class="org-keyword">in</span> aliases.into_iter() {
        <span class="org-keyword">let</span> <span class="org-variable-name">expanded_path</span> =
            <span class="org-constant">envsubst</span>::substitute(path_maybe_has_env_vars, <span class="org-rust-ampersand">&amp;</span>env_vars_cleaned).unwrap();
        aliases_expanded.insert(expanded_path, name.to_string());
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Encode the shell's "~" character as a special case of our "name" idiom.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">This way, even if no aliases match, we can replace "/home/foo" with "~".</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">FIXME: This requires HOME to be set. Otherwise we'll panic when we</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">unwrap() below.</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">home_value</span> = env_vars.get(&amp;<span class="org-string">"HOME"</span>.to_string()).unwrap();
    <span class="org-comment-delimiter">// </span><span class="org-comment">Don't replace $HOME with "~" becausewe we already prepend every name</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">match with a "~". So defining the value here with a tilde would result in</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">a "~~".</span>
    aliases_expanded.insert(home_value.to_string(), <span class="org-string">""</span>.to_string());

    <span class="org-keyword">let</span> <span class="org-variable-name">path_canonical</span> = <span class="org-keyword">match</span> get_matching_name(path, <span class="org-rust-ampersand">&amp;</span>aliases_expanded) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Find the longest matching expanded path in the path aliases. If there</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">is a match, then we use "~ALIAS" (the leading "~" does not mean $HOME</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">and just signifies that the word that immediately follows it is a</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">path alias). This is a Zsh-ism.</span>
        <span class="org-type">Some</span>((expanded_path, name)) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">aliased_path</span> = path.replacen(<span class="org-rust-ampersand">&amp;</span>expanded_path, <span class="org-rust-ampersand">&amp;</span>name, 1);
            <span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"~</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, aliased_path)
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">If there is no match, return the path as-is.</span>
        <span class="org-type">None</span> =&gt; path.to_string(),
    };

    path_canonical
}

<span class="org-keyword">fn</span> <span class="org-function-name">get_matching_name</span>(<span class="org-variable-name">path</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">aliases</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt;) -&gt; <span class="org-type">Option</span>&lt;(<span class="org-type">String</span>, <span class="org-type">String</span>)&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">aliased_paths</span> = aliases.keys().collect::&lt;<span class="org-type">Vec</span>&lt;_&gt;&gt;();
    aliased_paths.sort();
    aliased_paths.reverse();

    <span class="org-keyword">for</span> <span class="org-variable-name">aliased_path</span> <span class="org-keyword">in</span> aliased_paths {
        <span class="org-keyword">if</span> path.starts_with(aliased_path) {
            <span class="org-keyword">let</span> <span class="org-variable-name">name</span> = aliases.get(aliased_path).unwrap();
            <span class="org-keyword">return</span> <span class="org-type">Some</span>((aliased_path.to_string(), name.to_string()));
        }
    }

    <span class="org-type">None</span>
}

<span class="org-preprocessor">#[cfg(test)]</span>
<span class="org-keyword">mod</span> <span class="org-constant">test</span> {
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::*;

    <span class="org-preprocessor">#[test]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">test_make_canonical_path</span>() {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">aliases</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt; = <span class="org-type">HashMap</span>::new();
        aliases.insert(<span class="org-string">"${HOME}/bar"</span>.to_string(), <span class="org-string">"b"</span>.to_string());
        aliases.insert(
            <span class="org-string">"${HOME}/bar/baz/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/c"</span>.to_string(),
            <span class="org-string">"c"</span>.to_string(),
        );
        aliases.insert(<span class="org-string">"${MYPROJECT_DIR}"</span>.to_string(), <span class="org-string">"p"</span>.to_string());
        <span class="org-comment-delimiter">// </span><span class="org-comment">Handle aliases composed of multiple environment variables.</span>
        aliases.insert(
            <span class="org-string">"${MYPROJECT_DIR}/${KOALA_SIZE}"</span>.to_string(),
            <span class="org-string">"pk"</span>.to_string(),
        );

        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env_vars</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">String</span>&gt; = <span class="org-type">HashMap</span>::new();
        env_vars.insert(<span class="org-string">"HOME"</span>.to_string(), <span class="org-string">"/home/foo"</span>.to_string());
        env_vars.insert(
            <span class="org-string">"MYPROJECT_DIR"</span>.to_string(),
            <span class="org-string">"/home/foo/myproject"</span>.to_string(),
        );
        env_vars.insert(<span class="org-string">"KOALA_SIZE"</span>.to_string(), <span class="org-string">"big"</span>.to_string());

        <span class="org-preprocessor">assert_eq!</span>(make_canonical_path(<span class="org-string">""</span>, <span class="org-rust-ampersand">&amp;</span>aliases, <span class="org-rust-ampersand">&amp;</span>env_vars), <span class="org-string">""</span>);
        <span class="org-preprocessor">assert_eq!</span>(make_canonical_path(<span class="org-string">"/"</span>, <span class="org-rust-ampersand">&amp;</span>aliases, <span class="org-rust-ampersand">&amp;</span>env_vars), <span class="org-string">"/"</span>);
        <span class="org-preprocessor">assert_eq!</span>(
            make_canonical_path(<span class="org-string">"/unrecognized/path"</span>, <span class="org-rust-ampersand">&amp;</span>aliases, <span class="org-rust-ampersand">&amp;</span>env_vars),
            <span class="org-string">"/unrecognized/path"</span>
        );
        <span class="org-preprocessor">assert_eq!</span>(make_canonical_path(<span class="org-string">"/home/foo"</span>, <span class="org-rust-ampersand">&amp;</span>aliases, <span class="org-rust-ampersand">&amp;</span>env_vars), <span class="org-string">"~"</span>);
        <span class="org-preprocessor">assert_eq!</span>(
            make_canonical_path(<span class="org-string">"/home/foo/bar"</span>, <span class="org-rust-ampersand">&amp;</span>aliases, <span class="org-rust-ampersand">&amp;</span>env_vars),
            <span class="org-string">"~b"</span>
        );
        <span class="org-preprocessor">assert_eq!</span>(
            make_canonical_path(
                <span class="org-string">"/home/foo/bar/baz/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/c"</span>,
                <span class="org-rust-ampersand">&amp;</span>aliases,
                <span class="org-rust-ampersand">&amp;</span>env_vars,
            ),
            <span class="org-string">"~c"</span>
        );
        <span class="org-preprocessor">assert_eq!</span>(
            make_canonical_path(<span class="org-string">"/home/foo/myproject"</span>, <span class="org-rust-ampersand">&amp;</span>aliases, <span class="org-rust-ampersand">&amp;</span>env_vars),
            <span class="org-string">"~p"</span>
        );
        <span class="org-preprocessor">assert_eq!</span>(
            make_canonical_path(<span class="org-string">"/home/foo/myproject/big"</span>, <span class="org-rust-ampersand">&amp;</span>aliases, <span class="org-rust-ampersand">&amp;</span>env_vars),
            <span class="org-string">"~pk"</span>
        );
    }

    <span class="org-preprocessor">#[test]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">test_path_shorten</span>() {
        <span class="org-preprocessor">assert_eq!</span>(_path_shorten(<span class="org-string">""</span>, 30), <span class="org-string">""</span>);
        <span class="org-preprocessor">assert_eq!</span>(_path_shorten(<span class="org-string">"~"</span>, 30), <span class="org-string">"~"</span>);
        <span class="org-preprocessor">assert_eq!</span>(_path_shorten(<span class="org-string">"/"</span>, 30), <span class="org-string">"/"</span>);
        <span class="org-preprocessor">assert_eq!</span>(_path_shorten(<span class="org-string">"/a"</span>, 30), <span class="org-string">"/a"</span>);
        <span class="org-preprocessor">assert_eq!</span>(_path_shorten(<span class="org-string">"/a/b/c"</span>, 30), <span class="org-string">"/a/b/c"</span>);
        <span class="org-preprocessor">assert_eq!</span>(_path_shorten(<span class="org-string">"a"</span>, 30), <span class="org-string">"a"</span>);
        <span class="org-preprocessor">assert_eq!</span>(_path_shorten(<span class="org-string">"a/b/c"</span>, 30), <span class="org-string">"a/b/c"</span>);
        <span class="org-comment-delimiter">// </span><span class="org-comment">If the path is exactly 30 characters, we should not shorten anything.</span>
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(<span class="org-string">"/a23456789/b23456789/c23456789"</span>, 30),
            <span class="org-string">"/a23456789/b23456789/c23456789"</span>
        );
        <span class="org-comment-delimiter">// </span><span class="org-comment">If the path is just over 30 characters, we should shorten the first</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">directory.</span>
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(<span class="org-string">"/a23456789/b23456789/c23456789d"</span>, 30),
            <span class="org-string">"/a/b23456789/c23456789d"</span>
        );
        <span class="org-comment-delimiter">// </span><span class="org-comment">Some longer directories.</span>
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(<span class="org-string">"/a23456789/b23456789/c23456789/d23456789"</span>, 30),
            <span class="org-string">"/a/b/c23456789/d23456789"</span>
        );
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(<span class="org-string">"a23456789/b23456789/c23456789/d23456789"</span>, 30),
            <span class="org-string">"a/b/c23456789/d23456789"</span>
        );
        <span class="org-comment-delimiter">// </span><span class="org-comment">Shortening of aliases (directories with "~") in them are forbidden.</span>
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(<span class="org-string">"~a23456789/b23456789/c23456789/d23456789"</span>, 30),
            <span class="org-string">"~a23456789/b/c/d23456789"</span>
        );
        <span class="org-comment-delimiter">// </span><span class="org-comment">Realistic example (last directory remains untouched).</span>
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(<span class="org-string">"~/prog/foreign/git/contrib/thunderbird-patch-inline"</span>, 30),
            <span class="org-string">"~/p/f/g/c/thunderbird-patch-inline"</span>
        );
        <span class="org-comment-delimiter">// </span><span class="org-comment">Extreme cases.</span>
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(
                <span class="org-string">"~/aaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccc/hello"</span>,
                30
            ),
            <span class="org-string">"~/a/b/c/hello"</span>
        );
        <span class="org-comment-delimiter">// </span><span class="org-comment">Unusual case of just 2 directories, where both are very long.</span>
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(
                <span class="org-string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"</span>,
                30
            ),
            <span class="org-string">"a/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"</span>
        );
        <span class="org-comment-delimiter">// </span><span class="org-comment">Non-ASCII (exactly 30 characters).</span>
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(
                <span class="org-string">"/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;"</span>,
                30
            ),
            <span class="org-string">"/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;"</span>
        );
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(
                <span class="org-string">"&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;a"</span>,
                30
            ),
            <span class="org-string">"&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;a"</span>
        );
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(
                <span class="org-string">"~&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;"</span>,
                30
            ),
            <span class="org-string">"~&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;"</span>
        );
        <span class="org-comment-delimiter">// </span><span class="org-comment">Non-ASCII (over 30 characters).</span>
        <span class="org-preprocessor">assert_eq!</span>(
            _path_shorten(
                <span class="org-string">"/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/a"</span>,
                30
            ),
            <span class="org-string">"/&#51068;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/&#51068;&#51060;&#49340;&#49324;&#50724;&#50977;&#52832;&#54036;&#44396;/a"</span>
        );
        <span class="org-keyword">let</span> <span class="org-variable-name">longstr</span> = <span class="org-preprocessor">concat!</span>(
            <span class="org-string">"~/&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;&#51068;"</span>,
            <span class="org-string">"/&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;&#51060;"</span>,
            <span class="org-string">"/&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;&#49340;"</span>,
            <span class="org-string">"/hello"</span>
        );
        <span class="org-preprocessor">assert_eq!</span>(_path_shorten(longstr, 30), <span class="org-string">"~/&#51068;/&#51060;/&#49340;/hello"</span>);
        <span class="org-comment-delimiter">// </span><span class="org-comment">Shorten threshold is disabled, so don't shorten at all.</span>
        <span class="org-preprocessor">assert_eq!</span>(_path_shorten(longstr, 0), longstr);
    }
}
</pre></div>
</div>
</div>

<div id="outline-container-h-Caching" class="outline-5">
<h5 id="h-Caching"><span class="section-number-5">6.5.3.2.</span> Caching</h5>
<div class="outline-text-5" id="text-h-Caching">
<p>
We use caching for the path shortening logic. We avoid re-shortening a given
path if we've seen the same inputs before.
</p>

<p>
We only keep a cache size of 256 because in practice we only move around a
handful of directories during a typical computing session.
</p>

<div class="org-src-container"><pre class="src src-elixir" id="nil-21"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.Cache.PathShorten</span> <span class="org-keyword">do</span>
  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-doc">"""</span>
<span class="org-doc">  path-shorten Cache</span>
<span class="org-doc">  """</span>
  <span class="org-elixir-attribute">@cache_id</span> <span class="org-elixir-atom">:path_pretty_cache</span>

  <span class="org-keyword">def</span> <span class="org-function-name">child_spec</span>(<span class="org-comment">_init_arg</span>) <span class="org-keyword">do</span>
    %{
      <span class="org-elixir-atom">id:</span> <span class="org-elixir-attribute">@cache_id</span>,
      <span class="org-elixir-atom">type:</span> <span class="org-elixir-atom">:supervisor</span>,
      <span class="org-elixir-atom">start:</span>
        {<span class="org-type">Cachex</span>, <span class="org-elixir-atom">:start_link</span>,
         [
           <span class="org-elixir-attribute">@cache_id</span>,
           [
             <span class="org-elixir-atom">limit:</span> <span class="org-elixir-number">256</span>
           ]
         ]}
    }
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-h-Colors" class="outline-4">
<h4 id="h-Colors"><span class="section-number-4">6.5.4.</span> Colors</h4>
<div class="outline-text-4" id="text-h-Colors">
<p>
We use <a href="https://github.com/mazznoer/csscolorparser-rs"><code>csscolorparser</code></a> to parse a wide variety of ways to represent colors. The
point of using a NIF here isn't so much about speed, but more about the
convenience of being able to use this library.
</p>

<div class="org-src-container"><pre class="src src-rust" id="nil-22"><span class="org-keyword">use</span> <span class="org-constant">csscolorparser</span>::<span class="org-type">Color</span>;

<span class="org-preprocessor">#[derive(Default, Debug, PartialEq, Eq)]</span>
<span class="org-preprocessor">#[cfg_attr(feature = </span><span class="org-string">"elixir_support"</span><span class="org-preprocessor">, derive(rustler::NifTuple))]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Color24BitRust</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">red</span>: <span class="org-type">u8</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">green</span>: <span class="org-type">u8</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">blue</span>: <span class="org-type">u8</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">alpha</span>: <span class="org-type">u8</span>,
}

<span class="org-preprocessor">#[cfg_attr(feature = </span><span class="org-string">"elixir_support"</span><span class="org-preprocessor">, rustler::nif)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">parse_color</span>(<span class="org-variable-name">color_str</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Color24BitRust</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">vals</span> = <span class="org-keyword">match</span> color_str.parse::&lt;<span class="org-type">Color</span>&gt;() {
        <span class="org-type">Ok</span>(color) =&gt; color.to_rgba8(),
        <span class="org-type">Err</span>(e) =&gt; {
          <span class="org-rust-builtin-formatting-macro">eprintln!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string"> </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e, color_str);
          [127, 127, 127, 255]
        }
    };

    <span class="org-type">Color24BitRust</span> {
        <span class="org-variable-name">red</span>: vals[0],
        <span class="org-variable-name">green</span>: vals[1],
        <span class="org-variable-name">blue</span>: vals[2],
        <span class="org-variable-name">alpha</span>: vals[3],
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">_parse_color</span>(<span class="org-variable-name">color_str</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; [<span class="org-type">u8</span>; 4] {
    <span class="org-keyword">match</span> color_str.parse::&lt;<span class="org-type">Color</span>&gt;() {
        <span class="org-type">Ok</span>(color) =&gt; color.to_rgba8(),
        <span class="org-type">Err</span>(e) =&gt; {
          <span class="org-rust-builtin-formatting-macro">eprintln!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string"> </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e, color_str);
          [127, 127, 127, 255]
        }
    }
}

<span class="org-preprocessor">#[cfg(test)]</span>
<span class="org-keyword">mod</span> <span class="org-constant">test</span> {
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::*;

    <span class="org-preprocessor">#[test]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">test_parse_color</span>() {
        <span class="org-preprocessor">assert_eq!</span>(_parse_color(<span class="org-string">"#ff0000"</span>), [255, 0, 0, 255]);
        <span class="org-comment-delimiter">// </span><span class="org-comment">Invalid strings get parsed as grey.</span>
        <span class="org-preprocessor">assert_eq!</span>(_parse_color(<span class="org-string">""</span>), [127, 127, 127, 255]);
        <span class="org-preprocessor">assert_eq!</span>(_parse_color(<span class="org-string">"?"</span>), [127, 127, 127, 255]);
        <span class="org-preprocessor">assert_eq!</span>(_parse_color(<span class="org-string">"hello world"</span>), [127, 127, 127, 255]);
    }
}
</pre></div><div class="org-src-container"><pre class="src src-elixir" id="nil-23"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.Color</span> <span class="org-keyword">do</span>
  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-doc">"""</span>
<span class="org-doc">  Color parsing.</span>
<span class="org-doc">  """</span>

  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-keyword">def</span> <span class="org-function-name">parse</span>(color_str) <span class="org-keyword">do</span>
    {r, g, b, <span class="org-comment">_a</span>} = <span class="org-type">Melbyd.Nifs</span>.parse_color(color_str)
    {r, g, b}
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div>
</div>
</div>

<div id="outline-container-h-Entrypoint-for-client" class="outline-4">
<h4 id="h-Entrypoint-for-client"><span class="section-number-4">6.5.5.</span> Entrypoint for client</h4>
<div class="outline-text-4" id="text-h-Entrypoint-for-client">
<p>
This is where we start the Elixir program. There are lots of bits in here, but
the main thing we should care about for now is the <code>Melbyd.GRPC</code> module, which
acts as the entrypoint for clients using gRPC. The REST API is deprecated and
will be deleted in the future (to be replaced entirely with gRPC calls).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name"><code>Melbyd.Application</code></label><span class="lilac-caption-link-symbol"><a href="#code-Melbyd-Application--code">&#x1f517;</a></span></div><pre class="src src-elixir" id="code-Melbyd-Application--code"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.Application</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">See https://hexdocs.pm/elixir/Application.html</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">for more information on OTP Applications</span>
  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-elixir-atom">false</span>

  <span class="org-keyword">use</span> <span class="org-type">Application</span>
  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-elixir-attribute">@impl</span> <span class="org-elixir-atom">true</span>
  <span class="org-keyword">def</span> <span class="org-function-name">start</span>(<span class="org-comment">_type</span>, <span class="org-comment">_args</span>) <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Make sure the ~/.melby/tzdata directory exists.</span>
    <span class="org-type">File</span>.mkdir_p!(<span class="org-type">Path</span>.expand(<span class="org-string">"~/.melby/tzdata"</span>))

    <span class="org-variable-name">children</span> = [
      <span class="org-comment-delimiter"># </span><span class="org-comment">(model)</span>
      <span class="org-comment-delimiter">#</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Equivalent to {Melbyd.Cache.PathShorten, []} --- and now this module must</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">define its own child_spec(arg) function.</span>
      <span class="org-type">Melbyd.Cache.PathShorten</span>,

      <span class="org-comment-delimiter"># </span><span class="org-comment">Equivalent to {Task.Supervisor, [name: Melbyd.TaskSupervisor]}</span>
      {<span class="org-type">Task.Supervisor</span>, <span class="org-elixir-atom">name:</span> <span class="org-type">Melbyd.TaskSupervisor</span>},
      <span class="org-type">Melbyd.StandardResourceSupervisor</span>,
      <span class="org-type">Melbyd.ShellLoggerSupervisor</span>,

      <span class="org-comment-delimiter"># </span><span class="org-comment">Lua config validation cache</span>
      <span class="org-type">Melbyd.LuaConfigValidation</span>,

      <span class="org-comment-delimiter"># </span><span class="org-comment">PubSub messaging system. The "Melbyd.PubSub" here is just an atom, not an</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">actual Elixir Module. The sole purpose of it is to be a unique name,</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">from Phoenix.PubSub's perspective.</span>
      {<span class="org-type">Phoenix.PubSub</span>, <span class="org-elixir-atom">name:</span> <span class="org-type">Melbyd.PubSub</span>},

      <span class="org-comment-delimiter"># </span><span class="org-comment">gRPC service. (controller)</span>
      {<span class="org-type">GRPC.Server.Supervisor</span>,
       <span class="org-elixir-atom">endpoint:</span> <span class="org-type">Melbyd.GRPC</span>,
       <span class="org-elixir-atom">port:</span> <span class="org-type">Application</span>.get_env(<span class="org-elixir-atom">:melbyd</span>, <span class="org-elixir-atom">:melbyd_port</span>),
       <span class="org-elixir-atom">start_server:</span> <span class="org-elixir-atom">true</span>},

      <span class="org-comment-delimiter"># </span><span class="org-comment">Haskell "melbyr" service. (view)</span>
      <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_muontrap">melbyr_muontrap</a></span>
    ]

    <span class="org-comment-delimiter"># </span><span class="org-comment">See https://hexdocs.pm/elixir/Supervisor.html</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">for other strategies and supported options</span>
    <span class="org-variable-name">opts</span> = [<span class="org-elixir-atom">strategy:</span> <span class="org-elixir-atom">:one_for_one</span>, <span class="org-elixir-atom">name:</span> <span class="org-type">Melby.Supervisor</span>]

    announce()

    <span class="org-type">Supervisor</span>.start_link(children, opts)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Add ASCII-art here.</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">announce</span>() <span class="org-keyword">do</span>
    <span class="org-type">Logger</span>.info(<span class="org-string">"Starting application in </span><span class="org-variable-name">#{Application.fetch_env!(:melbyd, :env)}</span><span class="org-string"> environment"</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>

<div id="outline-container-h-melbyr-dependency" class="outline-5">
<h5 id="h-melbyr-dependency"><span class="section-number-5">6.5.5.1.</span> melbyr dependency</h5>
<div class="outline-text-5" id="text-h-melbyr-dependency">
<p>
Interacting with the view requires us to call into melbyr (Haskell server) from
Elixir. We need to
</p>

<ol class="org-ol">
<li>run the melbyr server, and</li>

<li>call its gRPC methods to interact with it.</li>
</ol>

<p>
The first part is guaranteed by using the <a href="https://github.com/fhunleth/muontrap">MuonTrap</a> library which handles running
OS processes reliably (restarting them if they crash). The second part is
handled by the Melbyd Lua SDK, where the call path goes from the user-provided
Lua, to Elixir, then finally to melbyr (Haskell) via gRPC.
</p>

<p>
The <code>stderr_to_stdout: true</code> redirects the stderr messages (which the Haskell
binary uses for printing logs) to stdout, and the <code>log_output: :debug</code> forwards
all stdout to the <code>Logger</code>. The disadvantage is that this forwarding to <code>Logger</code>
is done piecemeal in 256-byte chunks at a time (probably for performance
reasons), so any logs longer than 256 characters get chopped up into multiple
<code>Logger</code> messages. But the advantage is that we can control the log output
behavior of the Haskell binary during integration tests (to silence all Logger
output for passing tests, as per
<a href="https://hashrocket.com/blog/posts/silence-logger-messages-in-exunit">https://hashrocket.com/blog/posts/silence-logger-messages-in-exunit</a>).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#code-Melbyd-Application--code">melbyr_muontrap</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_muontrap">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyr_muontrap">{<span class="org-type">MuonTrap.Daemon</span>,
 [<span class="org-type">Application</span>.get_env(<span class="org-elixir-atom">:melbyd</span>, <span class="org-elixir-atom">:melbyr_path</span>),
  [<span class="org-string">"serve"</span>, <span class="org-string">"</span><span class="org-variable-name">#{Application.get_env(:melbyd, :melbyr_port)}</span><span class="org-string">"</span>],
 <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Make this more verbose output an environment variable option.</span>
 <span class="org-comment-delimiter">#</span><span class="org-comment">[stderr_to_stdout: true, log_output: :debug]]},</span>
 [<span class="org-elixir-atom">stderr_to_stdout:</span> <span class="org-elixir-atom">false</span>]]},
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-gRPC-services" class="outline-4">
<h4 id="h-gRPC-services"><span class="section-number-4">6.5.6.</span> gRPC services</h4>
<div class="outline-text-4" id="text-h-gRPC-services">
<p>
The most important way of interaction between the client and melbyd is the
<code>GetView</code> RPC method (FIXME: add link). This method takes in a Lua script, which
will be responsible for both collecting the necessary data and arranging it to
generate the view. So we let the client decide what to collect and display.
</p>

<p>
We serve clients through gRPC services. If you look at the proto file (FIXME:
add link), there is a single View service.
</p>

<p>
The View service is shown below.
</p>

<div class="org-src-container"><pre class="src src-elixir" id="nil-24"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.GRPC</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">GRPC.Endpoint</span>

  intercept <span class="org-type">GRPC.Server.Interceptors.Logger</span>, <span class="org-elixir-atom">level:</span> <span class="org-elixir-atom">:info</span>

  run <span class="org-type">Melbyd.View.Service</span>
<span class="org-keyword">end</span>

<span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.View.Service</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">GRPC.Server</span>, <span class="org-elixir-atom">service:</span> <span class="org-type">MelbyClient.View.Service</span>, <span class="org-elixir-atom">compressors:</span> [<span class="org-type">GRPC.Compressor.Gzip</span>]

  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-doc">"""</span>
<span class="org-doc">  Legacy.</span>
<span class="org-doc">  """</span>

  <span class="org-elixir-attribute">@doc</span> <span class="org-doc">"""</span>
<span class="org-doc">  Retrieves the prompt.</span>
<span class="org-doc">  """</span>
  <span class="org-elixir-attribute">@spec</span> get_view(<span class="org-type">MelbyClient.ViewRequest</span>.t(), <span class="org-type">GRPC.Server.Stream</span>.t()) ::
          <span class="org-type">MelbyClient.ViewResponse</span>.t()
  <span class="org-keyword">def</span> <span class="org-function-name">get_view</span>(req, <span class="org-comment">_stream</span>) <span class="org-keyword">do</span>
    <span class="org-type">Melbyd.View</span>.generate(req)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div><p>
Notice that we define the top-level <code>Melbyd.Endpont</code> module, which contains the
<code>View</code> service.
</p>
</div>

<div id="outline-container-h-View--melbyr-interface" class="outline-5">
<h5 id="h-View--melbyr-interface"><span class="section-number-5">6.5.6.1.</span> View (melbyr interface)</h5>
<div class="outline-text-5" id="text-h-View--melbyr-interface">
<p>
Below is <code>melby-client</code>'s <code>ViewRequest</code> that we handle. As part of handling this,
we will need to call out to the melbyr Haskell server over gRPC.
</p>

<div class="org-src-container"><pre class="src src-elixir" id="nil-25"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.View</span> <span class="org-keyword">do</span>
  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-doc">"""</span>
<span class="org-doc">  Module to generate an arbitrary view (string).</span>
<span class="org-doc">  """</span>

  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-keyword">def</span> <span class="org-function-name">generate</span>(req) <span class="org-keyword">do</span>
    <span class="org-variable-name">config_path</span> = req.config_path
    <span class="org-variable-name">env_vars</span> = req.env_vars
    <span class="org-variable-name">shell_pid</span> = req.shell_pid

    <span class="org-type">Logger</span>.info(<span class="org-string">"interpreting config </span><span class="org-variable-name">#{inspect(config_path)}</span><span class="org-string">"</span>)
    <span class="org-type">Logger</span>.info(<span class="org-string">"MELBY_DIR is </span><span class="org-variable-name">#{inspect(env_vars["MELBY_DIR"])}</span><span class="org-string">"</span>)

    <span class="org-keyword">with</span> <span class="org-elixir-atom">:ok</span> <span class="org-keyword">&lt;-</span> validate(config_path, env_vars, shell_pid),
         {<span class="org-elixir-atom">:ok</span>, view_params_types} <span class="org-keyword">&lt;-</span> <span class="org-type">Melbyd.LuaConfigValidation</span>.validate(config_path),
         {<span class="org-elixir-atom">:ok</span>, env_vars_reduced} <span class="org-keyword">&lt;-</span> <span class="org-type">Melbyd.LuaConfigValidation</span>.enforce_view_params_types(view_params_types, env_vars),
         {<span class="org-elixir-atom">:ok</span>, val} <span class="org-keyword">when</span> is_list(val) <span class="org-keyword">and</span> val != [] <span class="org-keyword">and</span> is_binary(hd(val)) <span class="org-keyword">&lt;-</span>
           <span class="org-type">Melbyd.LuaInterop</span>.run(config_path, [<span class="org-string">"Config"</span>, <span class="org-string">"view"</span>], [env_vars_reduced, shell_pid]) <span class="org-keyword">do</span>
      [view] = val

      <span class="org-type">%MelbyClient.ViewResponse</span>{
        <span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:VIEW_STATUS_OK</span>,
        <span class="org-elixir-atom">view:</span> view
      }
    <span class="org-keyword">else</span>
      {<span class="org-elixir-atom">:error</span>, reason} <span class="org-keyword">-&gt;</span>
        <span class="org-type">%MelbyClient.ViewResponse</span>{
          <span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:VIEW_STATUS_ERROR</span>,
          <span class="org-elixir-atom">error:</span> <span class="org-type">IO</span>.inspect(reason)
        }

      unrecognized <span class="org-keyword">-&gt;</span>
        <span class="org-type">%MelbyClient.ViewResponse</span>{
          <span class="org-elixir-atom">status:</span> <span class="org-elixir-atom">:VIEW_STATUS_ERROR</span>,
          <span class="org-elixir-atom">error:</span> <span class="org-string">"backend returned an unrecognized response: </span><span class="org-variable-name">#{inspect(unrecognized)}</span><span class="org-string">"</span>
        }
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Perform some rudimentary validation.</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Is this even worth it?</span>
  <span class="org-keyword">def</span> <span class="org-function-name">validate</span>(config_path, <span class="org-comment">_env_vars</span>, shell_pid) <span class="org-keyword">do</span>
    <span class="org-keyword">cond</span> <span class="org-keyword">do</span>
      !File.exists?(config_path) <span class="org-keyword">-&gt;</span>
        {<span class="org-elixir-atom">:error</span>, <span class="org-string">"file </span><span class="org-variable-name">#{config_path}</span><span class="org-string"> does not exist"</span>}

      <span class="org-type">String</span>.length(shell_pid) == <span class="org-elixir-number">0</span> <span class="org-keyword">-&gt;</span>
        {<span class="org-elixir-atom">:error</span>, <span class="org-string">"shell_pid cannot be an empty string"</span>}

      !String.match?(shell_pid, <span class="org-builtin">~r</span>/<span class="org-string">^[[:digit:]]+$</span>/) <span class="org-keyword">-&gt;</span>
        {<span class="org-elixir-atom">:error</span>, <span class="org-string">"shell_pid '</span><span class="org-variable-name">#{shell_pid}</span><span class="org-string">' has non-digit characters in it"</span>}

      <span class="org-elixir-atom">true</span> <span class="org-keyword">-&gt;</span>
        <span class="org-elixir-atom">:ok</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div>
</div>
</div>

<div id="outline-container-h-Standard-Resource-Service" class="outline-5">
<h5 id="h-Standard-Resource-Service"><span class="section-number-5">6.5.6.2.</span> Standard Resource Service</h5>
<div class="outline-text-5" id="text-h-Standard-Resource-Service">
<p>
The Standard Resource Service (SRS) is a general-purpose Elixir GenServer with a
notion of history of previous states. The two main selling points are:
</p>

<ol class="org-ol">
<li>it can be used to implement the Kubernetes controller pattern (FIXME:
insert link); and</li>

<li>unlike typical Elixir GenServers, it can be configured at runtime with Lua.</li>
</ol>

<p>
SRS was designed to solve the problem of long-running shell commands that are
long enough to be annoying but short enough that little effort has gone into
making the command run any faster, and where the output of the command doesn't
change that frequently. A good example is a "git status" command that takes 2 or
3 seconds or longer for large repositories. Another example might be calculating
the disk space usage of a particularly large folder with many files in it. SRS
allows users to encode these expensive shell commands into an Elixir GenServer
(a long-lived, lightweight thread that stores state), such that the output is
cached and only invalidated (and recomputed) based on user-defined conditions.
These user-defined conditions can be arbitrary, but SRS comes with some standard
ones such as file modification events. Other event producers are possible, such
as ones over the network (e.g., email inbox, pub-sub events, etc).
</p>
</div>

<div id="outline-container-h-Motivation" class="outline-6">
<h6 id="h-Motivation"><span class="section-number-6">6.5.6.2.1.</span> Motivation</h6>
<div class="outline-text-6" id="text-h-Motivation">
<p>
The original motivation behind SRS was the realization that most of the
functionality of the GitWatcher system was not unique to it and could be
generalized beyond just <code>git</code>.
</p>

<p>
A secondary motivation is that this enables using melbyc to create other
SRS-backed Resources at runtime (just like <code>kubectl apply -f ...</code>), and also
naturally lends itself to more introspection (we should be able to do <code>melbyc get
RESOURCE foo</code> just like how we can do <code>kubectl get RESOURCE</code>).
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-h-Lua-API" class="outline-4">
<h4 id="h-Lua-API"><span class="section-number-4">6.5.7.</span> Lua API</h4>
<div class="outline-text-4" id="text-h-Lua-API">
<p>
We provide a Lua API for <code>melbyc</code> (our users) because we want to make it easy to
configure advanced functionality for generating the prompt. There are 3 modules
here:
</p>

<dl class="org-dl">
<div class="lilac-description-list-entry"><dt><code>Melbyd.LuaInterop</code></dt><dd>Expose Lua capability to the rest of melbyd</dd></div>

<div class="lilac-description-list-entry"><dt><code>Melbyd.LuaSdk</code></dt><dd>Autoloaded "Melbyd Lua SDK"</dd></div>

<div class="lilac-description-list-entry"><dt><code>Melbyd.LuaSdkAutoload</code></dt><dd>Boilerplate to make <code>Melbyd.LuaSdk</code> easier to write.
Defines a behaviour that can be implemented by any other Elixir module that
wants to be exposed to the Lua environment.</dd></div>
</dl>
</div>

<div id="outline-container-h-Melbyd-LuaInterop" class="outline-5">
<h5 id="h-Melbyd-LuaInterop"><span class="section-number-5">6.5.7.1.</span> <code>Melbyd.LuaInterop</code></h5>
<div class="outline-text-5" id="text-h-Melbyd-LuaInterop">
<p>
This module extends Melbyd with Lua. It is able to read and execute Lua (5.2)
scripts. The Melbyd "API" is exposed to the script with the <code>def_lua_func</code> macro,
where we define an Elixir function to expose to the Lua code. The Elixir
functions are much more powerful than the Lua functions that the user can
define, because they have full access to all of the rest of Melbyd. All of the
Elixir functions are exposed under the "melbyd" Lua table (see <code>run_file/1</code>).
</p>

<p>
Practically speaking, this module is meant to allow users to configure the
output of melbyc. That is, users pass in a Lua script location to melbyc, and that
script gets executed here, and finally the result of that script is returned to
melbyc.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name"><code>Melbyd.LuaInterop</code></label><span class="lilac-caption-link-symbol"><a href="#code-Melbyd-LuaInterop--code">&#x1f517;</a></span></div><pre class="src src-elixir" id="code-Melbyd-LuaInterop--code"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.LuaInterop</span> <span class="org-keyword">do</span>
  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-elixir-atom">false</span>

  <span class="org-keyword">def</span> <span class="org-function-name">run</span>(lua_file, func_path, func_args) <span class="org-keyword">do</span>
    <span class="org-keyword">with</span> {<span class="org-elixir-atom">:ok</span>, <span class="org-constant">_</span>, st} <span class="org-keyword">&lt;-</span> run_file(lua_file),
         {res, <span class="org-comment">_st</span>} <span class="org-keyword">&lt;-</span> <span class="org-type">Luerl</span>.call_function(st, func_path, func_args) <span class="org-keyword">do</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Now that we have the Lua state with all custom callback functions loaded</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">inside it (as well as calls to our Elixir Melbyd SDK), we can piece</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">together what the user wants.</span>
      {<span class="org-elixir-atom">:ok</span>, res}
    <span class="org-keyword">else</span>
      reason <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"</span><span class="org-variable-name">#{inspect(reason)}</span><span class="org-string">"</span>}
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">run_file</span>(lua_file) <span class="org-keyword">do</span>
    <span class="org-keyword">with</span> st0 <span class="org-keyword">&lt;-</span> <span class="org-type">Luerl</span>.init(),
         <span class="org-comment-delimiter"># </span><span class="org-comment">Expose Melbyd API functions (everything inside Melbyd.LuaSdk).</span>
         st1 <span class="org-keyword">&lt;-</span> <span class="org-type">Luerl</span>.load_module(st0, [<span class="org-string">"melbyd"</span>], <span class="org-type">Melbyd.LuaSdk</span>),
         <span class="org-comment-delimiter"># </span><span class="org-comment">We must run "dofile" because otherwise nothing is loaded. That is, if</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">the Lua file has "function ... end" definitions and nothing else, the</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">only way to load these functions is to run Luerl.dofile/1 here. If we</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">use Luerl.loadfile/1 instead, the custom Lua functions are not loaded</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">into the state.</span>
         {res, st2} <span class="org-keyword">&lt;-</span> <span class="org-type">Luerl</span>.dofile(st1, <span class="org-type">String</span>.to_charlist(lua_file)) <span class="org-keyword">do</span>
      {<span class="org-elixir-atom">:ok</span>, res, st2}
    <span class="org-keyword">else</span>
      reason <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"</span><span class="org-variable-name">#{inspect(reason)}</span><span class="org-string">"</span>}
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_lua_config_validation">melbyd_lua_config_validation</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdkhelper">melbyd_luasdkhelper</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luerl_util">melbyd_luerl_util</a></span>
</pre></div></div>
</div>

<div id="outline-container-h-Validation" class="outline-6">
<h6 id="h-Validation"><span class="section-number-6">6.5.7.1.1.</span> Validation</h6>
<div class="outline-text-6" id="text-h-Validation">
<p>
Validation of a user's Lua configuration involves running the bulk of the given
configuration, but through a special, modified Lua SDK environment where all
inputs to the configuration are controlled.
</p>

<p>
The steps involved are roughly:
</p>

<ol class="org-ol">
<li>Modify the SRS reader functions to read the "fake" fixture data that are
part of each SRS's definition</li>

<li>Run the "Config.view" function, using a set of fake environment variables</li>

<li>Check that the result from step 2 contains some substrings we expect to get
(also defined in the Lua config).</li>

<li>Repeat steps 2 and 3 for each "Config.view_tests" entry defined in the Lua
config.</li>
</ol>

<p>
When the above steps are being executed, purely for validation, we don't expect
any of the resulting side effects to interfere with the real side effects of
interpreting the Lua configuration for production. This is important because as
a matter of principle, the test and production environments should never have
any overlap.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#code-Melbyd-LuaInterop--code">melbyd_lua_config_validation</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_lua_config_validation">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_lua_config_validation"><span class="org-keyword">import</span> <span class="org-type">Cachex.Spec</span>

<span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.LuaConfigValidation</span> <span class="org-keyword">do</span>
  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Add Cachex lookup to see if this config was validated previously. We</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">should add this lookup after we've implemented the validation functionality</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">completely.</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: (For caching) We should require env vars (which we use) to be</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">declared ahead of time, and hash the *names* of these env vars (not their</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">contents) as required inputs (you can think of them as types) to a function</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">(this Lua config). And then if the config does not declare this list of env</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">vars, we can refuse to validate it. This way we capture the exact "function</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">definition", so to speak, of the Lua config by precisely describing its</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">definition.</span>
  <span class="org-keyword">def</span> <span class="org-function-name">validate</span>(lua_file) <span class="org-keyword">do</span>
    <span class="org-keyword">with</span> st0 <span class="org-keyword">&lt;-</span> <span class="org-type">Luerl</span>.init(),
         st1 <span class="org-keyword">&lt;-</span> <span class="org-type">Luerl</span>.load_module(st0, [<span class="org-string">"melbyd"</span>], <span class="org-type">Melbyd.LuaSdk</span>),
         <span class="org-comment-delimiter"># </span><span class="org-comment">Overwrite "read_standard_resource" with the fake version. Note that</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">this __handle_lua_call__... function is defined by the def_lua_func</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">macro for the "read_standard_resource_fake" function. We have to use</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">Luerl.set_table1/3 (with the tuple form of {:erl_func, func_ref}) and</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">not Luerl.set_table/3 (which we can use with just the func_ref alone</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">as the 3rd argument --- this passes compilation), because we already</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">perform encoding back for Luerl inside all __handle_lua_call__...</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">functions. Otherwise we would be encoding twice.</span>
         st2 <span class="org-keyword">&lt;-</span>
           <span class="org-type">Luerl</span>.set_table1(
             st1,
             [<span class="org-string">"melbyd"</span>, <span class="org-string">"read_standard_resource"</span>],
             {<span class="org-elixir-atom">:erl_func</span>, <span class="org-type">&amp;Melbyd.LuaSdk.__handle_lua_call__read_standard_resource_fake</span>/<span class="org-elixir-number">2</span>}
           ),
         <span class="org-comment-delimiter"># </span><span class="org-comment">Overwrite the "get_path_aliases" function to use the contents of the</span>
         <span class="org-comment-delimiter"># </span><span class="org-comment">variable directly (instead of doing I/O to read the given path).</span>
         st3 <span class="org-keyword">&lt;-</span>
           <span class="org-type">Luerl</span>.set_table1(
             st2,
             [<span class="org-string">"melbyd"</span>, <span class="org-string">"get_path_aliases"</span>],
             {<span class="org-elixir-atom">:erl_func</span>, <span class="org-type">&amp;Melbyd.LuaSdk.__handle_lua_call__get_path_aliases_fake</span>/<span class="org-elixir-number">2</span>}
           ),
         {<span class="org-constant">_</span>, st4} <span class="org-keyword">&lt;-</span> <span class="org-type">Luerl</span>.dofile(st3, <span class="org-type">String</span>.to_charlist(lua_file)),
         vm_fingerprint <span class="org-keyword">&lt;-</span> get_vm_fingerprint(st4),
         {res, view_params_types} <span class="org-keyword">&lt;-</span>
           <span class="org-type">Cachex</span>.fetch(<span class="org-elixir-atom">:lua_config_validation_cache</span>, {lua_file, vm_fingerprint}) <span class="org-keyword">do</span>
      <span class="org-keyword">case</span> res <span class="org-keyword">do</span>
        <span class="org-elixir-atom">:ok</span> <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:ok</span>, view_params_types}
        <span class="org-elixir-atom">:commit</span> <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:ok</span>, view_params_types}
        <span class="org-elixir-atom">:ignore</span> <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"failed cache key validation"</span>}
        <span class="org-elixir-atom">:error</span> <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"failed cache key validation2"</span>}
      <span class="org-keyword">end</span>
    <span class="org-keyword">else</span>
      e <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, e}
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Return the blank state of the initial Lua VM state meant for validation</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">purposes only.</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Add a fake for SLG also? And also delete it when we're done with</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">validation?</span>
  <span class="org-keyword">def</span> <span class="org-function-name">preloaded_fake_lua_vm</span>() <span class="org-keyword">do</span>
    <span class="org-type">Luerl</span>.init()
    <span class="org-keyword">|&gt;</span> <span class="org-type">Luerl</span>.load_module([<span class="org-string">"melbyd"</span>], <span class="org-type">Melbyd.LuaSdk</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Overwrite "read_standard_resource" with the fake version. Note that this</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">__handle_lua_call__... function is defined by the def_lua_func macro for</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">the "read_standard_resource_fake" function. We have to use</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Luerl.set_table1/3 (with the tuple form of {:erl_func, func_ref}) and not</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Luerl.set_table/3 (which we can use with just the func_ref alone as the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">3rd argument --- this passes compilation), because we already perform</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">encoding back for Luerl inside all __handle_lua_call__... functions.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Otherwise we would be encoding twice.</span>
    <span class="org-keyword">|&gt;</span> <span class="org-type">Luerl</span>.set_table1(
      [<span class="org-string">"melbyd"</span>, <span class="org-string">"read_standard_resource"</span>],
      {<span class="org-elixir-atom">:erl_func</span>, <span class="org-type">&amp;Melbyd.LuaSdk.__handle_lua_call__read_standard_resource_fake</span>/<span class="org-elixir-number">2</span>}
    )
    <span class="org-comment-delimiter"># </span><span class="org-comment">Overwrite the "get_path_aliases" function to use the contents of the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">variable directly (instead of doing I/O to read the given path).</span>
    <span class="org-keyword">|&gt;</span> <span class="org-type">Luerl</span>.set_table1(
      [<span class="org-string">"melbyd"</span>, <span class="org-string">"get_path_aliases"</span>],
      {<span class="org-elixir-atom">:erl_func</span>, <span class="org-type">&amp;Melbyd.LuaSdk.__handle_lua_call__get_path_aliases_fake</span>/<span class="org-elixir-number">2</span>}
    )
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">validate_key</span>({lua_file, vm_fingerprint}, preloaded_fake_lua_vm) <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">We already declare the env var names we want to use in</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">our config, so we don't actually need the env_vars at all to be part of</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">the cache key..! So just</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">reading the lua_file (which itself declares the exact env vars we need) is</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">enough.</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">For deletion of the side effects (SRS, etc) generated via validation, the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">strategy is to use the vm_fingerprint. We store the fingerprint inside the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Lua VM state. Then when the fake versions of read_standard_resource are</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">called, they save this vm_fingerprint as part of their ID. Then we call a</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">"cleanup side effects" function directly right here with the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">vm_fingerprint. Then this cleanup function broadcasts a shutdown message</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">to all resources with this vm_fingerprint. We have to only delete the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">fakes that were generated as part of validing this particular</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">vm_fingerprint, because otherwise we would be deleting other resources</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">that might be in the middle of validating a different Lua config.</span>
    <span class="org-keyword">with</span> {<span class="org-constant">_</span>, st1} <span class="org-keyword">&lt;-</span> <span class="org-type">Luerl</span>.dofile(preloaded_fake_lua_vm, <span class="org-type">String</span>.to_charlist(lua_file)),
         view_params_types <span class="org-keyword">&lt;-</span> get_view_params_types(st1),
         <span class="org-elixir-atom">:ok</span> <span class="org-keyword">&lt;-</span> assert_expected_views(st1, view_params_types, vm_fingerprint) <span class="org-keyword">do</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Maybe store some more useful metrics beyond just</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">"view_params_types". E.g., the number of test cases executed, how long</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">it took to run it (at what time), etc.</span>
      {<span class="org-elixir-atom">:commit</span>, view_params_types}
    <span class="org-keyword">else</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">If there's any error, abort and return nil.</span>
      err <span class="org-keyword">-&gt;</span>
        <span class="org-type">Logger</span>.warning(<span class="org-string">"got error: </span><span class="org-variable-name">#{inspect(err)}</span><span class="org-string">"</span>)
        {<span class="org-elixir-atom">:ignore</span>, <span class="org-elixir-atom">nil</span>}
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">This checks the types of the actual env_vars from the real environment.</span>
  <span class="org-keyword">def</span> <span class="org-function-name">get_view_params_types</span>(st0) <span class="org-keyword">do</span>
    {view_params_types_tuples, <span class="org-comment">_st</span>} = <span class="org-type">Luerl</span>.get_table(st0, [<span class="org-string">"Config"</span>, <span class="org-string">"view_params_types"</span>])

    <span class="org-variable-name">view_params_types</span> =
      view_params_types_tuples
      <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()

    <span class="org-type">Map</span>.put(
      view_params_types,
      <span class="org-string">"env"</span>,
      view_params_types[<span class="org-string">"env"</span>]
      <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()
    )
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">enforce_view_params_types</span>(view_params_types, env_vars) <span class="org-keyword">do</span>
    <span class="org-variable-name">errors</span> =
      <span class="org-type">Enum</span>.reduce(view_params_types[<span class="org-string">"env"</span>], [], <span class="org-keyword">fn</span> {name, type_array}, errors <span class="org-keyword">-&gt;</span>
        [req_or_opt, type] =
          type_array
          <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list()

        <span class="org-variable-name">required</span> = req_or_opt == <span class="org-string">"required"</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Check vals of real env_vars.</span>
        <span class="org-keyword">case</span> assert_env_var_type(env_vars, name, required, type) <span class="org-keyword">do</span>
          <span class="org-elixir-atom">:ok</span> <span class="org-keyword">-&gt;</span> errors
          {<span class="org-elixir-atom">:error</span>, reason} <span class="org-keyword">-&gt;</span> [<span class="org-string">"</span><span class="org-variable-name">#{name}</span><span class="org-string">: "</span> &lt;&gt; reason | errors]
        <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>)

    <span class="org-keyword">if</span> errors == [] <span class="org-keyword">do</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Reduce the env_vars map to only include the env_vars listed in view_params_types.</span>
      <span class="org-variable-name">env_vars_reduced</span> =
        <span class="org-type">Enum</span>.reduce(env_vars, %{}, <span class="org-keyword">fn</span> {k, <span class="org-constant">_</span>}, env_vars_reduced <span class="org-keyword">-&gt;</span>
          <span class="org-variable-name">val</span> = <span class="org-type">Map</span>.fetch!(env_vars, k)
          <span class="org-type">Map</span>.put(env_vars_reduced, k, val)
        <span class="org-keyword">end</span>)

      {<span class="org-elixir-atom">:ok</span>, env_vars_reduced}
    <span class="org-keyword">else</span>
      {<span class="org-elixir-atom">:error</span>, <span class="org-type">Enum</span>.join(errors, <span class="org-string">"\n"</span>)}
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">assert_env_var_type</span>(env_vars, name, required, type) <span class="org-keyword">do</span>
    <span class="org-keyword">with</span> {<span class="org-elixir-atom">:ok</span>, val} <span class="org-keyword">&lt;-</span> <span class="org-type">Map</span>.fetch(env_vars, name),
         <span class="org-elixir-atom">:ok</span> <span class="org-keyword">&lt;-</span> assert_maybe_required(name, val, required) <span class="org-keyword">do</span>
      <span class="org-keyword">case</span> type <span class="org-keyword">do</span>
        <span class="org-string">"path"</span> <span class="org-keyword">-&gt;</span>
          assert_type_path(val)

        <span class="org-string">"paths"</span> <span class="org-keyword">-&gt;</span>
          assert_type_paths(val)

        <span class="org-comment-delimiter"># </span><span class="org-comment">The contents of a file can be anything (any sequence of bytes), so</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">it's always well-formed.</span>
        <span class="org-string">"pathblob"</span> <span class="org-keyword">-&gt;</span>
          <span class="org-elixir-atom">:ok</span>

        <span class="org-string">"int"</span> <span class="org-keyword">-&gt;</span>
          assert_type_int(val, <span class="org-elixir-atom">false</span>)

        <span class="org-string">"uint"</span> <span class="org-keyword">-&gt;</span>
          assert_type_int(val, <span class="org-elixir-atom">true</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Expect the string to be composed of at least 1 non-whitespace character.</span>
        <span class="org-string">"string"</span> <span class="org-keyword">-&gt;</span>
          <span class="org-keyword">if</span> <span class="org-type">String</span>.trim(val) == <span class="org-string">""</span> <span class="org-keyword">do</span>
            {<span class="org-elixir-atom">:error</span>, <span class="org-string">"string must have at least 1 non-whitespace character"</span>}
          <span class="org-keyword">else</span>
            <span class="org-elixir-atom">:ok</span>
          <span class="org-keyword">end</span>

        t <span class="org-keyword">-&gt;</span>
          {<span class="org-elixir-atom">:error</span>, <span class="org-string">"unrecognized type </span><span class="org-variable-name">#{t}</span><span class="org-string">"</span>}
      <span class="org-keyword">end</span>
    <span class="org-keyword">else</span>
      err <span class="org-keyword">-&gt;</span>
        <span class="org-keyword">case</span> err <span class="org-keyword">do</span>
          <span class="org-elixir-atom">:error</span> <span class="org-keyword">-&gt;</span>
            <span class="org-keyword">if</span> required <span class="org-keyword">do</span>
              {<span class="org-elixir-atom">:error</span>, <span class="org-string">"env var </span><span class="org-variable-name">#{name}</span><span class="org-string"> required but does not exist"</span>}
            <span class="org-keyword">else</span>
              <span class="org-elixir-atom">:ok</span>
            <span class="org-keyword">end</span>

          e <span class="org-keyword">-&gt;</span>
            {<span class="org-elixir-atom">:error</span>, <span class="org-string">"urecognized error </span><span class="org-variable-name">#{inspect(e)}</span><span class="org-string">"</span>}
        <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">assert_maybe_required</span>(name, val, required) <span class="org-keyword">do</span>
    <span class="org-keyword">if</span> required <span class="org-keyword">do</span>
      <span class="org-keyword">if</span> <span class="org-type">String</span>.length(val) == <span class="org-elixir-number">0</span> <span class="org-keyword">do</span>
        {<span class="org-elixir-atom">:error</span>, <span class="org-string">"env var </span><span class="org-variable-name">#{name}</span><span class="org-string"> is required, but it is set to the empty string"</span>}
      <span class="org-keyword">else</span>
        <span class="org-elixir-atom">:ok</span>
      <span class="org-keyword">end</span>
    <span class="org-keyword">else</span>
      <span class="org-elixir-atom">:ok</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">assert_type_int</span>(maybe_int, unsigned) <span class="org-keyword">do</span>
    <span class="org-keyword">try</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">int</span> = <span class="org-type">String</span>.to_integer(maybe_int)

      <span class="org-keyword">if</span> unsigned <span class="org-keyword">do</span>
        <span class="org-keyword">if</span> int &lt; <span class="org-elixir-number">0</span> <span class="org-keyword">do</span>
          {<span class="org-elixir-atom">:error</span>, <span class="org-string">"not a uint: </span><span class="org-variable-name">#{maybe_int}</span><span class="org-string"> is negative"</span>}
        <span class="org-keyword">else</span>
          <span class="org-elixir-atom">:ok</span>
        <span class="org-keyword">end</span>
      <span class="org-keyword">else</span>
        <span class="org-elixir-atom">:ok</span>
      <span class="org-keyword">end</span>
    <span class="org-keyword">rescue</span>
      e <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"not an integer: </span><span class="org-variable-name">#{maybe_int}</span><span class="org-string">: </span><span class="org-variable-name">#{Exception.message(e)}</span><span class="org-string">"</span>}
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">assert_type_path</span>(path) <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: use haskell parsec to do a full parse</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Use a basic heuristic. Assert that the first character starts with a slash</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">"/", that the last character is not a slash, and that there are no runs of</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">consecutive slashes. No null bytes. Last character cannot  be "." (this</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">includes the case where the last 2 characters are ".").</span>

    <span class="org-keyword">cond</span> <span class="org-keyword">do</span>
      <span class="org-type">String</span>.length(path) == <span class="org-elixir-number">0</span> <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"cannot be empty"</span>}
      <span class="org-type">String</span>.first(path) != <span class="org-string">"/"</span> <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"first character must be a slash"</span>}
      <span class="org-type">String</span>.last(path) == <span class="org-string">"/"</span> <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"last character cannot be a slash"</span>}
      <span class="org-type">String</span>.last(path) == <span class="org-string">"."</span> <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"last character cannot be a dot"</span>}
      <span class="org-type">String</span>.contains?(path, <span class="org-string">"//"</span>) <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"consecutive slashes are forbidden"</span>}
      <span class="org-type">String</span>.contains?(path, <span class="org-string">"\0"</span>) <span class="org-keyword">-&gt;</span> {<span class="org-elixir-atom">:error</span>, <span class="org-string">"cannot contain a null byte"</span>}
      <span class="org-elixir-atom">true</span> <span class="org-keyword">-&gt;</span> <span class="org-elixir-atom">:ok</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">assert_type_paths</span>(paths) <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: use haskell parsec to do a full parse</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Use a basic heuristic. Assert that the first character starts with a slash</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">"/", that the last character is not a slash, and that there are no runs of</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">consecutive slashes. No null bytes. Last character cannot  be "." (this</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">includes the case where the last 2 characters are ".").</span>

    <span class="org-variable-name">error_reasons</span> =
      <span class="org-type">String</span>.split(paths, <span class="org-string">":"</span>)
      <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.reduce([], <span class="org-keyword">fn</span> path, error_reasons <span class="org-keyword">-&gt;</span>
        <span class="org-keyword">case</span> assert_type_path(path) <span class="org-keyword">do</span>
          {<span class="org-elixir-atom">:error</span>, reason} <span class="org-keyword">-&gt;</span> [reason | error_reasons]
          <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span> error_reasons
        <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>)

    <span class="org-keyword">if</span> error_reasons == [] <span class="org-keyword">do</span>
      <span class="org-elixir-atom">:ok</span>
    <span class="org-keyword">else</span>
      {<span class="org-elixir-atom">:error</span>, error_reasons}
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Each of the SRS models have a "fake" field with faked readers in it</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">(which return plausible, well-formatted data). We just have to use them</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">somehow.</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">We can make this fake tick runner just run the ["Config", "view"] function</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">in the Lua state, wait 1 second, check the result and compare it to the</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">expectation, and repeat. The expectations can come from the config file</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">itself (add it under another key path). The behind the scenes the</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">StandardResource should behave almost like in prod, but with the difference</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">that it'll run the fake readers instead of the actual readers, as well as</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">provision the SRS GenServer in a different namespace so as not to clash with</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">the production resources.</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">The config should tell us how many "ticks" and corresponding expectations to</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">run. We could enforce a minimum of 3 rounds from our side (i.e., fail</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">validation if the user has not configured at lesat 3 rounds of</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">expectations).</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Each iteration should be:</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter">#     </span><span class="org-comment">1. Execute ["Config", "view"] function in the Lua VM state (time_idx is 1).</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter">#     </span><span class="org-comment">2. Expectation: check expected return value of the above versus what we</span>
  <span class="org-comment-delimiter">#     </span><span class="org-comment">actually got (got vs want).</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter">#     </span><span class="org-comment">3. Increment time_idx by 1, and re-run step 1. Continue until time_idx</span>
  <span class="org-comment-delimiter">#     </span><span class="org-comment">== 10 or some other number.</span>
  <span class="org-keyword">def</span> <span class="org-function-name">assert_expected_views</span>(st0, view_params_types, vm_fingerprint) <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Set the vm_fingerprint inside the Lua VM, so that the fake Lua SDK</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">functions can use them to pass them on to Elixir.</span>
    <span class="org-variable-name">st1</span> = <span class="org-type">Luerl</span>.set_table1(st0, [<span class="org-string">"melbyd"</span>, <span class="org-string">"vm_fingerprint"</span>], vm_fingerprint)

    <span class="org-comment-delimiter"># </span><span class="org-comment">'expectations' is a list of list of substrings we need to match after</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">calling ["Config", "view"].</span>
    {view_tests_tuples, <span class="org-comment">_st</span>} = <span class="org-type">Luerl</span>.get_table(st1, [<span class="org-string">"Config"</span>, <span class="org-string">"view_tests"</span>])

    <span class="org-variable-name">view_tests</span> =
      view_tests_tuples
      <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list()
      <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-type">&amp;Melbyd.LuerlUtil</span>.table_to_native_map/<span class="org-elixir-number">1</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">For each expectation in the expectations, run the Config.view() function.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Because we are running fake resources, the read() call will be synchronous</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">and force a re-read, incrementing the :read field in every SRS each time.</span>
    <span class="org-variable-name">errors</span> =
      <span class="org-type">Enum</span>.reduce(view_tests, [], <span class="org-keyword">fn</span> view_test, errors <span class="org-keyword">-&gt;</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check vals of fake env_vars in view_tests.</span>
        <span class="org-variable-name">env_vars_fake</span> = view_test[<span class="org-string">"env"</span>] <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()

        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: dedupe this logic (copied from enforce_view_params_types)</span>
        <span class="org-variable-name">type_errors</span> =
          <span class="org-type">Enum</span>.reduce(view_params_types[<span class="org-string">"env"</span>], [], <span class="org-keyword">fn</span> {name, type_array}, errors <span class="org-keyword">-&gt;</span>
            [req_or_opt, type] =
              type_array
              <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list()

            <span class="org-variable-name">required</span> = req_or_opt == <span class="org-string">"required"</span>

            <span class="org-comment-delimiter"># </span><span class="org-comment">Check vals of real env_vars.</span>
            <span class="org-keyword">case</span> assert_env_var_type(env_vars_fake, name, required, type) <span class="org-keyword">do</span>
              <span class="org-elixir-atom">:ok</span> <span class="org-keyword">-&gt;</span> errors
              {<span class="org-elixir-atom">:error</span>, reason} <span class="org-keyword">-&gt;</span> [<span class="org-string">"</span><span class="org-variable-name">#{name}</span><span class="org-string"> (view_test): "</span> &lt;&gt; reason | errors]
            <span class="org-keyword">end</span>
          <span class="org-keyword">end</span>)

        <span class="org-keyword">if</span> type_errors == [] <span class="org-keyword">do</span>
          <span class="org-keyword">case</span> assert_expected_view(st1, view_test, env_vars_fake) <span class="org-keyword">do</span>
            <span class="org-elixir-atom">:ok</span> <span class="org-keyword">-&gt;</span> errors
            {<span class="org-elixir-atom">:error</span>, errs} <span class="org-keyword">-&gt;</span> [errs | errors]
          <span class="org-keyword">end</span>
        <span class="org-keyword">else</span>
          type_errors ++ errors
        <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Send message to delete all fake SRS GenServers, because we're done using</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">them. We won't need them until we need to run this function again, which</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">will only happen when the cache entry for this vm_fingerprint expires</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">(which should technically only happen when melbyd restarts).</span>
    <span class="org-type">Phoenix.PubSub</span>.broadcast(
      <span class="org-type">Melbyd.PubSub</span>,
      <span class="org-string">"fake_"</span> &lt;&gt; vm_fingerprint,
      {<span class="org-elixir-atom">:EXIT</span>, self(), <span class="org-elixir-atom">:release_fake_resource</span>}
    )

    <span class="org-keyword">if</span> <span class="org-type">Kernel</span>.length(errors) &gt; <span class="org-elixir-number">0</span> <span class="org-keyword">do</span>
      <span class="org-type">Logger</span>.warning(<span class="org-string">"got </span><span class="org-variable-name">#{Kernel.length(errors)}</span><span class="org-string"> errors reading fake readers"</span>)
      errors <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-keyword">fn</span> e <span class="org-keyword">-&gt;</span> <span class="org-type">Logger</span>.warning(e) <span class="org-keyword">end</span>)
      <span class="org-string">"failed validation"</span>
    <span class="org-keyword">else</span>
      <span class="org-elixir-atom">:ok</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">assert_expected_view</span>(st0, view_test, env_vars_fake) <span class="org-keyword">do</span>
    <span class="org-variable-name">substrings</span> = view_test[<span class="org-string">"expected_substrings"</span>] <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list()

    {[got], <span class="org-comment">_st</span>} = <span class="org-type">Luerl</span>.call_function(st0, [<span class="org-string">"Config"</span>, <span class="org-string">"view"</span>],
                                       [env_vars_fake, <span class="org-string">"000"</span>])

    <span class="org-variable-name">errors</span> =
      <span class="org-type">Enum</span>.reduce(substrings, [], <span class="org-keyword">fn</span> substring, errors <span class="org-keyword">-&gt;</span>
        <span class="org-keyword">if</span> <span class="org-type">String</span>.contains?(got, substring) <span class="org-keyword">do</span>
          errors
        <span class="org-keyword">else</span>
          [<span class="org-string">"could not find </span><span class="org-variable-name">#{inspect(substring)}</span><span class="org-string"> inside </span><span class="org-variable-name">#{inspect(got)}</span><span class="org-string">"</span> | errors]
        <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>)

    <span class="org-keyword">if</span> errors == [] <span class="org-keyword">do</span>
      <span class="org-elixir-atom">:ok</span>
    <span class="org-keyword">else</span>
      {<span class="org-elixir-atom">:error</span>, errors}
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">get_vm_fingerprint</span>({a, b, c, d, e, f, g, h, i, <span class="org-comment">_j</span>, <span class="org-comment">_k</span>, l, m}) <span class="org-keyword">do</span>
    {a, b, c, d, e, f, g, h, i, l, m}
    <span class="org-keyword">|&gt;</span> <span class="org-type">Kernel</span>.inspect(
      <span class="org-elixir-atom">limit:</span> <span class="org-elixir-atom">:infinity</span>,
      <span class="org-elixir-atom">printable_limit:</span> <span class="org-elixir-atom">:infinity</span>,
      <span class="org-elixir-atom">width:</span> <span class="org-elixir-atom">:infinity</span>
    )
    <span class="org-keyword">|&gt;</span> (&amp;:crypto.hash(<span class="org-elixir-atom">:sha</span>, &amp;1)).()
    <span class="org-comment-delimiter"># </span><span class="org-comment">Make this fingerprint easier to debug.</span>
    <span class="org-keyword">|&gt;</span> <span class="org-type">Base</span>.encode16()
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Cache for storing a boolean of whether this config has already been</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">validated or not.</span>
  <span class="org-elixir-attribute">@cache_id</span> <span class="org-elixir-atom">:lua_config_validation_cache</span>

  <span class="org-keyword">def</span> <span class="org-function-name">child_spec</span>(<span class="org-comment">_init_arg</span>) <span class="org-keyword">do</span>
    %{
      <span class="org-elixir-atom">id:</span> <span class="org-elixir-attribute">@cache_id</span>,
      <span class="org-elixir-atom">type:</span> <span class="org-elixir-atom">:supervisor</span>,
      <span class="org-elixir-atom">start:</span>
        {<span class="org-type">Cachex</span>, <span class="org-elixir-atom">:start_link</span>,
         [
           <span class="org-elixir-attribute">@cache_id</span>,
           [
             <span class="org-elixir-atom">limit:</span> <span class="org-elixir-number">16</span>,
             <span class="org-elixir-atom">fallback:</span> fallback(<span class="org-elixir-atom">default:</span> &amp;validate_key/<span class="org-elixir-number">2</span>, <span class="org-elixir-atom">state:</span> preloaded_fake_lua_vm())
           ]
         ]}
    }
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Auto-loaded-Elixir-module-exposed-to-Lua---Melbyd-LuaSdk-" class="outline-5">
<h5 id="h-Auto-loaded-Elixir-module-exposed-to-Lua---Melbyd-LuaSdk-"><span class="section-number-5">6.5.7.2.</span> Auto-loaded Elixir module exposed to Lua (<code>Melbyd.LuaSdk</code>)</h5>
<div class="outline-text-5" id="text-h-Auto-loaded-Elixir-module-exposed-to-Lua---Melbyd-LuaSdk-">
<p>
The code here is inspired by
<a href="https://github.com/ConnorRigby/lou/blob/master/lib/lou/lua/discord.ex">https://github.com/ConnorRigby/lou/blob/master/lib/lou/lua/discord.ex</a>. But
basically the idea is that we can write a single Elixir module (<code>Melbyd.LuaSdk</code>)
which will get loaded into Lua. Theoretically we could have multiple such
auto-loaded modules, but currently there is no need.
</p>

<p>
There are basically 2 categories of functions we expose to Lua:
</p>

<ol class="org-ol">
<li>functions to fetch data (Git data, etc), and</li>

<li>functions to format the data for saving into the shell's <code>$PS1</code> prompt
variable.</li>
</ol>

<p>
The Elixir functions must all take 2 arguments: the first argument is a list
which captures the function arguments sent from the Lua side, and the second
argument is always the state of the Lua VM instance. This is demonstrated in the
<code>hello_names</code> function (see section <a href="#h-Tests-1">6.8</a>).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#code-Melbyd-LuaInterop--code">melbyd_luasdk</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.LuaSdk</span> <span class="org-keyword">do</span>
  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-doc">"""</span>
<span class="org-doc">  An Elixir module that can be accessed from Lua (via luerl).</span>
<span class="org-doc">  """</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">This declaration just prevents programmer errors where we forget to define</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">install/1.</span>
  <span class="org-elixir-attribute">@behaviour</span> <span class="org-type">Melbyd.LuaSdkLoadable</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Autogenerate some boilerplate to avoid having to manually define</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">autoloaded_functions_table(). Specifically it defines the install/1 and</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">loaded_functions_table/0 for us automatically.</span>
  <span class="org-keyword">use</span> <span class="org-type">Melbyd.LuaSdkLoadable</span>

  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-elixir-attribute">@newlines</span> [<span class="org-string">"\n"</span>, <span class="org-string">"\r"</span>, <span class="org-string">"\r\n"</span>, <span class="org-string">"\n\r"</span>]

  <span class="org-keyword">def</span> <span class="org-function-name">get_melbyr_addr</span>() <span class="org-keyword">do</span>
    <span class="org-string">"localhost:</span><span class="org-variable-name">#{Application.get_env(:melbyd, :melbyr_port)}</span><span class="org-string">"</span>
  <span class="org-keyword">end</span>

  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_render">melbyd_luasdk_render</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_get_path_pretty">melbyd_luasdk_get_path_pretty</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_get_colorized_sha">melbyd_luasdk_get_colorized_sha</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_get_time">melbyd_luasdk_get_time</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_to_shell_script">melbyd_luasdk_to_shell_script</a></span>

  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_srs">melbyd_luasdk_srs</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_srs_fake">melbyd_luasdk_srs_fake</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_srs_helpers-1">melbyd_luasdk_srs_helpers</a></span>

  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_pubsub">melbyd_luasdk_pubsub</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_sps">melbyd_luasdk_sps</a></span>

  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luasdk_misc">melbyd_luasdk_misc</a></span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>

<div id="outline-container-h-Render-widgets--convert-string--objects--into-strings-with-ANSI-escape-codes" class="outline-6">
<h6 id="h-Render-widgets--convert-string--objects--into-strings-with-ANSI-escape-codes"><span class="section-number-6">6.5.7.2.1.</span> Render widgets (convert string "objects" into strings with ANSI escape codes)</h6>
<div class="outline-text-6" id="text-h-Render-widgets--convert-string--objects--into-strings-with-ANSI-escape-codes">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_render</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_render">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_render">def_lua_func render([widgets_list_ref, delimiter_ref], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">delimiter_tuples</span> = <span class="org-type">Luerl</span>.decode(st0, delimiter_ref)
  <span class="org-variable-name">delimiter</span> = widget_from_tuples(delimiter_tuples)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Retrieve render_options from the Config table in the Lua state.</span>
  <span class="org-variable-name">render_options</span> = get_render_options(st0)

  <span class="org-variable-name">widgets</span> =
    <span class="org-type">Luerl</span>.decode(st0, widgets_list_ref)
    <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-keyword">fn</span> {<span class="org-comment">_idx</span>, widget_tuples} <span class="org-keyword">-&gt;</span>
      widget_from_tuples(widget_tuples)
    <span class="org-keyword">end</span>)

  <span class="org-variable-name">req</span> = <span class="org-type">%MelbyRenderer.RenderWidgetsRequest</span>{}
  <span class="org-variable-name">req</span> = <span class="org-type">Map</span>.put(req, <span class="org-elixir-atom">:widgets</span>, widgets)
  <span class="org-variable-name">req</span> = <span class="org-type">Map</span>.put(req, <span class="org-elixir-atom">:delimiter</span>, delimiter)
  <span class="org-variable-name">req</span> = <span class="org-type">Map</span>.put(req, <span class="org-elixir-atom">:render_options</span>, render_options)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Call out to melbyr over gRPC.</span>
  <span class="org-variable-name">addr</span> = get_melbyr_addr()
  <span class="org-keyword">with</span> {<span class="org-elixir-atom">:ok</span>, channel} <span class="org-keyword">&lt;-</span> <span class="org-type">GRPC.Stub</span>.connect(addr, <span class="org-elixir-atom">adapter_opts:</span> [<span class="org-elixir-atom">retry_timeout:</span> <span class="org-elixir-number">5</span>]),
       {<span class="org-elixir-atom">:ok</span>, reply} <span class="org-keyword">&lt;-</span> <span class="org-type">MelbyRenderer.Renderer.Stub</span>.render_widgets(channel, req, <span class="org-elixir-atom">timeout:</span> <span class="org-elixir-number">200</span>) <span class="org-keyword">do</span>
    <span class="org-type">GRPC.Stub</span>.disconnect(channel)
    {<span class="org-elixir-atom">:ok</span>, reply.widgets_rendered, st0}
  <span class="org-keyword">else</span>
    err <span class="org-keyword">-&gt;</span> <span class="org-keyword">raise</span> <span class="org-string">"could not parse response from melbyr: </span><span class="org-variable-name">#{inspect(err)}</span><span class="org-string">"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">get_render_options</span>(st0) <span class="org-keyword">do</span>
  {render_options_tuples, <span class="org-comment">_st1</span>} = <span class="org-type">Luerl</span>.get_table(st0, [<span class="org-string">"Config"</span>, <span class="org-string">"render_options"</span>])

  <span class="org-variable-name">render_options_map</span> =
    <span class="org-type">Map</span>.new(
      render_options_tuples
      <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-keyword">fn</span> {k, v} <span class="org-keyword">-&gt;</span> {<span class="org-type">String</span>.to_atom(k), <span class="org-type">String</span>.to_atom(v)} <span class="org-keyword">end</span>)
    )

  <span class="org-variable-name">render_options</span> = <span class="org-type">%MelbyRenderer.RenderOptions</span>{}
  <span class="org-type">Map</span>.merge(render_options, render_options_map)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">widget_from_tuples</span>(widget_tuples) <span class="org-keyword">do</span>
  {widget, tp} =
    <span class="org-type">Enum</span>.reduce(
      widget_tuples,
      {<span class="org-type">%MelbyRenderer.Widget</span>{}, <span class="org-type">%MelbyRenderer.TextProperty</span>{}},
      <span class="org-keyword">fn</span> {k, v}, acc <span class="org-keyword">-&gt;</span>
        {acc_w, acc_tp} = acc
        <span class="org-comment-delimiter"># </span><span class="org-comment">We only recognize certain keywords.</span>
        <span class="org-keyword">case</span> k <span class="org-keyword">do</span>
          <span class="org-string">"str"</span> <span class="org-keyword">-&gt;</span>
            {<span class="org-type">Map</span>.put(acc_w, <span class="org-elixir-atom">:str</span>, v), acc_tp}

          <span class="org-string">"fg"</span> <span class="org-keyword">-&gt;</span>
            {acc_w, <span class="org-type">Map</span>.put(acc_tp, <span class="org-elixir-atom">:fg</span>, color_from_str(v))}

          <span class="org-string">"bg"</span> <span class="org-keyword">-&gt;</span>
            {acc_w, <span class="org-type">Map</span>.put(acc_tp, <span class="org-elixir-atom">:bg</span>, color_from_str(v))}

          <span class="org-string">"styles"</span> <span class="org-keyword">-&gt;</span>
            <span class="org-variable-name">styles</span> = <span class="org-type">Enum</span>.map(v, <span class="org-keyword">fn</span> {<span class="org-comment">_idx</span>, s} <span class="org-keyword">-&gt;</span> style_from_str(s) <span class="org-keyword">end</span>)
            {acc_w, <span class="org-type">Map</span>.put(acc_tp, <span class="org-elixir-atom">:styles</span>, styles)}

          <span class="org-comment-delimiter"># </span><span class="org-comment">Skip over any unrecognized key.</span>
          <span class="org-string">"drop_delim_left"</span> <span class="org-keyword">-&gt;</span>
            {<span class="org-type">Map</span>.put(acc_w, <span class="org-elixir-atom">:drop_delim_left</span>, v), acc_tp}

          <span class="org-string">"drop_delim_right"</span> <span class="org-keyword">-&gt;</span>
            {<span class="org-type">Map</span>.put(acc_w, <span class="org-elixir-atom">:drop_delim_right</span>, v), acc_tp}

          <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
            acc
        <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>
    )

  <span class="org-type">Map</span>.put(widget, <span class="org-elixir-atom">:prop</span>, tp)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">color_from_str</span>(s) <span class="org-keyword">do</span>
  {r, g, b} = <span class="org-type">Melbyd.Color</span>.parse(s)
  <span class="org-variable-name">c24bit</span> = <span class="org-type">%MelbyRenderer.Color24Bit</span>{<span class="org-elixir-atom">red:</span> r, <span class="org-elixir-atom">green:</span> g, <span class="org-elixir-atom">blue:</span> b}
  <span class="org-type">%MelbyRenderer.Color</span>{<span class="org-elixir-atom">color_oneof:</span> {<span class="org-elixir-atom">:color_24_bit</span>, c24bit}}
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">style_from_str</span>(s) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> s <span class="org-keyword">do</span>
    <span class="org-string">"bold"</span> <span class="org-keyword">-&gt;</span> <span class="org-elixir-atom">:TEXT_STYLE_BOLD</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: skip over unrecogized values</span>
    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span> <span class="org-elixir-atom">:TEXT_STYLE_BOLD</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Pretty-paths" class="outline-6">
<h6 id="h-Pretty-paths"><span class="section-number-6">6.5.7.2.2.</span> Pretty paths</h6>
<div class="outline-text-6" id="text-h-Pretty-paths">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_get_path_pretty</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_get_path_pretty">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_get_path_pretty">def_lua_func get_path_pretty([path, options_ref], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">options</span> = <span class="org-type">Luerl</span>.decode(st0, options_ref)
  <span class="org-variable-name">options_map</span> = <span class="org-type">Map</span>.new(options)

  <span class="org-variable-name">aliases</span> = options_map[<span class="org-string">"aliases"</span>] <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()
  <span class="org-variable-name">env</span> = options_map[<span class="org-string">"env"</span>] <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()

  <span class="org-comment-delimiter"># </span><span class="org-comment">Create a subset of env vars. This is because we only care about the ones</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">used by the keys in aliases.</span>
  {aliases_filtered, env_filtered} =
    <span class="org-type">Enum</span>.reduce(aliases, {%{}, %{}}, <span class="org-keyword">fn</span> {k, v}, {aliases_filtered, env_filtered} <span class="org-keyword">-&gt;</span>
      <span class="org-variable-name">vars</span> = <span class="org-type">Regex</span>.scan(<span class="org-builtin">~r</span>/<span class="org-string">\$\{(.+?)\}</span>/, k) <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-keyword">fn</span> [<span class="org-comment">_entire_match</span>, group] <span class="org-keyword">-&gt;</span> group <span class="org-keyword">end</span>)
      <span class="org-comment-delimiter"># </span><span class="org-comment">Check if every variable is found in env.</span>
      <span class="org-variable-name">env_subset</span> = <span class="org-type">Map</span>.take(env, vars)

      <span class="org-keyword">if</span> length(vars) == <span class="org-type">Enum</span>.count(env_subset) <span class="org-keyword">do</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Only keep aliases if we can find all of its environment variable references.</span>
        {<span class="org-type">Map</span>.put(aliases_filtered, k, v), <span class="org-type">Map</span>.merge(env_filtered, env_subset)}
      <span class="org-keyword">else</span>
        {aliases_filtered, env_filtered}
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>)

  <span class="org-comment-delimiter"># </span><span class="org-comment">If we were unable to parse the aliases (e.g., we are given no aliases to</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">begin with because we failed to parse the path aliases file), then just use</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">a map with the HOME variable. This is because the Rust NIF always</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">expects at least the "HOME" env var to exist.</span>
  <span class="org-variable-name">env_filtered_final</span> =
    <span class="org-keyword">if</span> env_filtered == %{} <span class="org-keyword">do</span>
      <span class="org-keyword">if</span> env[<span class="org-string">"HOME"</span>] == <span class="org-elixir-atom">nil</span> <span class="org-keyword">do</span>
        <span class="org-type">Logger</span>.warning(
          <span class="org-string">"HOME environment variable is not defined; using useless default \"/home/foo\""</span>
        )
      <span class="org-keyword">end</span>

      <span class="org-type">Map</span>.new([{<span class="org-string">"HOME"</span>, env[<span class="org-string">"HOME"</span>] || <span class="org-string">"/home/foo"</span>}])
    <span class="org-keyword">else</span>
      env_filtered
    <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Default value is 0 (no shortening).</span>
  <span class="org-variable-name">shorten_threshold</span> = <span class="org-type">Map</span>.get(options_map, <span class="org-string">"shorten_threshold"</span>, <span class="org-elixir-number">0</span>)

  <span class="org-variable-name">prettified</span> =
    <span class="org-type">Melbyd.Path</span>.get_path_pretty(path, aliases_filtered, env_filtered_final, shorten_threshold)

  {<span class="org-elixir-atom">:ok</span>, prettified, st0}
<span class="org-keyword">end</span>

def_lua_func get_path_aliases([path_aliases_file], st0) <span class="org-keyword">do</span>
  <span class="org-keyword">if</span> path_aliases_file == <span class="org-elixir-atom">nil</span> <span class="org-keyword">do</span>
    <span class="org-type">Logger</span>.warning(<span class="org-string">"path_aliases_file is nil; defaulting to empty map"</span>)
    {<span class="org-elixir-atom">:ok</span>, <span class="org-type">Map</span>.new(), st0}
  <span class="org-keyword">else</span>
    <span class="org-keyword">with</span> {<span class="org-elixir-atom">:ok</span>, path_aliases_raw} <span class="org-keyword">&lt;-</span> <span class="org-type">File</span>.read(path_aliases_file) <span class="org-keyword">do</span>
      get_path_aliases_helper(path_aliases_raw, st0)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">This is just like get_path_aliases, but expects the raw file contents instead</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">of the filename (path) to read out.</span>
def_lua_func get_path_aliases_fake([path_aliases_raw], st0) <span class="org-keyword">do</span>
  get_path_aliases_helper(path_aliases_raw, st0)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">get_path_aliases_helper</span>(path_aliases_raw, st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">req</span> = <span class="org-type">%MelbyRenderer.ParsePathAliasesRequest</span>{}
  <span class="org-variable-name">req</span> = <span class="org-type">Map</span>.put(req, <span class="org-elixir-atom">:path_aliases_raw</span>, path_aliases_raw)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Call out to melbyr over gRPC.</span>
  <span class="org-variable-name">addr</span> = get_melbyr_addr()
  <span class="org-keyword">with</span> {<span class="org-elixir-atom">:ok</span>, channel} <span class="org-keyword">&lt;-</span> <span class="org-type">GRPC.Stub</span>.connect(addr, <span class="org-elixir-atom">adapter_opts:</span> [<span class="org-elixir-atom">retry_timeout:</span> <span class="org-elixir-number">5</span>]),
       {<span class="org-elixir-atom">:ok</span>, reply} <span class="org-keyword">&lt;-</span> <span class="org-type">MelbyRenderer.Renderer.Stub</span>.parse_path_aliases(
         channel, req, <span class="org-elixir-atom">timeout:</span> <span class="org-elixir-number">200</span>) <span class="org-keyword">do</span>
    <span class="org-type">GRPC.Stub</span>.disconnect(channel)
    <span class="org-keyword">if</span> reply.status == <span class="org-elixir-atom">:PARSE_STATUS_ERROR</span> <span class="org-keyword">do</span>
      <span class="org-type">Logger</span>.warning(<span class="org-string">"parse failed: </span><span class="org-variable-name">#{inspect(reply.error)}</span><span class="org-string">"</span>)
    <span class="org-keyword">end</span>
    {<span class="org-elixir-atom">:ok</span>, reply.path_aliases, st0}
  <span class="org-keyword">else</span>
    err <span class="org-keyword">-&gt;</span> <span class="org-keyword">raise</span> <span class="org-string">"failed to successfully call melbyr: </span><span class="org-variable-name">#{inspect(err)}</span><span class="org-string">"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Colorized-Git-SHA" class="outline-6">
<h6 id="h-Colorized-Git-SHA"><span class="section-number-6">6.5.7.2.3.</span> Colorized Git SHA</h6>
<div class="outline-text-6" id="text-h-Colorized-Git-SHA">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_get_colorized_sha</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_get_colorized_sha">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_get_colorized_sha">def_lua_func get_colorized_sha([sha, sha_length, pad_left, pad_right], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">render_options</span> = get_render_options(st0)

  <span class="org-variable-name">req</span> = <span class="org-type">%MelbyRenderer.ColorizedGitShaRequest</span>{}
  <span class="org-variable-name">req</span> = <span class="org-type">Map</span>.put(req, <span class="org-elixir-atom">:sha</span>, sha)
  <span class="org-variable-name">req</span> = <span class="org-type">Map</span>.put(req, <span class="org-elixir-atom">:sha_length</span>, sha_length)
  <span class="org-variable-name">req</span> = <span class="org-type">Map</span>.put(req, <span class="org-elixir-atom">:pad_left</span>, pad_left)
  <span class="org-variable-name">req</span> = <span class="org-type">Map</span>.put(req, <span class="org-elixir-atom">:pad_right</span>, pad_right)
  <span class="org-variable-name">req</span> = <span class="org-type">Map</span>.put(req, <span class="org-elixir-atom">:render_options</span>, render_options)

  <span class="org-type">Logger</span>.debug(<span class="org-string">"elixir req was: </span><span class="org-variable-name">#{inspect(req)}</span><span class="org-string">"</span>)

  <span class="org-variable-name">addr</span> = get_melbyr_addr()
  <span class="org-keyword">with</span> {<span class="org-elixir-atom">:ok</span>, channel} <span class="org-keyword">&lt;-</span> <span class="org-type">GRPC.Stub</span>.connect(addr, <span class="org-elixir-atom">adapter_opts:</span> [<span class="org-elixir-atom">retry_timeout:</span> <span class="org-elixir-number">5</span>]),
       {<span class="org-elixir-atom">:ok</span>, reply} <span class="org-keyword">&lt;-</span> channel
         <span class="org-keyword">|&gt;</span> <span class="org-type">MelbyRenderer.Renderer.Stub</span>.get_colorized_git_sha(req, <span class="org-elixir-atom">timeout:</span> <span class="org-elixir-number">200</span>) <span class="org-keyword">do</span>
    <span class="org-type">GRPC.Stub</span>.disconnect(channel)
    {<span class="org-elixir-atom">:ok</span>, reply.sha_colorized, st0}
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Time" class="outline-6">
<h6 id="h-Time"><span class="section-number-6">6.5.7.2.4.</span> Time</h6>
<div class="outline-text-6" id="text-h-Time">
<p>
FIXME: Use Timex library here also to avoid making the user use the stupid
"America/Los_Angeles" timezone and instead the shorter names that the "%Z"
strftime uses, because then the user doesn't have to use <code>timedatectl</code> as well.
</p>

<p>
Construct the time string from the time format string, and optional time zone
and UNIX seconds. We take in these optional parameters so that the test code can
inject them (otherwise the tests will break as the values tested will no longer
be constant).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_get_time</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_get_time">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_get_time">def_lua_func get_time([format, unix_seconds, time_zone], st0) <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Use UTC by default.</span>
  <span class="org-variable-name">tz</span> =
    <span class="org-keyword">cond</span> <span class="org-keyword">do</span>
      time_zone == <span class="org-string">"LOCAL"</span> <span class="org-keyword">-&gt;</span> <span class="org-type">Timex.Timezone</span>.local().full_name
      timezone_ok(time_zone) <span class="org-keyword">-&gt;</span> time_zone
      <span class="org-elixir-atom">true</span> <span class="org-keyword">-&gt;</span> <span class="org-string">"Etc/UTC"</span>
    <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Use the current time if unix_seconds is not provided.</span>
  <span class="org-variable-name">sec</span> =
    <span class="org-keyword">if</span> unix_seconds <span class="org-keyword">do</span>
      <span class="org-keyword">if</span> is_binary(unix_seconds) <span class="org-keyword">do</span>
        <span class="org-type">String</span>.to_integer(unix_seconds)
      <span class="org-keyword">else</span>
        unix_seconds
      <span class="org-keyword">end</span>
    <span class="org-keyword">else</span>
      <span class="org-keyword">with</span> {<span class="org-elixir-atom">:ok</span>, t} <span class="org-keyword">&lt;-</span> <span class="org-type">DateTime</span>.now(tz),
           <span class="org-elixir-atom">do:</span> <span class="org-type">DateTime</span>.to_unix(t)
    <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Format the current time with the given format string.</span>
  <span class="org-variable-name">t</span> =
    <span class="org-type">DateTime</span>.from_unix!(sec)
    <span class="org-keyword">|&gt;</span> <span class="org-type">DateTime</span>.shift_zone!(tz)

  {<span class="org-elixir-atom">:ok</span>, <span class="org-type">Calendar</span>.strftime(t, format), st0}
<span class="org-keyword">end</span>

def_lua_func get_unix_seconds(<span class="org-constant">_</span>, st0) <span class="org-keyword">do</span>
  <span class="org-keyword">with</span> {<span class="org-elixir-atom">:ok</span>, t} <span class="org-keyword">&lt;-</span> <span class="org-type">DateTime</span>.now(<span class="org-string">"Etc/UTC"</span>),
       <span class="org-elixir-atom">do:</span> {<span class="org-elixir-atom">:ok</span>, <span class="org-type">DateTime</span>.to_unix(t), st0}
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">timezone_ok</span>(tz) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> <span class="org-type">DateTime</span>.now(tz) <span class="org-keyword">do</span>
    {<span class="org-elixir-atom">:ok</span>, <span class="org-constant">_</span>} <span class="org-keyword">-&gt;</span>
      <span class="org-elixir-atom">true</span>

    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
      <span class="org-type">Logger</span>.warning(<span class="org-string">"unrecognized timezone: '</span><span class="org-variable-name">#{tz}</span><span class="org-string">'"</span>)
      <span class="org-elixir-atom">false</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Export-to-shell-script" class="outline-6">
<h6 id="h-Export-to-shell-script"><span class="section-number-6">6.5.7.2.5.</span> Export to shell script</h6>
<div class="outline-text-6" id="text-h-Export-to-shell-script">
<p>
FIXME: This should be another NIF because the logic here is purely functional
(independent of the Lua VM state).
</p>

<p>
The use of <code>mapfile</code> is from <a href="https://stackoverflow.com/a/47862096/437583">https://stackoverflow.com/a/47862096/437583</a>. We use
it instead of running <code>cat</code> because it avoids spawning a separate OS process.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_to_shell_script</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_to_shell_script">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_to_shell_script">def_lua_func to_shell_script([exports_ref], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">exports_list</span> = <span class="org-type">Luerl</span>.decode(st0, exports_ref) <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list()
  <span class="org-variable-name">exports</span> = exports_list <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-type">&amp;Melbyd.LuerlUtil</span>.table_to_native_map/<span class="org-elixir-number">1</span>)

  <span class="org-type">Logger</span>.debug(<span class="org-string">"exports is </span><span class="org-variable-name">#{inspect(exports)}</span><span class="org-string">"</span>)

  <span class="org-variable-name">script</span> =
    exports
    <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.reduce(<span class="org-string">""</span>, <span class="org-keyword">fn</span> export_map, acc <span class="org-keyword">-&gt;</span>
      acc &lt;&gt; export_shell_var(export_map)
    <span class="org-keyword">end</span>)

  <span class="org-type">Logger</span>.debug(<span class="org-string">"script is </span><span class="org-variable-name">#{inspect(script, limit: :infinity, binaries: :as_strings)}</span><span class="org-string">"</span>)

  {<span class="org-elixir-atom">:ok</span>, script, st0}
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">export_shell_var</span>(%{<span class="org-string">"name"</span> <span class="org-keyword">=&gt;</span> name, <span class="org-string">"val"</span> <span class="org-keyword">=&gt;</span> val, <span class="org-string">"type"</span> <span class="org-keyword">=&gt;</span> type}) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> type <span class="org-keyword">do</span>
    <span class="org-string">"array"</span> <span class="org-keyword">-&gt;</span>
      <span class="org-variable-name">ret</span> = <span class="org-string">"""</span>
<span class="org-string">      declare -a </span><span class="org-variable-name">#{name}</span>
<span class="org-string">      </span><span class="org-variable-name">#{name}</span><span class="org-string">=(</span>
<span class="org-string">      """</span>

      <span class="org-variable-name">ret</span> =
        <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list(val)
        <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.reduce(ret, <span class="org-keyword">fn</span> item, acc <span class="org-keyword">-&gt;</span> acc &lt;&gt; <span class="org-string">"</span><span class="org-variable-name">#{inspect(item)}</span><span class="org-string">"</span> <span class="org-keyword">end</span>)

      ret &lt;&gt; <span class="org-string">"\n)\n"</span>

    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Technically this is broken if "v" has a string "END_HEREDOC" on</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">its own line. There are ways around this but for now we don't care.</span>
      <span class="org-comment-delimiter">#</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">It's doubly broken because "k" could have an invalid non-keyword</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">character in it. But again we don't care for now.</span>
      <span class="org-string">"""</span>
<span class="org-string">      </span><span class="org-variable-name">#{name}</span><span class="org-string">=$(cat &lt;&lt; 'END_HEREDOC'</span>
<span class="org-string">      </span><span class="org-variable-name">#{val}</span>
<span class="org-string">      END_HEREDOC</span>
<span class="org-string">      )</span>
<span class="org-string">      """</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Expected-functions-in-the-Lua-file-for-SRS" class="outline-6">
<h6 id="h-Expected-functions-in-the-Lua-file-for-SRS"><span class="section-number-6">6.5.7.2.6.</span> Expected functions in the Lua file for SRS</h6>
<div class="outline-text-6" id="text-h-Expected-functions-in-the-Lua-file-for-SRS">
<p>
We expect the Lua file to include a <code>Config.view()</code> function that will be used
to generate all the data to read and present as the final <i>view</i> back to the
client. The Lua configuration is free to call into Elixir with the provided
functions in the <code>Melbyd.LuaSdk</code> module (exposed through the <code>melbyd</code> Lua table).
</p>
</div>

<ol class="org-ol">
<li><a id="h-Functions-for-instantiating-a-SRS-GenServer"></a>Functions for instantiating a SRS GenServer<br>
<div class="outline-text-7" id="text-h-Functions-for-instantiating-a-SRS-GenServer">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs">def_lua_func read_standard_resource([resource_ref, resource_opts_ref], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">resource</span> = resource_ref_to_native_map(resource_ref, st0)
  <span class="org-variable-name">resource_opts</span> = <span class="org-type">Luerl</span>.decode(st0, resource_opts_ref) <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()

  <span class="org-variable-name">resource_opts</span> = <span class="org-type">Map</span>.put(resource_opts, <span class="org-string">"fake"</span>, <span class="org-elixir-atom">false</span>)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Now we just have to pass in this data into a SRS initializer function. This</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">initializer function is the Melbyd.StandardResource.get_state() function,</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">which does the work of calling out to the DynamicSupervisor if necessary</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">before retrieving the state. The interesting thing is that the</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Melbyd.StandardResource module itself calls into the Lua config to determine</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">what kind of business logic it needs to run, especially for the control</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">loop.</span>
  <span class="org-variable-name">res</span> = <span class="org-type">Melbyd.StandardResource</span>.read(resource, resource_opts)
  {<span class="org-elixir-atom">:ok</span>, res, st0}
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">resource_ref_to_native_map</span>(resource_ref, st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">resource_luerl</span> = <span class="org-type">Luerl</span>.decode(st0, resource_ref)
  <span class="org-variable-name">resource</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(resource_luerl)
  <span class="org-variable-name">parser</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(resource[<span class="org-string">"parser"</span>])
  <span class="org-variable-name">fake</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(resource[<span class="org-string">"fake"</span>])
  <span class="org-variable-name">resource</span> = <span class="org-type">Map</span>.put(resource, <span class="org-string">"parser"</span>, parser)
  <span class="org-type">Map</span>.put(resource, <span class="org-string">"fake"</span>, fake)
<span class="org-keyword">end</span>
</pre></div></div>
</div>

<ol class="org-ol">
<li><a id="h-Fake"></a>Fake<br>
<div class="outline-text-8" id="text-h-Fake">
<p>
This is like <code>read_standard_resource</code>, but instead of reading things the regular
way, we inject a special "fake" key in the resource_opts so that the reader
knows that it is fake and understands it should execute the fake readers and
also the <code>resource_id_func</code> instead of the resource_id_command. The good thing
is that all of these bits should already be defined in the resource already by
the user.
</p>

<p>
FIXME: We must put all SRS and SLG resources in a separate <code>namespace</code> so as to
not collide with actual production resources. E.g., we don't want to create an
SRS or SLG GenServer instance whose <code>id</code> would collide with one for production.
We need to create a unique token for a validation request and use that as part
of the resource IDs so that multiple validation requests do not walk on each
other. Hmm, actually, what we need is a concurrent non-blocking cache. We need
to make it so that we hash the incoming code's contents to generate a
deterministic key (md5sum), then use this key as the validation result, and
cache this result. If there are any other requests coming into melbyd for the
same config, they also will get hashed to the same key, and must wait for the
first request's already-in-progress validation to succeed. We can use Cachex and
its so-called "fallbacks" to get this concurrent non-blocking cache behavior.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_fake</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_fake">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_fake">def_lua_func read_standard_resource_fake([resource_ref, resource_opts_ref], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">resource</span> = resource_ref_to_native_map(resource_ref, st0)
  <span class="org-variable-name">resource_opts</span> = <span class="org-type">Luerl</span>.decode(st0, resource_opts_ref) <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()

  <span class="org-comment-delimiter"># </span><span class="org-comment">Stamp this as being fake for all downstream code.</span>
  <span class="org-variable-name">resource_opts</span> = <span class="org-type">Map</span>.put(resource_opts, <span class="org-string">"fake"</span>, <span class="org-elixir-atom">true</span>)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Save vm_fingerprint so that it's accessible easily from the Elixir side.</span>
  {vm_fingerprint, <span class="org-constant">_</span>} = <span class="org-type">Luerl</span>.get_table1(st0, [<span class="org-string">"melbyd"</span>, <span class="org-string">"vm_fingerprint"</span>])
  <span class="org-variable-name">resource_opts</span> = <span class="org-type">Map</span>.put(resource_opts, <span class="org-string">"vm_fingerprint"</span>, vm_fingerprint)

  <span class="org-variable-name">res</span> = <span class="org-type">Melbyd.StandardResource</span>.read(resource, resource_opts)
  {<span class="org-elixir-atom">:ok</span>, res, st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>
</ol>
</li>

<li><a id="h-Functions-to-help-with-string-handling"></a>Functions to help with string handling<br>
<div class="outline-text-7" id="text-h-Functions-to-help-with-string-handling">
<p>
SRS lets users write UNIX commands that will be executed and parsed back.
Oftentimes, users will want to reach for the same facilities, such as string
whitespace trimming, to make parsing in Lua easier. We provide such
functionality here. This way users don't have to write at a lower level too much
in their Lua configuration.
</p>
</div>

<ol class="org-ol">
<li><a id="h-get-lines-trimmed-nonempty"></a><code>get_lines_trimmed_nonempty</code><br>
<div class="outline-text-8" id="text-h-get-lines-trimmed-nonempty">
<p>
Convert an arbitrary string into an array of strings, splitting on newlines and
trimming each line. Discards empty lines.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(1/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-1">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-1">def_lua_func get_lines_trimmed_nonempty([s], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">lines</span> =
    s
    <span class="org-keyword">|&gt;</span> <span class="org-type">String</span>.split(<span class="org-elixir-attribute">@newlines</span>)
    <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.take_while(<span class="org-keyword">fn</span> x <span class="org-keyword">-&gt;</span> <span class="org-type">String</span>.trim(x) <span class="org-keyword">|&gt;</span> <span class="org-type">String</span>.length() &gt; <span class="org-elixir-number">0</span> <span class="org-keyword">end</span>)

  {<span class="org-elixir-atom">:ok</span>, lines, st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-get-trimmed"></a><code>get_trimmed</code><br>
<div class="outline-text-8" id="text-h-get-trimmed">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(2/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-2">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-2">def_lua_func get_trimmed([s], st0) <span class="org-keyword">do</span>
  {<span class="org-elixir-atom">:ok</span>, <span class="org-type">String</span>.trim(s), st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-split"></a><code>split</code><br>
<div class="outline-text-8" id="text-h-split">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(3/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-3">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-3">def_lua_func split([s, delim], st0) <span class="org-keyword">do</span>
  {<span class="org-elixir-atom">:ok</span>, <span class="org-type">String</span>.split(s, delim, <span class="org-elixir-atom">trim:</span> <span class="org-elixir-atom">true</span>), st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-get-group-or-default--and--get-int-group"></a><code>get_group_or_default</code> and <code>get_int_group</code><br>
<div class="outline-text-8" id="text-h-get-group-or-default--and--get-int-group">
<p>
Given a regex pattern with a group, extract the given Nth group. If no such
group is found (or the pattern doesn't even match), return the default string.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(4/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-4">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-4">def_lua_func get_group_or_default([s, pat, nth, default], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">regex</span> =
    <span class="org-keyword">try</span> <span class="org-keyword">do</span>
      <span class="org-type">Regex</span>.compile!(pat)
    <span class="org-keyword">rescue</span>
      e <span class="org-keyword">in</span> <span class="org-type">Regex.CompileError</span> <span class="org-keyword">-&gt;</span>
        <span class="org-type">Logger</span>.error(<span class="org-elixir-atom">got:</span> e, <span class="org-elixir-atom">from_pat:</span> pat)
        <span class="org-elixir-atom">nil</span>
    <span class="org-keyword">end</span>

  <span class="org-keyword">case</span> regex <span class="org-keyword">do</span>
    <span class="org-elixir-atom">nil</span> <span class="org-keyword">-&gt;</span>
      {<span class="org-elixir-atom">:ok</span>, default, st0}

    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
      <span class="org-variable-name">captures</span> = <span class="org-type">Regex</span>.run(regex, s)

      <span class="org-variable-name">res</span> =
        <span class="org-keyword">if</span> captures == <span class="org-elixir-atom">nil</span> <span class="org-keyword">do</span>
          default
        <span class="org-keyword">else</span>
          <span class="org-keyword">case</span> <span class="org-type">Enum</span>.at(captures, nth) <span class="org-keyword">do</span>
            <span class="org-elixir-atom">nil</span> <span class="org-keyword">-&gt;</span> default
            g <span class="org-keyword">-&gt;</span> g
          <span class="org-keyword">end</span>
        <span class="org-keyword">end</span>

      {<span class="org-elixir-atom">:ok</span>, res, st0}
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Equivalent to get_group_or_default([s, pat, 1, 0], st0)</span>
def_lua_func get_int_group([s, pat], st0) <span class="org-keyword">do</span>
  {<span class="org-elixir-atom">:ok</span>, res, <span class="org-comment">_st</span>} = __internal__get_group_or_default([s, pat, <span class="org-elixir-number">1</span>, <span class="org-string">"0"</span>], st0)
  {<span class="org-elixir-atom">:ok</span>, <span class="org-type">String</span>.to_integer(res), st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-get-lines-matching-count"></a><code>get_lines_matching_count</code><br>
<div class="outline-text-8" id="text-h-get-lines-matching-count">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(5/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-5">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-5">def_lua_func get_lines_matching_count([s, pat], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">count</span> = <span class="org-type">String</span>.split(s, <span class="org-elixir-attribute">@newlines</span>) <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.count(<span class="org-keyword">fn</span> x <span class="org-keyword">-&gt;</span> <span class="org-type">String</span>.starts_with?(x, pat) <span class="org-keyword">end</span>)
  {<span class="org-elixir-atom">:ok</span>, count, st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-get-kv-lines-as-map"></a><code>get_kv_lines_as_map</code><br>
<div class="outline-text-8" id="text-h-get-kv-lines-as-map">
<p>
Given lines of the format <code>"key,value"</code>, return a hashmap of keys with their
values. Expects only 1 value for 1 key. If there is more than 1 instance of the
delimiter on the line, this is an error.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(6/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-6">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-6">def_lua_func get_kv_lines_as_map([s], st0) <span class="org-keyword">do</span>
  {<span class="org-elixir-atom">:ok</span>, lines, <span class="org-comment">_st</span>} = __internal__get_lines_trimmed_nonempty([s], st0)

  <span class="org-variable-name">kvs</span> =
    <span class="org-type">Enum</span>.map(lines, <span class="org-keyword">fn</span> line <span class="org-keyword">-&gt;</span>
      [k, v] = <span class="org-type">String</span>.split(line, <span class="org-string">","</span>)
      {k, v}
    <span class="org-keyword">end</span>)

  {<span class="org-elixir-atom">:ok</span>, <span class="org-type">Map</span>.new(kvs), st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-get-columnar-fields-zipped"></a><code>get_columnar_fields_zipped</code><br>
<div class="outline-text-8" id="text-h-get-columnar-fields-zipped">
<p>
Given a line like <code>"value1&lt;WHITESPACE&gt;value2"</code>, and a list of keys, return a map
with the keys and their respective values. The number of keys and values must
match.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(7/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-7">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-7">def_lua_func get_columnar_fields_zipped([s, keys_ref], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">keys</span> = <span class="org-type">Luerl</span>.decode(st0, keys_ref) <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list()
  <span class="org-variable-name">trimmed_line</span> = <span class="org-type">String</span>.trim(s)
  <span class="org-variable-name">vals</span> = <span class="org-type">String</span>.split(trimmed_line)
  <span class="org-variable-name">kvs</span> = <span class="org-type">Enum</span>.zip(keys, vals)

  {<span class="org-elixir-atom">:ok</span>, <span class="org-type">Map</span>.new(kvs), st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-cast-values"></a><code>cast_values</code><br>
<div class="outline-text-8" id="text-h-cast-values">
<p>
Convert some fields in a Lua table into a value other than a string. Here, <code>t</code>
is the table of key/values we want to cast, and <code>keytypes</code> is a table of
key/types.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(8/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-8">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-8">def_lua_func cast_values([t_ref, keytypes_ref], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">t</span> = <span class="org-type">Luerl</span>.decode(st0, t_ref) <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()
  <span class="org-variable-name">keytypes</span> = <span class="org-type">Luerl</span>.decode(st0, keytypes_ref) <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()

  <span class="org-variable-name">ret</span> =
    <span class="org-type">Enum</span>.reduce(t, %{}, <span class="org-keyword">fn</span> {key, val}, acc <span class="org-keyword">-&gt;</span>
      <span class="org-keyword">if</span> <span class="org-type">Map</span>.has_key?(keytypes, key) <span class="org-keyword">do</span>
        <span class="org-keyword">case</span> keytypes[key] <span class="org-keyword">do</span>
          <span class="org-string">"float"</span> <span class="org-keyword">-&gt;</span>
            <span class="org-type">Map</span>.put(acc, key, to_number(val, key))

          <span class="org-string">"int"</span> <span class="org-keyword">-&gt;</span>
            <span class="org-type">Map</span>.put(acc, key, <span class="org-type">Kernel</span>.trunc(to_number(val, key)))

          <span class="org-string">"bool"</span> <span class="org-keyword">-&gt;</span>
            <span class="org-type">Map</span>.put(acc, key, to_bool(val))

          <span class="org-comment-delimiter"># </span><span class="org-comment">If we can't figure out the type, log an error and use the uncasted value.</span>
          type <span class="org-keyword">-&gt;</span>
            <span class="org-type">Logger</span>.error(<span class="org-string">"key </span><span class="org-variable-name">#{inspect(key)}</span><span class="org-string">: unrecognized type </span><span class="org-variable-name">#{inspect(type)}</span><span class="org-string">"</span>)
            <span class="org-type">Map</span>.put(acc, key, val)
        <span class="org-keyword">end</span>
      <span class="org-keyword">else</span>
        <span class="org-type">Map</span>.put(acc, key, val)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>)

  {<span class="org-elixir-atom">:ok</span>, ret, st0}
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">to_number</span>(s, field) <span class="org-keyword">when</span> is_binary(s) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> <span class="org-type">Float</span>.parse(s) <span class="org-keyword">do</span>
    <span class="org-elixir-atom">:error</span> <span class="org-keyword">-&gt;</span>
      <span class="org-type">Logger</span>.error(<span class="org-string">"field </span><span class="org-variable-name">#{inspect(field)}</span><span class="org-string">: could not convert </span><span class="org-variable-name">#{inspect(s)}</span><span class="org-string"> to float; defaulting to 0"</span>)
      <span class="org-elixir-number">0</span>

    {f, <span class="org-comment">_rem</span>} <span class="org-keyword">-&gt;</span>
      f
    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span> <span class="org-elixir-number">0</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">to_number</span>(n, field) <span class="org-keyword">when</span> is_number(n) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.debug(<span class="org-string">"field </span><span class="org-variable-name">#{inspect(field)}</span><span class="org-string">: </span><span class="org-variable-name">#{n}</span><span class="org-string"> is already a number; using it as-is"</span>)
  n
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">to_number</span>(x, field) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.error(<span class="org-string">"field </span><span class="org-variable-name">#{inspect(field)}</span><span class="org-string">: </span><span class="org-variable-name">#{x}</span><span class="org-string"> is not a number; defaulting to 0"</span>)
  <span class="org-elixir-number">0</span>
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">to_bool</span>(s) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> s <span class="org-keyword">do</span>
    str
    <span class="org-keyword">when</span> str <span class="org-keyword">in</span> [<span class="org-string">""</span>, <span class="org-string">"n"</span>, <span class="org-string">"N"</span>, <span class="org-string">"no"</span>, <span class="org-string">"No"</span>, <span class="org-string">"NO"</span>, <span class="org-string">"nil"</span>, <span class="org-string">"Nil"</span>, <span class="org-string">"NIL"</span>, <span class="org-string">"false"</span>, <span class="org-string">"False"</span>, <span class="org-string">"FALSE"</span>] <span class="org-keyword">-&gt;</span>
      <span class="org-elixir-atom">false</span>

    <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
      <span class="org-elixir-atom">true</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-get-relative-age"></a><code>get_relative_age</code><br>
<div class="outline-text-8" id="text-h-get-relative-age">
<p>
Given a UNIX timestamp, return a relative age. E.g., "5s" for a time stamp 5
seconds in the past, or "5M" for 5 months ago.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(9/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-9">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-9">def_lua_func get_relative_age([unix_seconds_float], st0) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.debug(<span class="org-string">"unix_seconds: </span><span class="org-variable-name">#{unix_seconds_float}</span><span class="org-string">"</span>)
  <span class="org-variable-name">unix_seconds</span> = <span class="org-type">Kernel</span>.trunc(unix_seconds_float)
  <span class="org-variable-name">t</span> = <span class="org-type">Timex</span>.from_unix(unix_seconds)
  {<span class="org-elixir-atom">:ok</span>, s} = <span class="org-type">Timex</span>.format(t, <span class="org-string">"{relative}"</span>, <span class="org-elixir-atom">:relative</span>)

  {<span class="org-elixir-atom">:ok</span>, s, st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-get-relative-age-short"></a><code>get_relative_age_short</code><br>
<div class="outline-text-8" id="text-h-get-relative-age-short">
<p>
This is like <code>get_relative_age</code>, but much shorter. It's also not localized.
Below is a table of age ranges and how we display it, where <b>N</b> represents a
number. We treat 1 month to be 4 weeks long.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Age</td>
<td class="org-left">Output</td>
<td class="org-left">Truncation</td>
</tr>

<tr>
<td class="org-left">0 - 59 seconds</td>
<td class="org-left">Ns</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">1 minute - 59 minutes and 59 seconds</td>
<td class="org-left">Nm</td>
<td class="org-left">Seconds</td>
</tr>

<tr>
<td class="org-left">1 - 47 hours 59 minutes and 59 seconds</td>
<td class="org-left">Nh</td>
<td class="org-left">Minutes and seconds</td>
</tr>

<tr>
<td class="org-left">2 days - 6 days, hours 59 minutes and 59 seconds</td>
<td class="org-left">Nd</td>
<td class="org-left">Hours, minutes and seconds</td>
</tr>

<tr>
<td class="org-left">1 weeks - 3 weeks, 6 days, hours 59 minutes and 59 seconds</td>
<td class="org-left">Nw</td>
<td class="org-left">Days, hours, minutes and seconds</td>
</tr>

<tr>
<td class="org-left">1 month - 11 months, 3 weeks, 6 days, hours 59 minutes and 59 seconds</td>
<td class="org-left">NM</td>
<td class="org-left">Weeks, days, hours, minutes and seconds</td>
</tr>

<tr>
<td class="org-left">1 year and older</td>
<td class="org-left">NY</td>
<td class="org-left">Months, weeks, days, hours, minutes and seconds</td>
</tr>
</tbody>
</table>
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(10/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-10">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-10">def_lua_func get_relative_age_short([unix_seconds_float], st0) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.debug(<span class="org-string">"unix_seconds: </span><span class="org-variable-name">#{unix_seconds_float}</span><span class="org-string">"</span>)
  <span class="org-variable-name">t1</span> = <span class="org-type">Kernel</span>.trunc(unix_seconds_float)
  <span class="org-comment-delimiter"># </span><span class="org-comment">t1 = Timex.from_unix(unix_seconds)</span>
  <span class="org-variable-name">t2</span> = <span class="org-type">Timex</span>.now() <span class="org-keyword">|&gt;</span> <span class="org-type">Timex</span>.to_unix()

  <span class="org-variable-name">age_seconds</span> = t2 - t1

  <span class="org-variable-name">age</span> = <span class="org-type">Timex.Duration</span>.from_seconds(age_seconds)

  <span class="org-variable-name">s</span> =
    <span class="org-keyword">cond</span> <span class="org-keyword">do</span>
      <span class="org-type">Timex.Duration</span>.to_minutes(age) &lt; <span class="org-elixir-number">1</span> <span class="org-keyword">-&gt;</span>
        <span class="org-string">"</span><span class="org-variable-name">#{age_seconds}</span><span class="org-string">s"</span>

      <span class="org-type">Timex.Duration</span>.to_hours(age) &lt; <span class="org-elixir-number">1</span> <span class="org-keyword">-&gt;</span>
        <span class="org-variable-name">minutes</span> = <span class="org-type">Kernel</span>.trunc(<span class="org-type">Timex.Duration</span>.to_minutes(age))
        <span class="org-string">"</span><span class="org-variable-name">#{minutes}</span><span class="org-string">m"</span>

      <span class="org-type">Timex.Duration</span>.to_hours(age) &lt; <span class="org-elixir-number">48</span> <span class="org-keyword">-&gt;</span>
        <span class="org-variable-name">hours</span> = <span class="org-type">Kernel</span>.trunc(<span class="org-type">Timex.Duration</span>.to_hours(age))
        <span class="org-string">"</span><span class="org-variable-name">#{hours}</span><span class="org-string">h"</span>

      <span class="org-type">Timex.Duration</span>.to_days(age) &lt; <span class="org-elixir-number">14</span> <span class="org-keyword">-&gt;</span>
        <span class="org-variable-name">days</span> = <span class="org-type">Kernel</span>.trunc(<span class="org-type">Timex.Duration</span>.to_days(age))
        <span class="org-string">"</span><span class="org-variable-name">#{days}</span><span class="org-string">d"</span>

      <span class="org-type">Timex.Duration</span>.to_days(age) &lt; <span class="org-elixir-number">30</span> <span class="org-keyword">-&gt;</span>
        <span class="org-variable-name">weeks</span> = <span class="org-type">Kernel</span>.trunc(<span class="org-type">Timex.Duration</span>.to_days(age) / <span class="org-elixir-number">7</span>)
        <span class="org-string">"</span><span class="org-variable-name">#{weeks}</span><span class="org-string">w"</span>

      <span class="org-type">Timex.Duration</span>.to_days(age) &lt; <span class="org-elixir-number">365</span> <span class="org-keyword">-&gt;</span>
        <span class="org-variable-name">months</span> = <span class="org-type">Kernel</span>.trunc(<span class="org-type">Timex.Duration</span>.to_days(age) / <span class="org-elixir-number">30</span>)
        <span class="org-string">"</span><span class="org-variable-name">#{months}</span><span class="org-string">M"</span>

      <span class="org-elixir-atom">true</span> <span class="org-keyword">-&gt;</span>
        <span class="org-variable-name">years</span> = <span class="org-type">Kernel</span>.trunc(<span class="org-type">Timex.Duration</span>.to_days(age) / <span class="org-elixir-number">365</span>)
        <span class="org-string">"</span><span class="org-variable-name">#{years}</span><span class="org-string">Y"</span>
    <span class="org-keyword">end</span>

  {<span class="org-elixir-atom">:ok</span>, s, st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>

<li><a id="h-get-truncated-personal-moniker"></a><code>get_truncated_personal_moniker</code><br>
<div class="outline-text-8" id="text-h-get-truncated-personal-moniker">
<p>
Given a first and last name, shorten it to the first name's initial and the last
name, truncating the last name as necessary.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_srs_helpers</a></span>(11/11) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_srs_helpers-11">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_srs_helpers-11">def_lua_func get_truncated_personal_moniker([first_last_name, max], st0) <span class="org-keyword">do</span>
  <span class="org-type">Logger</span>.debug(<span class="org-string">"first_last_name: </span><span class="org-variable-name">#{first_last_name}</span><span class="org-string">"</span>)

  <span class="org-variable-name">s</span> =
    <span class="org-keyword">case</span> <span class="org-type">String</span>.split(first_last_name) <span class="org-keyword">do</span>
      [] <span class="org-keyword">-&gt;</span>
        <span class="org-string">"?"</span>

      [name] <span class="org-keyword">-&gt;</span>
        <span class="org-type">String</span>.slice(name, <span class="org-elixir-number">0</span>..(max - <span class="org-elixir-number">1</span>))

      [first_name, last_name] <span class="org-keyword">-&gt;</span>
        <span class="org-type">String</span>.first(first_name) &lt;&gt; <span class="org-type">String</span>.slice(last_name, <span class="org-elixir-number">0</span>..(max - <span class="org-elixir-number">2</span>))

      names <span class="org-keyword">-&gt;</span>
        <span class="org-type">String</span>.first(<span class="org-type">List</span>.first(names)) &lt;&gt; <span class="org-type">String</span>.slice(<span class="org-type">List</span>.last(names), <span class="org-elixir-number">0</span>..(max - <span class="org-elixir-number">2</span>))
    <span class="org-keyword">end</span>

  {<span class="org-elixir-atom">:ok</span>, s, st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-h-Messaging" class="outline-6">
<h6 id="h-Messaging"><span class="section-number-6">6.5.7.2.7.</span> Messaging</h6>
<div class="outline-text-6" id="text-h-Messaging">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_pubsub</a></span>(1/1) <span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_pubsub">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_pubsub">def_lua_func broadcast([topic, message_ref], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">message</span> = <span class="org-type">Luerl</span>.decode(st0, message_ref) <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map_atomic_keys()

  <span class="org-variable-name">payload</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map_atomic_keys(message.payload)
  <span class="org-variable-name">payload</span> = <span class="org-type">Map</span>.put(payload, <span class="org-elixir-atom">:time</span>, <span class="org-type">Calendar</span>.strftime(<span class="org-type">Timex</span>.local(), <span class="org-string">"%H:%M:%S"</span>))
  <span class="org-variable-name">message</span> = <span class="org-type">Map</span>.put(message, <span class="org-elixir-atom">:payload</span>, payload)

  <span class="org-type">Phoenix.PubSub</span>.broadcast(<span class="org-type">Melbyd.PubSub</span>, topic, message)

  <span class="org-comment-delimiter"># </span><span class="org-comment">There is nothing to return back to Lua.</span>
  {<span class="org-elixir-atom">:ok</span>, <span class="org-elixir-atom">nil</span>, st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>

<ol class="org-ol">
<li><a id="h-Functions-for-instantiating-an-SLG"></a>Functions for instantiating an SLG<br>
<div class="outline-text-7" id="text-h-Functions-for-instantiating-an-SLG">
<p>
Here, <code>topics</code> is a list of topic names (strings) which we want to subscribe to.
The Lua config should know what topics to subscribe to.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_sps</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_sps">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_sps">def_lua_func get_shell_messages([shell_pid, resources_ref, env_vars_ref], st0) <span class="org-keyword">do</span>
  <span class="org-variable-name">resource_luerl_tables</span> =
    <span class="org-type">Luerl</span>.decode(st0, resources_ref) <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.array_to_native_list()
  <span class="org-variable-name">env_vars</span> = <span class="org-type">Luerl</span>.decode(st0, env_vars_ref) <span class="org-keyword">|&gt;</span> <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map()

  <span class="org-comment-delimiter"># </span><span class="org-comment">Topic handlers is a map where the key is the resource type (e.g.,</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">"srs_Git"), and the handler is the Lua function named "should_keep_message"</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">for that resource.</span>
  <span class="org-variable-name">topic_handlers</span> =
    resource_luerl_tables
    <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.map(<span class="org-keyword">fn</span> resource_luerl_table <span class="org-keyword">-&gt;</span>
      <span class="org-variable-name">resource</span> = <span class="org-type">Melbyd.LuerlUtil</span>.table_to_native_map(resource_luerl_table)
      {<span class="org-string">"srs_"</span> &lt;&gt; resource[<span class="org-string">"type"</span>], resource[<span class="org-string">"should_keep_message"</span>]}
    <span class="org-keyword">end</span>)
    <span class="org-keyword">|&gt;</span> <span class="org-type">Map</span>.new()

  <span class="org-variable-name">messages</span> = <span class="org-type">Melbyd.ShellLogger</span>.get_messages(shell_pid, topic_handlers, env_vars)

  {<span class="org-elixir-atom">:ok</span>, messages, st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</li>
</ol>
</div>

<div id="outline-container-h-Other-1" class="outline-6">
<h6 id="h-Other-1"><span class="section-number-6">6.5.7.2.8.</span> Other</h6>
<div class="outline-text-6" id="text-h-Other-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luasdk">melbyd_luasdk_misc</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdk_misc">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdk_misc">def_lua_func log([msg], st0) <span class="org-keyword">do</span>
  <span class="org-keyword">case</span> msg <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">If msg is not a primitive (e.g., a string), then decode it first. This way</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">we can handle Lua tables.</span>
    x <span class="org-keyword">when</span> is_tuple(x) <span class="org-keyword">-&gt;</span>
      <span class="org-variable-name">y</span> = <span class="org-type">Luerl</span>.decode(st0, x)
      <span class="org-type">Logger</span>.debug(<span class="org-string">"(Melbyd Lua SDK debug (string)): </span><span class="org-variable-name">#{inspect(y, limit: :infinity, binaries: :as_strings)}</span><span class="org-string">"</span>)
      <span class="org-type">Logger</span>.debug(<span class="org-string">"(Melbyd Lua SDK debug (binary)): </span><span class="org-variable-name">#{inspect(y, limit: :infinity, binaries: :as_binaries)}</span><span class="org-string">"</span>)
    x <span class="org-keyword">-&gt;</span>
      <span class="org-type">Logger</span>.debug(<span class="org-string">"(Melbyd Lua SDK debug (string)): </span><span class="org-variable-name">#{inspect(x, limit: :infinity, binaries: :as_strings)}</span><span class="org-string">"</span>)
      <span class="org-type">Logger</span>.debug(<span class="org-string">"(Melbyd Lua SDK debug (binary)): </span><span class="org-variable-name">#{inspect(x, limit: :infinity, binaries: :as_binaries)}</span><span class="org-string">"</span>)
  <span class="org-keyword">end</span>
  {<span class="org-elixir-atom">:ok</span>, <span class="org-elixir-atom">nil</span>, st0}
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Boilerplate-1" class="outline-5">
<h5 id="h-Boilerplate-1"><span class="section-number-5">6.5.7.3.</span> Boilerplate</h5>
<div class="outline-text-5" id="text-h-Boilerplate-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#code-Melbyd-LuaInterop--code">melbyd_luasdkhelper</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luasdkhelper">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luasdkhelper"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.LuaSdkLoadable</span> <span class="org-keyword">do</span>
  <span class="org-keyword">require</span> <span class="org-type">Logger</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">This prevents programmer errors where we no longer autogenerate an install/1</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">function. This will probably never happen, but because we don't have types</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">this is the best we can do.</span>
  <span class="org-elixir-attribute">@callback</span> install(<span class="org-type">Lua</span>.t()) :: <span class="org-type">Lua</span>.t()

  <span class="org-keyword">alias</span> <span class="org-type">Melbyd.LuaSdkLoader</span>, <span class="org-elixir-atom">as:</span> <span class="org-type">Loader</span>

  <span class="org-keyword">defmacro</span> __using__(<span class="org-comment">_options</span> \\ []) <span class="org-keyword">do</span>
    <span class="org-keyword">quote</span> <span class="org-keyword">do</span>
      <span class="org-keyword">import</span> <span class="org-keyword">unquote</span>(<span class="org-constant">__MODULE__</span>)
      <span class="org-type">Module</span>.register_attribute(<span class="org-constant">__MODULE__</span>, <span class="org-elixir-atom">:loadable_functions</span>, <span class="org-elixir-atom">accumulate:</span> <span class="org-elixir-atom">true</span>)
      <span class="org-elixir-attribute">@before_compile</span> <span class="org-keyword">unquote</span>(<span class="org-constant">__MODULE__</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Maybe this macro should have been named "final_macro_expansion" or</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">something. But the point is that we run this after all other macros are</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">expanded, *just* before compilation to Erlang bytecode begins.</span>
  <span class="org-keyword">defmacro</span> __before_compile__(<span class="org-comment">_env</span>) <span class="org-keyword">do</span>
    <span class="org-keyword">quote</span> <span class="org-keyword">do</span>

      <span class="org-comment-delimiter"># </span><span class="org-comment">install/1 is called by Luerl's load_module() function. This is documented in</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">https://github.com/rvirding/luerl/blob/bc655178dc8f59f29199fd7df77a7c314c0f2e02/src/NOTES#L115.</span>
      <span class="org-keyword">def</span> <span class="org-function-name">install</span>(st) <span class="org-keyword">do</span>
        <span class="org-variable-name">table</span> = <span class="org-type">Loader</span>.load(<span class="org-elixir-attribute">@loadable_functions</span>, <span class="org-constant">__MODULE__</span>)
        <span class="org-elixir-atom">:luerl_heap</span>.alloc_table(table, st)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Note that all Elixir expressions, when quoted (converted into an AST), have</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">the form of {atom, context, arguments}.</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Here we pattern match the arguments so that we only process those function</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">declarations that want 2 arguments, because that's what Luerl requires of</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">us. (First argument is a  list of arguments passed in from the invocation of</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">this function from Lua, and the second argument is the Lua VM state.)</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">We define 2 functions for every def_lua_func macro. The first is a private</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">function that actually captures the business logic. The second is a wrapper</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">that makes sure that the function behaves as a proper Luerl-compatible</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">function, in that it always returns things through the Loader.to_luerl/1</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">helper function. We basically use this to force all functions to behave</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">properly.</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">"dlf_block" means "def_lua_func block".</span>
  <span class="org-keyword">defmacro</span> def_lua_func({f_name, f_context, [<span class="org-comment">_args_from_lua</span>, <span class="org-comment">_st</span>] = f_args} = <span class="org-comment">_elixir_expression</span>,
             <span class="org-elixir-atom">do:</span> dlf_block
           ) <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">If a user created a function named "foo", then create another Elixir</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">function named as "__handle_lua_call__foo".</span>
    <span class="org-variable-name">prefixed_f_name</span> = <span class="org-type">String</span>.to_atom(<span class="org-string">"__handle_lua_call__"</span> &lt;&gt; <span class="org-type">Atom</span>.to_string(f_name))
    <span class="org-variable-name">prefixed_f_name_internal</span> = <span class="org-type">String</span>.to_atom(<span class="org-string">"__internal__"</span> &lt;&gt; <span class="org-type">Atom</span>.to_string(f_name))

    <span class="org-keyword">quote</span> <span class="org-keyword">do</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Register this function call (make a note of it) into the</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">@loadable_functions attribute.</span>
      <span class="org-elixir-attribute">@loadable_functions</span> <span class="org-keyword">unquote</span>(prefixed_f_name)

      <span class="org-comment-delimiter"># </span><span class="org-comment">This is the wrapper function that is publicly visible to Luerl. It runs</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">the business logic and makes sure to wrap the return values in a form</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">that Luerl expects by piping to Loader.to_luerl/1.</span>
      <span class="org-keyword">def</span> <span class="org-keyword">unquote</span>(prefixed_f_name)(args_list_from_lua, lua_state) <span class="org-keyword">do</span>
        <span class="org-keyword">unquote</span>(prefixed_f_name_internal)(args_list_from_lua, lua_state)
          <span class="org-keyword">|&gt;</span> <span class="org-type">Loader</span>.to_luerl
      <span class="org-keyword">end</span>

      <span class="org-comment-delimiter"># </span><span class="org-comment">This is the private function that actually houses the business logic.</span>
      <span class="org-keyword">defp</span> <span class="org-keyword">unquote</span>({prefixed_f_name_internal, f_context, f_args}) <span class="org-keyword">do</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Define the function body (written by the user in the "do ... end"</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">part) as-is.</span>
        <span class="org-keyword">unquote</span>(dlf_block)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">The point of this module is so that we can minimize our use of macros. This</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">way, we minimize the amount of code we generate dynamically to only generate</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">the bare minimum to get things working.</span>
<span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.LuaSdkLoader</span> <span class="org-keyword">do</span>

  <span class="org-keyword">def</span> <span class="org-function-name">load</span>(elixir_funcs, module) <span class="org-keyword">do</span>
    <span class="org-type">Enum</span>.map(elixir_funcs, <span class="org-keyword">fn</span> elixir_func <span class="org-keyword">-&gt;</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">From the Lua side, we can call an Elixir function by its "short" name,</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">without the leading "__handle_lua_call__" prefix.</span>
      <span class="org-variable-name">lua_func_name</span> =
        <span class="org-type">String</span>.replace_prefix(<span class="org-type">Atom</span>.to_string(elixir_func), <span class="org-string">"__handle_lua_call__"</span>, <span class="org-string">""</span>)

      <span class="org-comment-delimiter"># </span><span class="org-comment">The arity is fixed at 2, because (FIXME: add link).</span>
      <span class="org-variable-name">elixir_func_reference</span> = <span class="org-type">Function</span>.capture(module, elixir_func, <span class="org-elixir-number">2</span>)
      {lua_func_name, {<span class="org-elixir-atom">:erl_func</span>, elixir_func_reference}}
    <span class="org-keyword">end</span>)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Helper function for returning things back to Luerl (Lua VM) from an autoloaded Elixir</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">module.</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Through trial and error, it appears that the return value must be a tuple</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">where the first element is what's returned to Lua and the second element is</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">the new state of the Lua VM.</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">The first element itself has to be a list of 2 elements, of the form</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">[lua_return_value, error]. If we don't do this we get a strange error from</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Elixir. The error, if not nil, must be a string.</span>
  <span class="org-comment-delimiter">#</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">For consistency with idiomatic Elixir, we make callers use the familiar</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">"{:ok, foo}" and "{:error, message}" patterns and translate them here to</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">make luerl happy.</span>
  <span class="org-keyword">def</span> <span class="org-function-name">to_luerl</span>(val) <span class="org-keyword">do</span>
    <span class="org-keyword">case</span> val <span class="org-keyword">do</span>
      {<span class="org-elixir-atom">:ok</span>, result, st} <span class="org-keyword">-&gt;</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">We need to encode results before the Lua functions can use them.</span>
        {result_encoded, st1} = <span class="org-type">Luerl</span>.encode(st, result)
        {[result_encoded, <span class="org-elixir-atom">nil</span>], st1}
      {<span class="org-elixir-atom">:error</span>, msg, st} <span class="org-keyword">-&gt;</span> {[<span class="org-elixir-atom">nil</span>, msg], st}
      got <span class="org-keyword">-&gt;</span> <span class="org-keyword">raise</span> <span class="org-string">"got </span><span class="org-variable-name">#{got}</span><span class="org-string">, expected {:ok, result, st} or {:error, msg, st}"</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Luerl-util" class="outline-5">
<h5 id="h-Luerl-util"><span class="section-number-5">6.5.7.4.</span> Luerl util</h5>
<div class="outline-text-5" id="text-h-Luerl-util">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#code-Melbyd-LuaInterop--code">melbyd_luerl_util</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luerl_util">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luerl_util"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.LuerlUtil</span> <span class="org-keyword">do</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luerl_util_table_lookup">melbyd_luerl_util_table_lookup</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luerl_util_array_to_native_list">melbyd_luerl_util_array_to_native_list</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luerl_util_table_to_native_map">melbyd_luerl_util_table_to_native_map</a></span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyd_luerl_util_table_to_native_map_atomic_keys">melbyd_luerl_util_table_to_native_map_atomic_keys</a></span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>

<div id="outline-container-h-Reading-from-Lua-tables-returned-by-Luerl" class="outline-6">
<h6 id="h-Reading-from-Lua-tables-returned-by-Luerl"><span class="section-number-6">6.5.7.4.1.</span> Reading from Lua tables returned by Luerl</h6>
<div class="outline-text-6" id="text-h-Reading-from-Lua-tables-returned-by-Luerl">
<p>
Luerl returns Lua tables to Elixir as a list of tuples, where the first element
is the index and the second element is the value. This scheme is used to
represent both Lua arrays (where the keys are positive integers starting with
<code>1</code>) and tables (where the keys can be arbitrary string values).
</p>

<p>
What we want to do is to be able to read deeply nested values from such a table,
by providing a list of keys to look up. For example, for a native Elixir map
with nested maps, the syntax would look like this:
</p>

<div class="org-src-container"><pre class="src src-elixir" id="nil-26">foo_map[<span class="org-string">"a"</span>][<span class="org-string">"b"</span>][<span class="org-string">"c"</span>]
</pre></div><p>
and we want to do something similar to a table returned by Luerl. Something like this:
</p>

<div class="org-src-container"><pre class="src src-elixir" id="nil-27">lookup(foo_table, [<span class="org-string">"a"</span>, <span class="org-string">"b"</span>, <span class="org-string">"c"</span>])
</pre></div><p>
The key (no pun intended) is to do a linear search of all tuples to find the
right tuple, and to repeat this search on the resulting value as many times as
necessary.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luerl_util">melbyd_luerl_util_table_lookup</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luerl_util_table_lookup">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luerl_util_table_lookup"><span class="org-keyword">def</span> <span class="org-function-name">table_lookup</span>(<span class="org-comment">_t</span>, []) <span class="org-keyword">do</span>
  <span class="org-keyword">raise</span> <span class="org-type">ArgumentError</span>, <span class="org-elixir-atom">message:</span> <span class="org-string">"lookup_keys cannot be empty"</span>
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">table_lookup</span>(t, lookup_keys) <span class="org-keyword">do</span>
  <span class="org-type">Enum</span>.reduce(lookup_keys, t, <span class="org-keyword">fn</span> lookup_key, val_so_far <span class="org-keyword">-&gt;</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> <span class="org-type">Kernel</span>.is_list(val_so_far) <span class="org-keyword">do</span>
      <span class="org-keyword">raise</span> <span class="org-type">ArgumentError</span>, <span class="org-elixir-atom">message:</span> <span class="org-string">"val_so_far '</span><span class="org-variable-name">#{inspect(val_so_far)}</span><span class="org-string">' is not a list"</span>
    <span class="org-keyword">end</span>

    <span class="org-type">Enum</span>.map(val_so_far, &amp;verify_table_tuple/<span class="org-elixir-number">1</span>)

    <span class="org-variable-name">found</span> = <span class="org-type">Enum</span>.find(val_so_far, <span class="org-keyword">fn</span> {t_key, <span class="org-comment">_t_val</span>} <span class="org-keyword">-&gt;</span> t_key == lookup_key <span class="org-keyword">end</span>)

    <span class="org-keyword">if</span> found == <span class="org-elixir-atom">nil</span> <span class="org-keyword">do</span>
      <span class="org-keyword">raise</span> <span class="org-type">ArgumentError</span>, <span class="org-elixir-atom">message:</span> <span class="org-string">"lookup_key '</span><span class="org-variable-name">#{lookup_key}</span><span class="org-string">' not found"</span>
    <span class="org-keyword">else</span>
      {<span class="org-comment">_t_key</span>, t_val} = found
      t_val
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">verify_table_tuple</span>({k, <span class="org-comment">_v</span>}) <span class="org-keyword">when</span> is_binary(k) <span class="org-keyword">do</span>
  <span class="org-elixir-atom">:ok</span>
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">verify_table_tuple</span>(x) <span class="org-keyword">do</span>
  <span class="org-keyword">raise</span> <span class="org-type">ArgumentError</span>, <span class="org-elixir-atom">message:</span> <span class="org-string">"element '</span><span class="org-variable-name">#{inspect(x)}</span><span class="org-string">' is not a well-formed tuple"</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Array-to-native-list" class="outline-6">
<h6 id="h-Array-to-native-list"><span class="section-number-6">6.5.7.4.2.</span> Array to native list</h6>
<div class="outline-text-6" id="text-h-Array-to-native-list">
<p>
Luerl returns arrays as a list of tuples, with each element being of the form
<code>{k, v}</code> where <code>k</code> is the positive integer index and <code>v</code> is some other arbitrary
value.
</p>

<p>
Here we convert such a list of tuples into a plain list with all of the indices
removed. We expect the indices to be well-formed, meaning that the indices are
contiguous, ascending, and start from <code>1</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luerl_util">melbyd_luerl_util_array_to_native_list</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luerl_util_array_to_native_list">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luerl_util_array_to_native_list"><span class="org-keyword">def</span> <span class="org-function-name">array_to_native_list</span>(a) <span class="org-keyword">do</span>
  <span class="org-type">Enum</span>.map(a, &amp;verify_array_tuple/<span class="org-elixir-number">1</span>)

  {<span class="org-constant">_</span>, native_list} =
    <span class="org-type">Enum</span>.reduce(a, {<span class="org-elixir-number">0</span>, []}, <span class="org-keyword">fn</span> {k, v}, {i, native_list} <span class="org-keyword">-&gt;</span>
      <span class="org-keyword">if</span> k == i + <span class="org-elixir-number">1</span> <span class="org-keyword">do</span>
        {k, [v | native_list]}
      <span class="org-keyword">else</span>
        <span class="org-keyword">raise</span> <span class="org-type">ArgumentError</span>, <span class="org-elixir-atom">message:</span> <span class="org-string">"expected index </span><span class="org-variable-name">#{i + 1}</span><span class="org-string"> for element '</span><span class="org-variable-name">#{inspect({k, v}</span><span class="org-string">)}'"</span>
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>)

  <span class="org-type">Enum</span>.reverse(native_list)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">verify_array_tuple</span>({k, <span class="org-comment">_v</span>}) <span class="org-keyword">when</span> is_integer(k) <span class="org-keyword">do</span>
  <span class="org-elixir-atom">:ok</span>
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">verify_array_tuple</span>(x) <span class="org-keyword">do</span>
  <span class="org-keyword">raise</span> <span class="org-type">ArgumentError</span>, <span class="org-elixir-atom">message:</span> <span class="org-string">"element '</span><span class="org-variable-name">#{inspect(x)}</span><span class="org-string">' is not a well-formed tuple"</span>
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Table-to-native-map" class="outline-6">
<h6 id="h-Table-to-native-map"><span class="section-number-6">6.5.7.4.3.</span> Table to native map</h6>
<div class="outline-text-6" id="text-h-Table-to-native-map">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luerl_util">melbyd_luerl_util_table_to_native_map</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luerl_util_table_to_native_map">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luerl_util_table_to_native_map"><span class="org-keyword">def</span> <span class="org-function-name">table_to_native_map</span>(t) <span class="org-keyword">do</span>
  <span class="org-type">Enum</span>.map(t, &amp;verify_table_tuple/<span class="org-elixir-number">1</span>)
  <span class="org-type">Map</span>.new(t)
<span class="org-keyword">end</span>
</pre></div></div><p>
Below is a specialized version which also converts all keys to atoms. This
should only be used for cases where the keys are known to be some subset, as
atoms are never garbage-collected.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyd_luerl_util">melbyd_luerl_util_table_to_native_map_atomic_keys</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyd_luerl_util_table_to_native_map_atomic_keys">&#x1f517;</a></span></div><pre class="src src-elixir" id="__NREF__melbyd_luerl_util_table_to_native_map_atomic_keys"><span class="org-keyword">def</span> <span class="org-function-name">table_to_native_map_atomic_keys</span>(t) <span class="org-keyword">do</span>
  <span class="org-type">Enum</span>.map(t, &amp;verify_table_tuple/<span class="org-elixir-number">1</span>)
  <span class="org-type">Enum</span>.map(t, <span class="org-keyword">fn</span> {k, v} <span class="org-keyword">-&gt;</span> {<span class="org-type">String</span>.to_atom(k), v} <span class="org-keyword">end</span>) <span class="org-keyword">|&gt;</span> <span class="org-type">Map</span>.new()
<span class="org-keyword">end</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Lua-tables-to-Elixir-maps" class="outline-6">
<h6 id="h-Lua-tables-to-Elixir-maps"><span class="section-number-6">6.5.7.4.4.</span> Lua tables to Elixir maps</h6>
<div class="outline-text-6" id="text-h-Lua-tables-to-Elixir-maps">
<p>
The reason why we don't convert from a Lua table to an Elixir Map or List
(recursively) is because we are not sure how to handle the empty table <code>{}</code> in
Lua &#x2014; it can represent either an empty Map or List. See
<a href="https://github.com/rvirding/luerl/wiki/0.7-Data-representation">https://github.com/rvirding/luerl/wiki/0.7-Data-representation</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-h-Tests" class="outline-5">
<h5 id="h-Tests"><span class="section-number-5">6.5.7.5.</span> Tests</h5>
<div class="outline-text-5" id="text-h-Tests">
<p>
We have a Lua smoke test to check that Lua/Elixir interop is working. This tests
the sample Lua configuration to ensure that it is a fully working example.
</p>

<div class="org-src-container"><pre class="src src-elixir" id="nil-28"><span class="org-keyword">import</span> <span class="org-type">Config</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Log everything during tests. We want to see all logs in case a test fails.</span>
config <span class="org-elixir-atom">:logger</span>,
  <span class="org-elixir-atom">level:</span> <span class="org-elixir-atom">:debug</span>
</pre></div><div class="org-src-container"><pre class="src src-elixir" id="nil-29"><span class="org-keyword">defmodule</span> <span class="org-type">MelbydTest</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">ExUnit.Case</span>
  <span class="org-keyword">require</span> <span class="org-type">Logger</span>
  <span class="org-keyword">require</span> <span class="org-type">WaitForIt</span>

  setup_all <span class="org-keyword">do</span>
    <span class="org-type">IO</span>.puts(<span class="org-string">"resetting fake_kube_config"</span>)
    <span class="org-variable-name">content</span> = <span class="org-string">"current-context=one\ncurrent-namespace=default\n"</span>
    {<span class="org-elixir-atom">:ok</span>, mix_root} = <span class="org-type">File</span>.cwd()
    <span class="org-variable-name">path</span> = mix_root &lt;&gt; <span class="org-string">"/test/fake_kube_config"</span>
    <span class="org-type">File</span>.write(path, content)
    <span class="org-elixir-atom">:ok</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Generate a unique-looking 7-digit shell pid based on the module and test</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">name. This is important because each test must use a unique shell pid. The</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">alternative to using this helper function is to maually assign a unique</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">shell pid for each test case, which is error-prone.</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">get_unique_shell_pid</span>(module_name_atom, test_name_atom) <span class="org-keyword">do</span>
    <span class="org-variable-name">module_test_str</span> = <span class="org-type">Atom</span>.to_string(module_name_atom) &lt;&gt; <span class="org-type">Atom</span>.to_string(test_name_atom)
    <span class="org-variable-name">pid_length</span> = <span class="org-elixir-number">7</span>

    <span class="org-elixir-atom">:crypto</span>.hash(<span class="org-elixir-atom">:md5</span>, module_test_str)
    <span class="org-keyword">|&gt;</span> <span class="org-elixir-atom">:binary</span>.decode_unsigned()
    <span class="org-keyword">|&gt;</span> <span class="org-type">Integer</span>.to_string()
    <span class="org-keyword">|&gt;</span> <span class="org-type">String</span>.graphemes()
    <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.drop_while(<span class="org-keyword">fn</span> c <span class="org-keyword">-&gt;</span> c == <span class="org-string">"0"</span> <span class="org-keyword">end</span>)
    <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.take(pid_length)
    <span class="org-keyword">|&gt;</span> <span class="org-type">Enum</span>.join()
    <span class="org-keyword">|&gt;</span> <span class="org-type">String</span>.pad_trailing(pid_length, <span class="org-string">"0"</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">run_git_script</span>(path, shell_script) <span class="org-keyword">do</span>
    <span class="org-variable-name">preamble</span> = <span class="org-string">"""</span>
<span class="org-string">    set -euo pipefail</span>
<span class="org-string">    clock_time="Thu, 07 Apr 2005 15:13:13 -0700"</span>
<span class="org-string">    export GIT_AUTHOR_DATE="${clock_time}"</span>
<span class="org-string">    export GIT_AUTHOR_NAME=a</span>
<span class="org-string">    export GIT_AUTHOR_EMAIL=a@b.edu</span>
<span class="org-string">    export GIT_COMMITTER_DATE="${clock_time}"</span>
<span class="org-string">    export GIT_COMMITTER_NAME=d</span>
<span class="org-string">    export GIT_COMMITTER_EMAIL=e@f.edu</span>
<span class="org-string">    export GIT_CONFIG_GLOBAL=1</span>
<span class="org-string">    export GIT_CONFIG_NOSYSTEM=1</span>
<span class="org-string">    """</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Run shell script at the given path. The stderr_to_stdout is so that we</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">capture all results into the "output" variable, to be sent to the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Logger.debug. Otherwise, the stderr output is not captured and always</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">displayed, going against the intent of `import ExUnit.CaptureLog` above.</span>
    {output, ret} =
      <span class="org-type">System</span>.cmd(<span class="org-string">"bash"</span>, [<span class="org-string">"-c"</span>, preamble &lt;&gt; shell_script], <span class="org-elixir-atom">cd:</span> path, <span class="org-elixir-atom">stderr_to_stdout:</span> <span class="org-elixir-atom">true</span>)

    <span class="org-type">Logger</span>.debug(<span class="org-string">"got bash output: </span><span class="org-variable-name">#{inspect(output)}</span><span class="org-string">"</span>)

    assert ret == <span class="org-elixir-number">0</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">mk_tmp_dir</span>(prefix) <span class="org-keyword">do</span>
    <span class="org-type">Temp</span>.track!()

    {<span class="org-elixir-atom">:ok</span>, dir_path} = <span class="org-type">Temp</span>.mkdir(prefix)
    <span class="org-comment-delimiter"># </span><span class="org-comment">On Darwin, /tmp is symlinked to /private/tmp. Temp.mkdir() (and even</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Elixir's System.temp_dir()) uses "/tmp" as the temp directory. However,</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">this doesn't stop other Elixir libraries or even our own code (shelling</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">out to external commands) from using the non-symlinked version</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">"/private/tmp". So, make ourselves also use the dereferenced</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">(non-symlinked) path for consistency.</span>
    <span class="org-type">Logger</span>.warning(<span class="org-string">"dir_path </span><span class="org-variable-name">#{dir_path}</span><span class="org-string">"</span>)
    <span class="org-keyword">if</span> <span class="org-elixir-atom">:os</span>.type() == {<span class="org-elixir-atom">:unix</span>, <span class="org-elixir-atom">:darwin</span>} <span class="org-keyword">do</span>
      <span class="org-string">"/private"</span> &lt;&gt; dir_path
    <span class="org-keyword">else</span>
      dir_path
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Initialize state (AGENT)</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">init_lua_reader</span>() <span class="org-keyword">do</span>
    <span class="org-type">Agent</span>.start_link(<span class="org-keyword">fn</span> <span class="org-keyword">-&gt;</span> <span class="org-string">""</span> <span class="org-keyword">end</span>)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Read state (CONSUMER)</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">get_lua_reader_state</span>(pid) <span class="org-keyword">do</span>
    <span class="org-type">Agent</span>.get(pid, &amp; &amp;1)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Update state (PRODUCER)</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">update_lua_reader_state</span>(pid, shell_pid, lua_script, env_vars, ansi_escapes_allowed) <span class="org-keyword">do</span>
    <span class="org-keyword">case</span> <span class="org-type">Melbyd.LuaInterop</span>.run(lua_script, [<span class="org-string">"Config"</span>, <span class="org-string">"view"</span>], [env_vars, shell_pid]) <span class="org-keyword">do</span>
      {<span class="org-elixir-atom">:ok</span>, [got]} <span class="org-keyword">-&gt;</span>
        <span class="org-type">Agent</span>.update(pid, <span class="org-keyword">fn</span> <span class="org-constant">_</span> <span class="org-keyword">-&gt;</span>
          <span class="org-keyword">if</span> ansi_escapes_allowed <span class="org-keyword">do</span>
            got
          <span class="org-keyword">else</span>
            strip_ansi(got)
          <span class="org-keyword">end</span>
        <span class="org-keyword">end</span>)

      x <span class="org-keyword">-&gt;</span>
        <span class="org-type">Logger</span>.error(<span class="org-string">"failed to run lua script: </span><span class="org-variable-name">#{x}</span><span class="org-string">"</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">expect</span>(want, pid, shell_pid, lua_script, env_vars, ansi_escapes_allowed) <span class="org-keyword">do</span>
    update_lua_reader_state(pid, shell_pid, lua_script, env_vars, ansi_escapes_allowed)
    get_lua_reader_state(pid) =~ want
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Change argument order to match assert_output_substrings.</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">assert_output_string</span>(want, shell_pid, lua_script, env_vars, ansi_escapes_allowed) <span class="org-keyword">do</span>
    {<span class="org-elixir-atom">:ok</span>, pid} = init_lua_reader()

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wait up to 5 seconds (5 poll events) to see if we can get some output that</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">has our =want= substring in it.</span>
    <span class="org-type">WaitForIt</span>.wait(
      expect(want, pid, shell_pid, lua_script, env_vars, ansi_escapes_allowed),
      <span class="org-elixir-atom">frequency:</span> <span class="org-elixir-number">1000</span>,
      <span class="org-elixir-atom">timeout:</span> <span class="org-elixir-number">5_000</span>
    )

    <span class="org-variable-name">got</span> = get_lua_reader_state(pid)
    <span class="org-type">Agent</span>.stop(pid)
    assert got =~ want
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">strip_ansi</span>(s) <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">This is a terrible regex, but performs adequately because our ANSI codes</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">are well-formed.</span>
    <span class="org-type">Regex</span>.replace(<span class="org-builtin">~r</span>/<span class="org-string">\e\[([0-9;])*m</span>/, s, <span class="org-string">""</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">assert_output_substrings</span>(
         want_substrs,
         shell_pid,
         lua_script,
         env_vars,
         ansi_escapes_allowed
       ) <span class="org-keyword">do</span>
    {<span class="org-elixir-atom">:ok</span>, pid} = init_lua_reader()

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wait for the last substring to appear.</span>
    <span class="org-type">WaitForIt</span>.wait(
      expect(<span class="org-type">List</span>.last(want_substrs), pid, shell_pid, lua_script, env_vars, ansi_escapes_allowed),
      <span class="org-elixir-atom">frequency:</span> <span class="org-elixir-number">1000</span>,
      <span class="org-elixir-atom">timeout:</span> <span class="org-elixir-number">5_000</span>
    )
    <span class="org-comment-delimiter"># </span><span class="org-comment">Alternate: wait for all substrings to appear. But actually, this is broken</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">because we run the lua script too many times (once for each substring); so</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">then our backend will purge any already-broadcasted shell message. The</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">right approach is to wait up to 5 seconds, and during that time do fetches</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">1x per second, and for each fetch we should check how many of the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">substrings have matched, and NOT re-check those already-matched substrings</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">in the next iteration. That is, we should match as much as possible each</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">time we run the lua script and fetch (this way different parts of the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">output string can match what we want overall).</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">WaitForIt.wait(</span>
    <span class="org-comment-delimiter">#  </span><span class="org-comment">Enum.map(</span>
    <span class="org-comment-delimiter">#    </span><span class="org-comment">want_substrs,</span>
    <span class="org-comment-delimiter">#    </span><span class="org-comment">fn s -&gt; expect(s, pid, shell_pid, lua_script, env_vars, ansi_escapes_allowed)</span>
    <span class="org-comment-delimiter">#    </span><span class="org-comment">end) |&gt; Enum.all?(),</span>
    <span class="org-comment-delimiter">#  </span><span class="org-comment">frequency: 1000,</span>
    <span class="org-comment-delimiter">#  </span><span class="org-comment">timeout: 5_000</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">)</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Run the Lua script to simulate invoking melbyc.</span>
    <span class="org-variable-name">got</span> = get_lua_reader_state(pid)
    <span class="org-type">Agent</span>.stop(pid)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Check every substring, not just the last one.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Make this stricter by consuming the input in order (the substrings</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">must be found in order).</span>
    <span class="org-type">Enum</span>.each(want_substrs, <span class="org-keyword">fn</span> substr <span class="org-keyword">-&gt;</span>
      assert <span class="org-type">String</span>.contains?(got, substr)
    <span class="org-keyword">end</span>)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">This tag lets us do "mix test --only basic" to only run this test.</span>
  <span class="org-elixir-attribute">@tag</span> <span class="org-elixir-atom">basic:</span> <span class="org-elixir-atom">true</span>
  test <span class="org-string">"basic smoke test (no git repo)"</span>, %{<span class="org-elixir-atom">test:</span> test_name} <span class="org-keyword">do</span>
    <span class="org-variable-name">shell_pid</span> = get_unique_shell_pid(<span class="org-constant">__MODULE__</span>, test_name)

    {<span class="org-elixir-atom">:ok</span>, mix_root} = <span class="org-type">File</span>.cwd()
    <span class="org-variable-name">lua_script</span> = mix_root &lt;&gt; <span class="org-string">"/test/sample/melby.lua"</span>

    <span class="org-variable-name">env_vars</span> = %{
      <span class="org-elixir-atom">KUBECONFIG:</span> mix_root &lt;&gt; <span class="org-string">"/test/fake_kube_config"</span>,
      <span class="org-elixir-atom">HOME:</span> mix_root,
      <span class="org-comment-delimiter"># </span><span class="org-comment">This path doesn't exist, but it doesn't really matter for purposes of</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">testing the path shortening logic.</span>
      <span class="org-elixir-atom">PWD:</span> mix_root &lt;&gt; <span class="org-string">"/go/src/k8s.io/kubernetes"</span>,
      <span class="org-elixir-atom">USER:</span> <span class="org-string">"foo"</span>,
      <span class="org-elixir-atom">HOST:</span> <span class="org-string">"laptop"</span>,
      <span class="org-elixir-atom">MELBY_UNIX_SECONDS:</span> <span class="org-string">"1234567890"</span>,
      <span class="org-elixir-atom">MELBY_TIME_ZONE:</span> <span class="org-string">"America/Los_Angeles"</span>,
      <span class="org-elixir-atom">MELBY_ZSH_KEYMAP_INDICATOR:</span> <span class="org-string">"N"</span>,
      <span class="org-elixir-atom">MELBY_PATH_ALIASES_FILE:</span> mix_root &lt;&gt; <span class="org-string">"/test/sample/path-aliases"</span>,
      <span class="org-elixir-atom">MELBY_DIR:</span> mix_root &lt;&gt; <span class="org-string">"/test/sample"</span>
    }

    assert_output_substrings(
      [
        <span class="org-string">"MELBY_PS1_LINE1"</span>,
        <span class="org-string">"\e[38;2;0;0;0;48;2;255;215;0;1m"</span>,
        <span class="org-string">"02-13 &#37329; 15:31:30 PST"</span>,
        <span class="org-string">"\e[38;2;0;0;0;48;2;255;192;203;1m"</span>,
        <span class="org-string">"02-13 &#37329; 23:31:30 UTC"</span>,
        <span class="org-string">"\e[0m\e[38;2;0;0;0;48;2;135;206;250;1m"</span>,
        <span class="org-string">"&lt;N&gt;"</span>,
        <span class="org-string">"foo@laptop"</span>,
        <span class="org-string">"\e[38;2;0;255;255;1m"</span>,
        <span class="org-string">"~kk"</span>,
        <span class="org-string">"MELBY_PS1_LINE2"</span>,
        <span class="org-string">"declare -a MELBY_SHELL_MESSAGES"</span>
      ],
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">true</span>
    )
  <span class="org-keyword">end</span>

  <span class="org-elixir-attribute">@tag</span> <span class="org-elixir-atom">ttl:</span> <span class="org-elixir-atom">true</span>
  test <span class="org-string">"SRS ttl: exit when ttl reaches 0"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">path_local</span> = mk_tmp_dir(<span class="org-string">"repo_local"</span>)

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    git init</span>
<span class="org-string">    echo world &gt; hello</span>
<span class="org-string">    git add hello</span>
<span class="org-string">    git commit -m 'initial import'</span>
<span class="org-string">    """</span>)

    {<span class="org-elixir-atom">:ok</span>, mix_root} = <span class="org-type">File</span>.cwd()

    <span class="org-comment-delimiter"># </span><span class="org-comment">Because the production code always sets the notify_on_exit_pid to nil (in</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">the normal codepath for users), we have to use a different code path. This</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">is essentially the body of the read_standard_resource Melbyd SDK function</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">we provide, but customized to not run Melbyd.StandardResource.read/2, but</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">to use our own logic to directly start the Melbyd.StandardResource</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">GenServer.</span>
    {<span class="org-elixir-atom">:ok</span>, [resource_ref], st0} = <span class="org-type">Melbyd.LuaInterop</span>.run_file(mix_root &lt;&gt; <span class="org-string">"/test/sample/Git.lua"</span>)

    <span class="org-variable-name">resource</span> = <span class="org-type">Melbyd.LuaSdk</span>.resource_ref_to_native_map(resource_ref, st0)

    {<span class="org-elixir-atom">:ok</span>, <span class="org-constant">_</span>} =
      <span class="org-type">GenServer</span>.start_link(<span class="org-type">Melbyd.StandardResource</span>, %{
        <span class="org-elixir-atom">id:</span> {<span class="org-string">"Git"</span>, path_local},
        <span class="org-elixir-atom">resource:</span> resource,
        <span class="org-elixir-atom">resource_opts:</span> %{<span class="org-string">"PWD"</span> <span class="org-keyword">=&gt;</span> path_local, <span class="org-string">"fake"</span> <span class="org-keyword">=&gt;</span> <span class="org-elixir-atom">false</span>},
        <span class="org-elixir-atom">ttl:</span> <span class="org-elixir-number">1</span>,
        <span class="org-elixir-atom">notify_on_exit_pid:</span> self()
      })

    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Move this 10_000 timeout to some global timeout (Application.get_env).</span>
    assert_receive <span class="org-elixir-atom">:shutting_down</span>, <span class="org-elixir-number">10_000</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">We can't use :tmp_dir because we need multiple temporary directories.</span>
  <span class="org-elixir-attribute">@tag</span> <span class="org-elixir-atom">git:</span> <span class="org-elixir-atom">true</span>
  test <span class="org-string">"basic smoke test (with git repo)"</span>, %{<span class="org-elixir-atom">test:</span> test_name} <span class="org-keyword">do</span>
    <span class="org-variable-name">shell_pid</span> = get_unique_shell_pid(<span class="org-constant">__MODULE__</span>, test_name)

    {<span class="org-elixir-atom">:ok</span>, mix_root} = <span class="org-type">File</span>.cwd()

    <span class="org-comment-delimiter"># </span><span class="org-comment">Create basic Git repo. We use a temporary folder for this.</span>
    <span class="org-variable-name">path_upstream</span> = mk_tmp_dir(<span class="org-string">"repo_upstream"</span>)

    run_git_script(path_upstream, <span class="org-string">"""</span>
<span class="org-string">    git init</span>
<span class="org-string">    echo world &gt; hello</span>
<span class="org-string">    git add hello</span>
<span class="org-string">    git commit -m 'initial import'</span>
<span class="org-string">    """</span>)

    <span class="org-variable-name">path_local</span> = mk_tmp_dir(<span class="org-string">"repo_local"</span>)

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    cd /</span>
<span class="org-string">    git clone --no-hardlinks </span><span class="org-variable-name">#{path_upstream}</span><span class="org-string"> </span><span class="org-variable-name">#{path_local}</span>
<span class="org-string">    """</span>)

    <span class="org-variable-name">env_vars</span> = %{
      <span class="org-elixir-atom">KUBECONFIG:</span> mix_root &lt;&gt; <span class="org-string">"/test/fake_kube_config"</span>,
      <span class="org-elixir-atom">HOME:</span> <span class="org-string">"/home/foo"</span>,
      <span class="org-elixir-atom">PWD:</span> path_local,
      <span class="org-elixir-atom">USER:</span> <span class="org-string">"foo"</span>,
      <span class="org-elixir-atom">HOST:</span> <span class="org-string">"laptop"</span>,
      <span class="org-elixir-atom">MELBY_UNIX_SECONDS:</span> <span class="org-string">"1234567890"</span>,
      <span class="org-elixir-atom">MELBY_TIME_ZONE:</span> <span class="org-string">"America/Los_Angeles"</span>,
      <span class="org-elixir-atom">MELBY_ZSH_KEYMAP_INDICATOR:</span> <span class="org-string">"N"</span>,
      <span class="org-elixir-atom">MELBY_PATH_ALIASES_FILE:</span> mix_root &lt;&gt; <span class="org-string">"/test/sample/path-aliases"</span>,
      <span class="org-elixir-atom">MELBY_DIR:</span> mix_root &lt;&gt; <span class="org-string">"/test/sample"</span>
    }

    <span class="org-variable-name">path_local_short</span> =
      <span class="org-type">Melbyd.Nifs</span>.path_shorten(
        path_local,
        %{},
        %{<span class="org-string">"HOME"</span> <span class="org-keyword">=&gt;</span> <span class="org-string">"/home/foo"</span>},
        <span class="org-elixir-number">30</span>
      )

    <span class="org-variable-name">lua_script</span> = mix_root &lt;&gt; <span class="org-string">"/test/sample/melby.lua"</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">This initial response should not have Git information because it's too</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">quick (the Git watcher would have returned an initial empty loading</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">state). So check for the "[ Git... ]" string.</span>
    assert_output_string(<span class="org-string">"[ Git... ]"</span>, shell_pid, lua_script, env_vars, <span class="org-elixir-atom">false</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">After some time, the original "[ Git... ]" string should have disappeared</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">from the output by now, and we should have a final view like below.</span>
    assert_output_substrings(
      [
        <span class="org-string">"MELBY_PS1_LINE1"</span>,
        <span class="org-string">"$(cat &lt;&lt; 'END_HEREDOC'\n 02-13 &#37329; 15:31:30 PST   02-13 &#37329; 23:31:30 UTC   "</span>,
        <span class="org-string">"&lt;N&gt;  foo@laptop </span><span class="org-variable-name">#{path_local_short}</span><span class="org-string">\nEND_HEREDOC"</span>,
        <span class="org-string">"\n)\nMELBY_PS1_LINE2=$(cat &lt;&lt; 'END_HEREDOC'\n["</span>,
        <span class="org-string">"&#9096; one:default 8T 5p 2r 0s 0f 1u]"</span>,
        <span class="org-string">" [ 3b83e1cd  master 19Y a]\nEND_HEREDOC\n)\ndeclare -a MELBY_SHELL_MESSAGES"</span>,
        <span class="org-string">"\nMELBY_SHELL_MESSAGES=(\n\n)\n"</span>,
      ],
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    <span class="org-comment-delimiter"># </span><span class="org-comment">If we make some changes to it, we should see it reflected. We also only</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">test for changes to the prompt that we expect to see --- namely the Git</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">parts.</span>
    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    echo bye &gt;&gt; hello</span>
<span class="org-string">    """</span>)

    assert_output_substrings(
      [<span class="org-string">"[ 3b83e1cd  master 19Y a U1+1]"</span>],
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    git add hello</span>
<span class="org-string">    """</span>)

    assert_output_substrings(
      [<span class="org-string">"[ 3b83e1cd  master 19Y a S1+1]"</span>, <span class="org-string">"Staged size is now XS (4 bytes)."</span>],
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    git commit -m 'append bye'</span>
<span class="org-string">    """</span>)

    assert_output_string(
      <span class="org-string">"[ f679b84c  master 19Y a &#9650;1]"</span>,
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    run_git_script(path_upstream, <span class="org-string">"""</span>
<span class="org-string">    echo x &gt;&gt; x</span>
<span class="org-string">    git add x</span>
<span class="org-string">    git commit -m 'upstream change 1'</span>
<span class="org-string">    """</span>)

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    git fetch</span>
<span class="org-string">    """</span>)

    assert_output_string(
      <span class="org-string">"[ f679b84c  master 19Y a &#9650;1 &#9660;1]"</span>,
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    echo untracked &gt; untracked</span>
<span class="org-string">    """</span>)

    assert_output_string(
      <span class="org-string">"[ f679b84c  master 19Y a &#9650;1 &#9660;1 N1]"</span>,
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    echo 0 &gt;&gt; hello</span>
<span class="org-string">    git stash</span>
<span class="org-string">    """</span>)

    assert_output_string(
      <span class="org-string">"[ f679b84c  master 19Y a &#9650;1 &#9660;1 N1 T1]"</span>,
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    echo 2 &gt; 2</span>
<span class="org-string">    git add 2</span>
<span class="org-string">    git commit -m 'local commit 2'</span>
<span class="org-string">    echo x &gt;&gt; 2</span>
<span class="org-string">    git update-index --assume-unchanged 2</span>
<span class="org-string">    """</span>)

    assert_output_string(
      <span class="org-string">"[ 2e4f8685  master 19Y a &#9650;2 &#9660;1 N1 T1 A1]"</span>,
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    <span class="org-variable-name">path_sm1</span> = mk_tmp_dir(<span class="org-string">"sm1"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Add submodule, but don't initialize it.</span>
    run_git_script(path_sm1, <span class="org-string">"""</span>
<span class="org-string">    git init</span>
<span class="org-string">    echo sm1 &gt; sm1</span>
<span class="org-string">    git add sm1</span>
<span class="org-string">    git commit -m 'initial import'</span>
<span class="org-string">    """</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Due to Git CVE-2022-39253, we hae to pass in "-c</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">protocol.file.allow=always" in order to allow adding a submodule from</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">disk. See https://bugs.launchpad.net/ubuntu/+source/git/+bug/1993586.</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Also, because the absolute path on disk is unique in each run, it appears</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">that the resulting commit SHA will also be different on each run of this</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">test. To get around this, we don't check for the SHA any more.</span>
    run_git_script(path_upstream, <span class="org-string">"""</span>
<span class="org-string">    git -c protocol.file.allow=always submodule add </span><span class="org-variable-name">#{path_sm1}</span><span class="org-string"> sm1</span>
<span class="org-string">    git commit -m 'add submodule'</span>
<span class="org-string">    """</span>)

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    git update-index --no-assume-unchanged 2</span>
<span class="org-string">    git checkout 2</span>
<span class="org-string">    git pull --rebase</span>
<span class="org-string">    """</span>)

    assert_output_string(
      <span class="org-string">"master 19Y a &#9650;2 N1 T1 M{not_init=1}]"</span>,
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    <span class="org-variable-name">path_sm2</span> = mk_tmp_dir(<span class="org-string">"sm2"</span>)

    run_git_script(path_sm2, <span class="org-string">"""</span>
<span class="org-string">    git init</span>
<span class="org-string">    echo sm2 &gt; sm2</span>
<span class="org-string">    git add sm2</span>
<span class="org-string">    git commit -m 'initial import'</span>
<span class="org-string">    """</span>)

    run_git_script(path_upstream, <span class="org-string">"""</span>
<span class="org-string">    git -c protocol.file.allow=always submodule add </span><span class="org-variable-name">#{path_sm2}</span><span class="org-string"> sm2</span>
<span class="org-string">    git commit -m 'add submodule sm2'</span>
<span class="org-string">    """</span>)

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    git pull --rebase</span>
<span class="org-string">    git -c protocol.file.allow=always submodule update --init sm2</span>
<span class="org-string">    """</span>)

    run_git_script(path_sm2, <span class="org-string">"""</span>
<span class="org-string">    echo foo &gt; foo</span>
<span class="org-string">    git add foo</span>
<span class="org-string">    git commit -m 'add foo'</span>
<span class="org-string">    """</span>)

    run_git_script(path_upstream, <span class="org-string">"""</span>
<span class="org-string">    cd sm2</span>
<span class="org-string">    git pull</span>
<span class="org-string">    cd ..</span>
<span class="org-string">    git add --update</span>
<span class="org-string">    git commit -m 'update submodule sm2'</span>
<span class="org-string">    """</span>)

    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    git pull --rebase</span>
<span class="org-string">    """</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">The "C&#8226;1+1-1" is because the local repo's sm2 is still checked out at an</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">older version, whereas upstream has moved on to a newer commit.</span>
    assert_output_string(
      <span class="org-string">"master 19Y a &#9650;2 U1+1-1 N1 T1 M{not_init=1 need_sync=1}]"</span>,
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    run_git_script(path_sm2, <span class="org-string">"""</span>
<span class="org-string">    echo there &gt; there</span>
<span class="org-string">    git add there</span>
<span class="org-string">    git commit -m 'add there'</span>
<span class="org-string">    """</span>)

    run_git_script(path_upstream, <span class="org-string">"""</span>
<span class="org-string">    cd sm2</span>
<span class="org-string">    git pull</span>
<span class="org-string">    cd ..</span>
<span class="org-string">    git add sm2</span>
<span class="org-string">    git commit -m 'use sm2 master'</span>
<span class="org-string">    """</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">If we try to merge two branches of the superproject together but they</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">reference different versions of a submodule, this should result in a</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">submodule merge conflict.</span>
    run_git_script(path_local, <span class="org-string">"""</span>
<span class="org-string">    cd sm2</span>
<span class="org-string">    git rm -f sm2</span>
<span class="org-string">    echo hello &gt; sm2</span>
<span class="org-string">    git add sm2</span>
<span class="org-string">    git commit -m 'changing sm2 locally'</span>

<span class="org-string">    cd ..</span>
<span class="org-string">    git add sm2</span>
<span class="org-string">    git commit -m 'using local sm2 update'</span>
<span class="org-string">    git fetch</span>
<span class="org-string">    git merge origin/master || true</span>
<span class="org-string">    """</span>)

    assert_output_string(
      <span class="org-string">"master 19Y a &#9650;3 &#9660;1 N1 T1 M{not_init=1 conflict=1}"</span>,
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )
  <span class="org-keyword">end</span>

  <span class="org-elixir-attribute">@tag</span> <span class="org-elixir-atom">k8s:</span> <span class="org-elixir-atom">true</span>
  test <span class="org-string">"basic smoke test (with kubectl)"</span>, %{<span class="org-elixir-atom">test:</span> test_name} <span class="org-keyword">do</span>
    <span class="org-variable-name">shell_pid</span> = get_unique_shell_pid(<span class="org-constant">__MODULE__</span>, test_name)

    {<span class="org-elixir-atom">:ok</span>, mix_root} = <span class="org-type">File</span>.cwd()
    <span class="org-variable-name">lua_script</span> = mix_root &lt;&gt; <span class="org-string">"/test/sample/melby.lua"</span>

    <span class="org-variable-name">non_git_repo</span> = mk_tmp_dir(<span class="org-string">"non_git_repo"</span>)

    <span class="org-variable-name">content</span> = <span class="org-string">"current-context=one\ncurrent-namespace=default\n"</span>
    <span class="org-variable-name">kubeconfig</span> = non_git_repo &lt;&gt; <span class="org-string">"/fake_kube_config"</span>
    <span class="org-type">File</span>.write(kubeconfig, content)

    <span class="org-variable-name">env_vars</span> = %{
      <span class="org-elixir-atom">KUBECONFIG:</span> kubeconfig,
      <span class="org-elixir-atom">HOME:</span> mix_root &lt;&gt; <span class="org-string">"/test/sample"</span>,
      <span class="org-elixir-atom">PWD:</span> non_git_repo,
      <span class="org-elixir-atom">USER:</span> <span class="org-string">"foo"</span>,
      <span class="org-elixir-atom">HOST:</span> <span class="org-string">"laptop"</span>,
      <span class="org-elixir-atom">MELBY_UNIX_SECONDS:</span> <span class="org-string">"1234567890"</span>,
      <span class="org-elixir-atom">MELBY_TIME_ZONE:</span> <span class="org-string">"America/Los_Angeles"</span>,
      <span class="org-elixir-atom">MELBY_ZSH_KEYMAP_INDICATOR:</span> <span class="org-string">"N"</span>,
      <span class="org-elixir-atom">MELBY_PATH_ALIASES_FILE:</span> mix_root &lt;&gt; <span class="org-string">"/test/sample/path-aliases"</span>,
      <span class="org-elixir-atom">MELBY_DIR:</span> mix_root &lt;&gt; <span class="org-string">"/test/sample"</span>
    }

    assert_output_substrings(
      [
        <span class="org-string">"[ K8s... ]"</span>
      ],
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    assert_output_substrings(
      [
        <span class="org-string">"one:default"</span>
      ],
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    <span class="org-comment-delimiter"># </span><span class="org-comment">Change config to point to "two:bar".</span>
    <span class="org-variable-name">content</span> = <span class="org-string">"current-context=two\ncurrent-namespace=bar\n"</span>
    <span class="org-type">File</span>.write(kubeconfig, content)

    assert_output_substrings(
      [
        <span class="org-string">"Context changed from 'one' to 'two'."</span>,
        <span class="org-string">"Namespace changed from 'default' to 'bar'."</span>
      ],
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )

    assert_output_substrings(
      [
        <span class="org-string">"two:bar"</span>
      ],
      shell_pid,
      lua_script,
      env_vars,
      <span class="org-elixir-atom">false</span>
    )
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-h-Purpose-2" class="outline-4">
<h4 id="h-Purpose-2"><span class="section-number-4">6.5.8.</span> Purpose</h4>
<div class="outline-text-4" id="text-h-Purpose-2">
<p>
<code>melbyr</code> (the melby-renderer) converts raw data into strings that can be
interpreted and presented by some other program (e.g., Zsh prompt display).
</p>

<p>
There are basically 2 concrete things that <code>melbyr</code> can do:
</p>

<ol class="org-ol">
<li>Convert existing composite data types into a string token ("render" the
data into a string representation).</li>

<li>Convert a list of string tokens into a new string ("render" the tokens down
into a final string output).</li>
</ol>

<p>
The second step involves interpreting layout tokens such as <code>FILL</code> and <code>SPACE</code>.
</p>
</div>
</div>

<div id="outline-container-h-Design-by-contract-1" class="outline-4">
<h4 id="h-Design-by-contract-1"><span class="section-number-4">6.5.9.</span> Design by contract</h4>
<div class="outline-text-4" id="text-h-Design-by-contract-1">
<p>
We would like <code>melbyr</code> to observe the following behaviors.
</p>
</div>

<div id="outline-container-h-Communication-between-melbyd-and-melbyr" class="outline-5">
<h5 id="h-Communication-between-melbyd-and-melbyr"><span class="section-number-5">6.5.9.1.</span> Communication between melbyd and melbyr</h5>
<div class="outline-text-5" id="text-h-Communication-between-melbyd-and-melbyr">
</div>

<div id="outline-container-h-Proto-3" class="outline-6">
<h6 id="h-Proto-3"><span class="section-number-6">6.5.9.1.1.</span> Proto</h6>
<div class="outline-text-6" id="text-h-Proto-3">
<div class="org-src-container"><pre class="src src-protobuf" id="nil-30">syntax = <span class="org-string">"proto3"</span>;

<span class="org-keyword">package</span> <span class="org-type">melby_renderer</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">melby &lt;-&gt; melby-renderer communication</span>
<span class="org-keyword">service</span> <span class="org-type">Renderer</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">For other Git Repo stats, each of those stats can be inserted into the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">layout with Lua so that the user can configure the order/orientation of</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">each bit (they should also be able to decide how much of the 40-char sha</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">they want to expose --- so we need a way to colorize all 40 chars by using</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">all 160 bits of data).</span>
  <span class="org-keyword">rpc</span> <span class="org-function-name">GetColorizedGitSha</span> (ColorizedGitShaRequest) <span class="org-keyword">returns</span> (ColorizedGitShaResponse);
  <span class="org-keyword">rpc</span> <span class="org-function-name">RenderWidgets</span> (RenderWidgetsRequest) <span class="org-keyword">returns</span> (RenderWidgetsResponse);
  <span class="org-comment-delimiter">// </span><span class="org-comment">This is not a method for rendering, but because</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">https://github.com/higherkindness/mu-haskell/pull/309 isn't released yet,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">we cannot use a separate service for this, because doing so would require</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">us to use a second TCP port. Once mu-grpc-server gets a new release that</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">includes the above PR, we can use a separate service and multiplex it on</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the same port for better code organization.</span>
  <span class="org-keyword">rpc</span> <span class="org-function-name">ParsePathAliases</span> (ParsePathAliasesRequest) <span class="org-keyword">returns</span> (ParsePathAliasesResponse);
}

<span class="org-keyword">message</span> <span class="org-type">ColorizedGitShaRequest</span> {
  <span class="org-type">string</span> <span class="org-variable-name">sha</span> = 1;
  <span class="org-comment-delimiter">// </span><span class="org-comment">How many SHA hex chars to colorize (and output). Typically this will be</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">less than 40 because in practice people rarely want the full 40-char SHA in</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">their shell prompt.</span>
  <span class="org-type">uint32</span> <span class="org-variable-name">sha_length</span> = 2;
  <span class="org-comment-delimiter">// </span><span class="org-comment">How many space characters to add to the left/right of the final (colorized)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">output. These space characters will take on the background color of their</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">adjacent colorized hex chars in the SHA string. This is purely for</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">aesthetic reasons.</span>
  <span class="org-type">uint32</span> <span class="org-variable-name">pad_left</span> = 3;
  <span class="org-type">uint32</span> <span class="org-variable-name">pad_right</span> = 4;
  <span class="org-type">RenderOptions</span> <span class="org-variable-name">render_options</span> = 5;
}

<span class="org-keyword">message</span> <span class="org-type">ColorizedGitShaResponse</span> {
  <span class="org-type">string</span> <span class="org-variable-name">sha_colorized</span> = 1;
}

<span class="org-keyword">message</span> <span class="org-type">RenderOptions</span> {
  <span class="org-type">RenderFormat</span> <span class="org-variable-name">format</span> = 1;
  <span class="org-type">RenderColorDepth</span> <span class="org-variable-name">color_depth</span> = 2;
}

<span class="org-keyword">enum</span> <span class="org-type">RenderFormat</span> {
  RENDER_FORMAT_UNSPECIFIED = 0;
  RENDER_FORMAT_UNIX_TERMINAL = 1;
}

<span class="org-keyword">enum</span> <span class="org-type">RenderColorDepth</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">"Unspecified" just means to refrain from doing any special colorizations.</span>
  RENDER_COLOR_DEPTH_UNSPECIFIED = 0;
  RENDER_COLOR_DEPTH_256 = 1;
  RENDER_COLOR_DEPTH_24_BIT = 2;
}

<span class="org-keyword">message</span> <span class="org-type">RenderWidgetsRequest</span> {
  <span class="org-keyword">repeated</span> <span class="org-type">Widget</span> <span class="org-variable-name">widgets</span> = 1;
  <span class="org-comment-delimiter">// </span><span class="org-comment">By default, this is a single space character (without any colors) and acts</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">as a separater between all widgets.</span>
  <span class="org-type">Widget</span> <span class="org-variable-name">delimiter</span> = 2;
  <span class="org-type">RenderOptions</span> <span class="org-variable-name">render_options</span> = 3;
}

<span class="org-keyword">message</span> <span class="org-type">RenderWidgetsResponse</span> {
  <span class="org-type">string</span> <span class="org-variable-name">widgets_rendered</span> = 1;
}

<span class="org-keyword">message</span> <span class="org-type">Widget</span> {
  <span class="org-type">string</span> <span class="org-variable-name">str</span> = 1;
  <span class="org-type">TextProperty</span> <span class="org-variable-name">prop</span> = 2;
  <span class="org-type">bool</span> <span class="org-variable-name">drop_delim_left</span> = 3;
  <span class="org-type">bool</span> <span class="org-variable-name">drop_delim_right</span> = 4;
}

<span class="org-keyword">message</span> <span class="org-type">TextProperty</span> {
  <span class="org-type">Color</span> <span class="org-variable-name">fg</span> = 1;
  <span class="org-type">Color</span> <span class="org-variable-name">bg</span> = 2;
  <span class="org-keyword">repeated</span> <span class="org-type">TextStyle</span> <span class="org-variable-name">styles</span> = 3;
  <span class="org-comment-delimiter">// </span><span class="org-comment">FIXME: It is possible to have underlines in a different color than the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">current foreground color. This field captures that possibility. BUT the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">ansi-terminal library does not appear to support this. So don't bother.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Color line_color = 4;</span>
}

<span class="org-keyword">message</span> <span class="org-type">Color</span> {
  <span class="org-type">oneof</span> <span class="org-variable-name">color_oneof</span> {
    <span class="org-type">Color24Bit</span> <span class="org-variable-name">color_24_bit</span> = 1;
    <span class="org-comment-delimiter">// </span><span class="org-comment">The well-known "256" colors as used in ANSI escade codes. The first 16</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">colors (0 through 15) are the traditional 16 colors used before 256</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">colors became a thing. The colors 232-255 represent a grayscale gradient</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">(dark to light), and finally the middle 216 colors (16-231) represent</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">additional colors in 6 squares, each with 36 colors. See FIXME table</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">here: https://en.wikipedia.org/wiki/ANSI_escape_code</span>
    <span class="org-type">uint32</span> <span class="org-variable-name">color_256</span> = 2;
  }
}

<span class="org-keyword">message</span> <span class="org-type">Color24Bit</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ideally each of these should be a "uint8" but protobuf does not have this</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">scalar type. So target applications have to convert to a uint8 (mask the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">lower 8 bits) of each color channel.</span>
  <span class="org-type">uint32</span> <span class="org-variable-name">red</span> = 1;
  <span class="org-type">uint32</span> <span class="org-variable-name">green</span> = 2;
  <span class="org-type">uint32</span> <span class="org-variable-name">blue</span> = 3;
}

<span class="org-keyword">enum</span> <span class="org-type">TextStyle</span> {
  TEXT_STYLE_UNSPECIFIED = 0;
  TEXT_STYLE_BOLD = 1;
  TEXT_STYLE_ITALIC = 2;
  TEXT_STYLE_UNDERLINE = 3;
  TEXT_STYLE_UNDERLINE_DOUBLE = 4;
  TEXT_STYLE_BLINK = 5;
  TEXT_STYLE_BLINK_RAPID = 6;
}

<span class="org-keyword">message</span> <span class="org-type">ParsePathAliasesRequest</span> {
  <span class="org-type">string</span> <span class="org-variable-name">path_aliases_raw</span> = 1;
}

<span class="org-keyword">message</span> <span class="org-type">ParsePathAliasesResponse</span> {
  <span class="org-type">ParseStatus</span> <span class="org-variable-name">status</span> = 1;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Happy path.</span>
  map&lt;<span class="org-type">string</span>, <span class="org-type">string</span>&gt; path_aliases = 2;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Error message from melbyr, if any.</span>
  <span class="org-type">string</span> <span class="org-variable-name">error</span> = 3;
}

<span class="org-keyword">enum</span> <span class="org-type">ParseStatus</span> {
  PARSE_STATUS_UNSPECIFIED = 0;
  PARSE_STATUS_ERROR = 1;
  PARSE_STATUS_OK = 2;
}
</pre></div>
</div>
</div>
</div>

<div id="outline-container-h-Running-very-quickly-1" class="outline-5">
<h5 id="h-Running-very-quickly-1"><span class="section-number-5">6.5.9.2.</span> Running very quickly</h5>
<div class="outline-text-5" id="text-h-Running-very-quickly-1">
<p>
We don't want the client to block too long, because it is expected to be called
as often as every second (or even more often if Zsh ever offers sub-1-second
delay with the <code>TMOUT</code> variable).
</p>

<p>
The basic way we ensure this is that we make melbyd return whatever it has
without waiting for any of its internal calculations to finish.
</p>

<p>
Because this is a daemon-side concern, there isn't much for us to do here.
</p>
</div>
</div>

<div id="outline-container-h-Command-line-argument-handling-1" class="outline-5">
<h5 id="h-Command-line-argument-handling-1"><span class="section-number-5">6.5.9.3.</span> Command line argument handling</h5>
<div class="outline-text-5" id="text-h-Command-line-argument-handling-1">
<p>
This is somewhat "boring" and we actually don't have much to design here. Much
of the choices here depend heavily on the command line argument parsing library
that we will be using.
</p>
</div>
</div>
</div>

<div id="outline-container-h-Code-overview-2" class="outline-4">
<h4 id="h-Code-overview-2"><span class="section-number-4">6.5.10.</span> Code overview</h4>
<div class="outline-text-4" id="text-h-Code-overview-2">
<p>
This walk-through is written for the future maintainers of this codebase.
</p>
</div>

<div id="outline-container-h-Overall-structure-1" class="outline-5">
<h5 id="h-Overall-structure-1"><span class="section-number-5">6.5.10.1.</span> Overall structure</h5>
<div class="outline-text-5" id="text-h-Overall-structure-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Layout of <code>melby-renderer.hs</code></label><span class="lilac-caption-link-symbol"><a href="#Layout-of--code-melby-renderer-hs--code">&#x1f517;</a></span></div><pre class="src src-haskell" id="Layout-of--code-melby-renderer-hs--code"><span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_pragmas">melbyr_pragmas</a></span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">Main</span> <span class="org-haskell-keyword">where</span>

<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_imports">melbyr_imports</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_option_handling">melbyr_option_handling</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_main">melbyr_main</a></span>
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Business-logic-1" class="outline-4">
<h4 id="h-Business-logic-1"><span class="section-number-4">6.5.11.</span> Business logic</h4>
<div class="outline-text-4" id="text-h-Business-logic-1">
</div>

<div id="outline-container-h-Widget-Rendering-System" class="outline-5">
<h5 id="h-Widget-Rendering-System"><span class="section-number-5">6.5.11.1.</span> Widget Rendering System</h5>
<div class="outline-text-5" id="text-h-Widget-Rendering-System">
<p>
A "widget" object encodes a string of text that must be rendered on the
terminal. Widgets are encoded in Lua directly in the user configuration. Here is
an example:
</p>

<div class="org-src-container"><pre class="src src-lua" id="nil-31">foo = {str=<span class="org-string">" foo "</span>, fg=<span class="org-string">"white"</span>, bg=<span class="org-string">"blue"</span>, styles={<span class="org-string">"bold"</span>}}
</pre></div><p>
This encodes the <code>" foo "</code> string with a blue background with white, bold
text. The user can then just send over a list of these widgets to be rendered on
a single line (assuming they do not encode any newlines in the <code>str</code> field).
</p>

<p>
Between each widget, 1 space character is inserted by default. This can be
adjusted with the <code>delimiter</code> option in the call to <code>render()</code>, like this:
</p>

<div class="org-src-container"><pre class="src src-lua" id="nil-32">rendered = melbyd.render(widgets,
                         delimiter={str=<span class="org-string">"**"</span>},
                         render_options={format=<span class="org-string">"RENDER_FORMAT_UNIX_TERMINAL"</span>,
                                         color_depth=<span class="org-string">"RENDER_COLOR_DEPTH_24_BIT"</span>})
</pre></div><p>
This uses 2 asterisks as a delimiter.
</p>
</div>

<div id="outline-container-h-Widget-field-reference" class="outline-6">
<h6 id="h-Widget-field-reference"><span class="section-number-6">6.5.11.1.1.</span> Widget field reference</h6>
<div class="outline-text-6" id="text-h-Widget-field-reference">
<p>
Widgets can have the following fields:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Field</td>
<td class="org-left">Description</td>
<td class="org-left">Examples</td>
</tr>

<tr>
<td class="org-left">str</td>
<td class="org-left">The literal string character(s) to display.</td>
<td class="org-left"><code>" foo "</code></td>
</tr>

<tr>
<td class="org-left">fg</td>
<td class="org-left">Forground stying. Colors and/or text formatting accepted.</td>
<td class="org-left"><code>"black"</code></td>
</tr>

<tr>
<td class="org-left">bg</td>
<td class="org-left">Background colors.</td>
<td class="org-left"><code>"white"</code></td>
</tr>

<tr>
<td class="org-left">styles</td>
<td class="org-left">List of styles to apply.</td>
<td class="org-left"><code>"bold", "italic"</code></td>
</tr>
</tbody>
</table>

<p>
For a complete list of color names, see
<a href="https://www.w3.org/TR/css-color-4/#named-colors">https://www.w3.org/TR/css-color-4/#named-colors</a>. For other accepted color
formats, refer to the <a href="https://github.com/mazznoer/csscolorparser-rs">csscolorparser Rust library</a> which we use. Note that any
color that we cannot parse is just given a generic, grey color. This is because
we don't yet have configuration validation.
</p>
</div>
</div>

<div id="outline-container-h-Optional-widget-delimiters" class="outline-6">
<h6 id="h-Optional-widget-delimiters"><span class="section-number-6">6.5.11.1.2.</span> Optional widget delimiters</h6>
<div class="outline-text-6" id="text-h-Optional-widget-delimiters">
<p>
List all widgets. If 0 or 1 in length, do nothing.
</p>

<p>
If the length is \(> 1\), then create a second copy. Shift by 1 (drop 1), and zip
together, so that if we have e.g. <code>[1, 2, 3]</code> we get <code>[(1, 2), (2, 3)]</code>. Thus we
are able to get a "pairwise" view of all widgets.
</p>

<p>
Then just loop through this list of pairs, and build up the final widgets list
(with or without delimiters) depending on the <code>drop_delim_left</code> and
<code>drop_delim_right</code> fields in each pair. The final list is built up by adding in
up to 2 widgets at a time, the left pair item and an optional delimiter widget.
Finally, append the last widget unconditionally.
</p>

<p>
Actually we can do the above with just recursion. See <code>injectDelimiters</code>.
</p>
</div>
</div>

<div id="outline-container-h-Implementation-1" class="outline-6">
<h6 id="h-Implementation-1"><span class="section-number-6">6.5.11.1.3.</span> Implementation</h6>
<div class="outline-text-6" id="text-h-Implementation-1">
<div class="org-src-container"><pre class="src src-haskell" id="nil-33"><span class="org-haskell-pragma">{-# LANGUAGE DataKinds #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeApplications #-}</span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">MelbyRenderer.Widgets</span>
  ( renderWidgets
  ) <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Monad.Logger</span> <span class="org-haskell-keyword">hiding</span> (logDebug)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Colour.SRGB</span> (sRGB24)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Maybe</span> (catMaybes, listToMaybe)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Text</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">T</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">GHC.Records</span> (getField)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.Server</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Console.ANSI</span>
       ( setSGRCode
       , <span class="org-haskell-constructor">BlinkSpeed</span> (<span class="org-haskell-operator">..</span>)
       , <span class="org-haskell-constructor">ConsoleIntensity</span> (<span class="org-haskell-operator">..</span>)
       , <span class="org-haskell-constructor">ConsoleLayer</span> (<span class="org-haskell-operator">..</span>)
       , <span class="org-haskell-constructor">SGR</span> (<span class="org-haskell-operator">..</span>)
       , <span class="org-haskell-constructor">Underlining</span> (<span class="org-haskell-operator">..</span>))

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.Log</span> (logDebug)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.Schema</span>

<span class="org-haskell-definition">renderWidgets</span>
  <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">MonadServer</span> m, <span class="org-haskell-type">MonadLogger</span> m)
  <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MRenderWidgetsRequest</span>
  <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-type">MRenderWidgetsResponse</span>
<span class="org-haskell-definition">renderWidgets</span> req <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  logDebug <span class="org-haskell-operator">$</span> <span class="org-string">"request was: "</span> <span class="org-haskell-operator">&lt;&gt;</span> (T.pack <span class="org-haskell-operator">$</span> show req)
  pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MRenderWidgetsResponse</span>
    { widgets_rendered <span class="org-haskell-operator">=</span> rendered
    }
  <span class="org-haskell-keyword">where</span>
  rendered <span class="org-haskell-operator">=</span> T.concat <span class="org-haskell-operator">$</span> map (renderWidget renderOpts) widgetsWithDelimiters
  widgetsWithDelimiters <span class="org-haskell-operator">=</span> injectDelimiters delimiterFinal <span class="org-haskell-operator">$</span> widgets req
  delimiterFinal <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> delimiter req <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Just</span> d <span class="org-haskell-operator">-&gt;</span> d
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">MWidget</span>
      { str <span class="org-haskell-operator">=</span> <span class="org-string">" "</span>
      , prop <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span>
      , drop_delim_left <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
      , drop_delim_right <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
      }
  renderOpts <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> GHC.Records.getField <span class="org-haskell-operator">@</span><span class="org-string">"render_options"</span> req <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Just</span> ro <span class="org-haskell-operator">-&gt;</span> ro
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">MRenderOptions</span>
      { format <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RENDER_FORMAT_UNIX_TERMINAL</span>
      , color_depth <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RENDER_COLOR_DEPTH_24_BIT</span>
      }

<span class="org-haskell-definition">injectDelimiters</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MWidget</span> <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-type">MWidget</span>] <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-type">MWidget</span>]
<span class="org-haskell-definition">injectDelimiters</span> delim ws <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> ws <span class="org-haskell-keyword">of</span>
  <span class="org-haskell-constructor">[]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">[]</span>
  [w] <span class="org-haskell-operator">-&gt;</span> [w]
  (w1<span class="org-haskell-constructor">:</span>w2<span class="org-haskell-constructor">:</span>rest) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">let</span> recurse <span class="org-haskell-operator">=</span> injectDelimiters delim (w2<span class="org-haskell-constructor">:</span>rest)
    <span class="org-haskell-keyword">in</span> <span class="org-haskell-keyword">if</span> drop_delim_right w1 <span class="org-haskell-operator">||</span> drop_delim_left w2
      <span class="org-haskell-keyword">then</span> w1<span class="org-haskell-constructor">:</span>recurse
      <span class="org-haskell-keyword">else</span> w1<span class="org-haskell-constructor">:</span>delim<span class="org-haskell-constructor">:</span>recurse

<span class="org-haskell-definition">renderWidget</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MRenderOptions</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">MWidget</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">T.Text</span>
<span class="org-haskell-definition">renderWidget</span> renderOptions widget <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> format renderOptions <span class="org-haskell-keyword">of</span>
  <span class="org-haskell-constructor">RENDER_FORMAT_UNSPECIFIED</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-string">"RENDER_FORMAT_UNSPECIFIED is unimplemented"</span>
  <span class="org-haskell-constructor">RENDER_FORMAT_UNIX_TERMINAL</span> <span class="org-haskell-operator">-&gt;</span> T.concat
    [ propCodes
    , MelbyRenderer.Schema.str widget
    , T.pack <span class="org-haskell-operator">$</span> setSGRCode [<span class="org-haskell-constructor">Reset</span>]
    ]
  <span class="org-haskell-keyword">where</span>
  propCodes <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> prop widget <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Just</span> p <span class="org-haskell-operator">-&gt;</span> textPropToAnsiCode p
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-string">""</span>

<span class="org-haskell-definition">textPropToAnsiCode</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MTextProperty</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">T.Text</span>
<span class="org-haskell-definition">textPropToAnsiCode</span> tp
  <span class="org-haskell-operator">=</span> T.pack <span class="org-haskell-operator">.</span> setSGRCode <span class="org-haskell-operator">$</span> catMaybes
    ([ propFg
     , propBg
     ] <span class="org-haskell-operator">&lt;&gt;</span> map (listToMaybe <span class="org-haskell-operator">.</span> styleToSGRCode) (styles tp))
  <span class="org-haskell-keyword">where</span>
  propFg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> fg tp <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
    <span class="org-haskell-constructor">Just</span> mcolor <span class="org-haskell-operator">-&gt;</span> colorToSGRCode mcolor <span class="org-haskell-constructor">Foreground</span>
  propBg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> bg tp <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
    <span class="org-haskell-constructor">Just</span> mcolor <span class="org-haskell-operator">-&gt;</span> colorToSGRCode mcolor <span class="org-haskell-constructor">Background</span>
  colorToSGRCode mcolor fgOrBg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> color_oneof mcolor <span class="org-haskell-keyword">of</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">FIXME: Get the default terminal background color and use it to blend the</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">foreground color here against it to get a Colour (instead of</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">AlphaColour).</span>

    <span class="org-comment-delimiter">-- </span><span class="org-comment">(MColorOneOf24Bit mcolor24bit) -&gt; Just</span>
    <span class="org-comment-delimiter">--                                </span><span class="org-comment">. SetRGBColor Foreground</span>
    <span class="org-comment-delimiter">--                                </span><span class="org-comment">. withOpacity (fromIntegral $ alpha mcolor24bit)</span>
    (<span class="org-haskell-constructor">MColorOneOf24Bit</span> mcolor24bit) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">.</span> <span class="org-haskell-constructor">SetRGBColor</span> fgOrBg
      <span class="org-haskell-operator">$</span> sRGB24 (fromIntegral <span class="org-haskell-operator">$</span> red mcolor24bit)
               (fromIntegral <span class="org-haskell-operator">$</span> green mcolor24bit)
               (fromIntegral <span class="org-haskell-operator">$</span> blue mcolor24bit)
    (<span class="org-haskell-constructor">MColorOneOf256</span> mcolor256) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">SetPaletteColor</span> fgOrBg (fromIntegral mcolor256)
  styleToSGRCode <span class="org-haskell-operator">=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
    <span class="org-haskell-constructor">TEXT_STYLE_UNSPECIFIED</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">[]</span>
    <span class="org-haskell-constructor">TEXT_STYLE_BOLD</span> <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-constructor">SetConsoleIntensity</span> <span class="org-haskell-constructor">BoldIntensity</span>]
    <span class="org-haskell-constructor">TEXT_STYLE_ITALIC</span> <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-constructor">SetItalicized</span> <span class="org-haskell-constructor">True</span>]
    <span class="org-haskell-constructor">TEXT_STYLE_UNDERLINE</span> <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-constructor">SetUnderlining</span> <span class="org-haskell-constructor">SingleUnderline</span>]
    <span class="org-haskell-constructor">TEXT_STYLE_UNDERLINE_DOUBLE</span> <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-constructor">SetUnderlining</span> <span class="org-haskell-constructor">DoubleUnderline</span>]
    <span class="org-haskell-constructor">TEXT_STYLE_BLINK</span> <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-constructor">SetBlinkSpeed</span> <span class="org-haskell-constructor">SlowBlink</span>]
    <span class="org-haskell-constructor">TEXT_STYLE_BLINK_RAPID</span> <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-constructor">SetBlinkSpeed</span> <span class="org-haskell-constructor">RapidBlink</span>]
</pre></div>
</div>
</div>
</div>

<div id="outline-container-h-Colorized-Git-SHA-1" class="outline-5">
<h5 id="h-Colorized-Git-SHA-1"><span class="section-number-5">6.5.11.2.</span> Colorized Git SHA</h5>
<div class="outline-text-5" id="text-h-Colorized-Git-SHA-1">
<p>
We want to colorized a Git SHA to make it easier to tell apart from another Git
SHA without having to read each individual hex digit. The basic idea is to use
the hex digits (which have a lot of entropy due to the cryptographic nature of
the underlying SHA-1 hash algorithm) to generate the colors, so that one commit
SHA will look very different (color-wise) from another, even if they share the
same leading hex digits.
</p>

<p>
There are two effective color modes (<code>OutputColorDepth</code>): 256 colors (available
to all standard terminals) and 24-bit color (available to most modern
terminals). The colorization algorithms for these modes differ significantly,
but they both have the following properties:
</p>

<ol class="org-ol">
<li>colorize all 40 hex characters,</li>

<li>feed the underlying bits of the hex characters themselves into the
colorization algorithm (to make it deterministic), and</li>

<li>make it so that even if 2 different commit SHAs have the same leading N hex
characters, that these two are colorized very differently.</li>
</ol>

<p>
The last property is important because most users will want to only display the
leading 7 to 10 characters of the hex string because this is typically enough in
practice, and we don't want 2 different commits that share the leading 7 to 10
characters to appear the same (for these leading characters). There are many
ways to achieve this, such as using the tail end of the hex string to colorize
the front.
</p>

<p>
Our algorithms below do their best to make use of all 160 bits of entropy in
every commit SHA. Generally they do this with 2 methods &#x2014; choosing the colors
and distributing these colors onto the 40 hex characters.
</p>
</div>

<div id="outline-container-h-Overview" class="outline-6">
<h6 id="h-Overview"><span class="section-number-6">6.5.11.2.1.</span> Overview</h6>
<div class="outline-text-6" id="text-h-Overview">
<div class="org-src-container"><pre class="src src-haskell" id="nil-34"><span class="org-haskell-pragma">{-# LANGUAGE DataKinds #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeApplications #-}</span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">MelbyRenderer.Colorizer</span>
  ( getColorizedGitSha
  ) <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Monad.Logger</span> <span class="org-haskell-keyword">hiding</span> (logDebug)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Bits</span> (xor)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.ByteString</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">B</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.ByteString.Base16</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">B16</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Colour.CIE.Illuminant</span> (d65)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Colour.CIE</span> (lightness)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Colour.SRGB</span> (sRGB24, toSRGB24)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Colour.RGBSpace</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Either</span> (fromRight)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Text.Encoding</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">T</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Text</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">T</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Word</span> (<span class="org-haskell-constructor">Word32</span>)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.Server</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Console.ANSI</span> (setSGRCode, <span class="org-haskell-constructor">ConsoleIntensity</span> (<span class="org-haskell-operator">..</span>), <span class="org-haskell-constructor">ConsoleLayer</span> (<span class="org-haskell-operator">..</span>), <span class="org-haskell-constructor">SGR</span> (<span class="org-haskell-operator">..</span>))

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.Log</span> (logDebug)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.Schema</span>

<span class="org-haskell-definition">getColorizedGitSha</span>
  <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">MonadServer</span> m, <span class="org-haskell-type">MonadLogger</span> m)
  <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MColorizedGitShaRequest</span>
  <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-type">MColorizedGitShaResponse</span>
<span class="org-haskell-definition">getColorizedGitSha</span> req <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  logDebug <span class="org-haskell-operator">$</span> <span class="org-string">"request was: "</span> <span class="org-haskell-operator">&lt;&gt;</span> (T.pack <span class="org-haskell-operator">$</span> show req)
  pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MColorizedGitShaResponse</span>{ sha_colorized <span class="org-haskell-operator">=</span> colorize
                                                   (sha req)
                                                   (sha_length req)
                                                   (pad_left req)
                                                   (pad_right req)}
  <span class="org-haskell-keyword">where</span>
  colorize bytes len padl padr
    <span class="org-haskell-operator">=</span> renderColorized
    <span class="org-haskell-operator">.</span> (<span class="org-haskell-operator">&lt;&gt;</span> [(<span class="org-haskell-constructor">Reset</span>, <span class="org-string">""</span>)])
    <span class="org-haskell-operator">.</span> ((<span class="org-haskell-constructor">SetConsoleIntensity</span> <span class="org-haskell-constructor">BoldIntensity</span>, <span class="org-string">""</span>) <span class="org-haskell-constructor">:</span>)
    <span class="org-haskell-operator">.</span> addPadding padl padr
    <span class="org-haskell-operator">$</span> colorizeGitSha24bit bytes len

<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_colorize_git_sha_24_bit">melbyr_colorize_git_sha_24_bit</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_add_padding">melbyr_add_padding</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_render_misc">melbyr_render_misc</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_perceived_lightness">melbyr_perceived_lightness</a></span>
</pre></div>
</div>
</div>

<div id="outline-container-h-24-bit-colors" class="outline-6">
<h6 id="h-24-bit-colors"><span class="section-number-6">6.5.11.2.2.</span> 24-bit colors</h6>
<div class="outline-text-6" id="text-h-24-bit-colors">
<p>
The Git SHA uses SHA-1 and has 160 random bits. We want 80 extra random bits so
that we have 240 total bits. We generate the 80 extra bits by XOR-ing the first
half and second half of the original together.
</p>

<p>
Now we have 240 bits to work with, and this is a "nice" number because we can
now choose 10 24-bit colors. We then split up the 40 hex chars into 10 groups of
4 characters, and colorize each of these groups using the 10 chosen colors.
</p>
</div>

<ol class="org-ol">
<li><a id="h-Cosmetics"></a>Cosmetics<br>
<div class="outline-text-7" id="text-h-Cosmetics">
<p>
We do 2 additional things for colorization:
</p>

<ol class="org-ol">
<li>optionally pad the left and right by an extra space character, so that the
hex characters (with the colored background) are easier to read on the eyes,
and</li>
<li>choose to display the hex char text in either black or white depending on the
perceived brightness of the background color.</li>
</ol>
</div>

<ol class="org-ol">
<li><a id="h-Choose-black-or-white-foreground-text-based-on-perceived-lightness"></a>Choose black or white foreground text based on perceived lightness<br>
<div class="outline-text-8" id="text-h-Choose-black-or-white-foreground-text-based-on-perceived-lightness">
<p>
The <a href="https://en.wikipedia.org/wiki/RGB_color_model">RGB color model</a>, which is used extensively in computer graphics, noticeably
lacks a "luminance" value. The <a href="https://en.wikipedia.org/wiki/CIELAB_color_space">CIELAB color space</a> includes a luminance value to
measure perceptual lightness. The simplest thing we can do to find the perceived
lightness from a given RGB value is to convert it to the CIELAB color space and
extract the lightness value from it.
</p>

<p>
Note that a color model is just how a color is described, whereas a color space
is responsible for generating actual (physically real) colors from the color
model's discrete (limited) values. See <a href="https://photo.stackexchange.com/a/48985">this post</a> for more information about
color models vs color spaces.
</p>

<p>
Anyway, see <a href="https://stackoverflow.com/a/56678483/437583">https://stackoverflow.com/a/56678483/437583</a> for an explanation of
how to find perceived lightness from an RGB (color model) value. However, we
don't follow that guide because the work has already been done for us in the
<a href="https://hackage.haskell.org/package/colour-2.3.6">colour</a> library for Haskell, which includes conversion into the CIELAB color
space.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-34">melbyr_perceived_lightness</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_perceived_lightness">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_perceived_lightness"><span class="org-haskell-definition">getPerceivedLightness</span> <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">Floating</span> b, <span class="org-haskell-type">RealFrac</span> b) <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Colour</span> b <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span>
<span class="org-haskell-definition">getPerceivedLightness</span> c <span class="org-haskell-operator">=</span> lightness d65 <span class="org-haskell-operator">$</span> sRGB24 r g b
  <span class="org-haskell-keyword">where</span>
  m <span class="org-haskell-operator">=</span> toSRGB24 c
  r <span class="org-haskell-operator">=</span> channelRed m
  g <span class="org-haskell-operator">=</span> channelGreen m
  b <span class="org-haskell-operator">=</span> channelBlue m

<span class="org-haskell-definition">getContrastingColor</span> <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">Floating</span> b, <span class="org-haskell-type">RealFrac</span> b) <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Colour</span> b <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Colour</span> b
<span class="org-haskell-definition">getContrastingColor</span> c <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">if</span> (getPerceivedLightness c) <span class="org-haskell-operator">&lt;</span> 50.0
  <span class="org-haskell-keyword">then</span> sRGB24 255 255 255
  <span class="org-haskell-keyword">else</span> sRGB24 0 0 0
</pre></div></div>
</div>
</li>
</ol>
</li>

<li><a id="h-Implementation-2"></a>Implementation<br>
<div class="outline-text-7" id="text-h-Implementation-2">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-34">melbyr_colorize_git_sha_24_bit</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_colorize_git_sha_24_bit">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_colorize_git_sha_24_bit"><span class="org-haskell-definition">colorizeGitSha24bit</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Word32</span> <span class="org-haskell-operator">-&gt;</span> [(<span class="org-haskell-type">SGR</span>, <span class="org-haskell-type">T.Text</span>)]
<span class="org-haskell-definition">colorizeGitSha24bit</span> shaStr len
  <span class="org-haskell-operator">=</span> reverse
  <span class="org-haskell-operator">.</span> zip colorCodes
  <span class="org-haskell-operator">.</span> buildOutput <span class="org-haskell-constructor">[]</span>
  <span class="org-haskell-operator">$</span> T.take (fromIntegral len) shaStr
  <span class="org-haskell-keyword">where</span>
  bytes <span class="org-haskell-operator">=</span> asBytes shaStr
  <span class="org-comment-delimiter">-- </span><span class="org-comment">XOR the first and second halves of the input bytes (20 bytes) to generate</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">10 more bytes. Now we have 30 bytes in total in bytesFinal.</span>
  bytes1 <span class="org-haskell-operator">=</span> B.take 10 bytes
  <span class="org-comment-delimiter">-- </span><span class="org-comment">FIXME: after ByteString 0.11.1.0, use B.takeEnd</span>
  bytes2 <span class="org-haskell-operator">=</span> B.drop (B.length bytes <span class="org-haskell-operator">-</span> 10) bytes
  bytesFinal <span class="org-haskell-operator">=</span> B.concat
    <span class="org-comment-delimiter">-- </span><span class="org-comment">FIXME: after ByteString 0.11.1.0, use B.packZipWith</span>
    <span class="org-comment-delimiter">--</span><span class="org-comment">[B.packZipWith (\a b -&gt; xor a b) bytes1 bytes2, B.reverse bytes]</span>
    [(B.pack <span class="org-haskell-operator">$</span> B.zipWith (<span class="org-haskell-operator">\</span>a b <span class="org-haskell-operator">-&gt;</span> xor a b) bytes1 bytes2), B.reverse bytes]
  <span class="org-comment-delimiter">-- </span><span class="org-comment">Using the 30 bytes in bytesFinal, generate 10 colors (of 3 bytes, or 24 bits, each).</span>
  colorCodes <span class="org-haskell-operator">=</span> gen10Colors <span class="org-haskell-constructor">[]</span> bytesFinal
  gen10Colors acc bs <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> B.length (B.take 3 bs) <span class="org-haskell-keyword">of</span>
    3 <span class="org-haskell-operator">-&gt;</span> gen10Colors ((toSgrCode <span class="org-haskell-operator">.</span> toRgbTuple <span class="org-haskell-operator">$</span> B.take 3 bs) <span class="org-haskell-constructor">:</span> acc) (B.drop 3 bs)
    <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> acc
  toRgbTuple bs3
    <span class="org-haskell-operator">=</span> ( fromIntegral <span class="org-haskell-operator">$</span> B.index bs3 0
      , fromIntegral <span class="org-haskell-operator">$</span> B.index bs3 1
      , fromIntegral <span class="org-haskell-operator">$</span> B.index bs3 2
      )
  toSgrCode (r, g, b) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">SetRGBColor</span> <span class="org-haskell-constructor">Background</span> <span class="org-haskell-operator">$</span> sRGB24 r g b
  <span class="org-comment-delimiter">-- </span><span class="org-comment">Construct the output string as groups of 4 hex chars each. Use the same</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">recursion pattern as in gen10Colors to build up an output that colorizes 4</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">hex chars at a time.</span>
  buildOutput acc hexChars <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> T.length (T.take 4 hexChars) <span class="org-haskell-keyword">of</span>
    0 <span class="org-haskell-operator">-&gt;</span> acc
    <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> buildOutput (T.take 4 hexChars <span class="org-haskell-constructor">:</span> acc) (T.drop 4 hexChars)
</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-34">melbyr_add_padding</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_add_padding">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_add_padding"><span class="org-haskell-definition">addPadding</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Word32</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Word32</span> <span class="org-haskell-operator">-&gt;</span> [(<span class="org-haskell-type">SGR</span>, <span class="org-haskell-type">T.Text</span>)] <span class="org-haskell-operator">-&gt;</span> [(<span class="org-haskell-type">SGR</span>, <span class="org-haskell-type">T.Text</span>)]
<span class="org-haskell-definition">addPadding</span> padl padr colorized <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> colorized <span class="org-haskell-keyword">of</span>
  <span class="org-haskell-constructor">[]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">[]</span>
  (c, t)<span class="org-haskell-constructor">:[]</span> <span class="org-haskell-operator">-&gt;</span> [(c, prefix <span class="org-haskell-operator">&lt;&gt;</span> t <span class="org-haskell-operator">&lt;&gt;</span> suffix)]
  (c1, t1)<span class="org-haskell-constructor">:</span>(c2, t2)<span class="org-haskell-constructor">:[]</span> <span class="org-haskell-operator">-&gt;</span> [(c1, prefix <span class="org-haskell-operator">&lt;&gt;</span> t1), (c2, t2 <span class="org-haskell-operator">&lt;&gt;</span> suffix)]
  <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">let</span>
    (c1, t1) <span class="org-haskell-operator">=</span> head colorized
    (c2, t2) <span class="org-haskell-operator">=</span> last colorized
    mid <span class="org-haskell-operator">=</span> init <span class="org-haskell-operator">$</span> drop 1 colorized
    <span class="org-haskell-keyword">in</span> [(c1, prefix <span class="org-haskell-operator">&lt;&gt;</span> t1)] <span class="org-haskell-operator">&lt;&gt;</span> mid <span class="org-haskell-operator">&lt;&gt;</span> [(c2, t2 <span class="org-haskell-operator">&lt;&gt;</span> suffix)]
  <span class="org-haskell-keyword">where</span>
  prefix <span class="org-haskell-operator">=</span> T.replicate (fromIntegral padl) <span class="org-string">" "</span>
  suffix <span class="org-haskell-operator">=</span> T.replicate (fromIntegral padr) <span class="org-string">" "</span>
</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-34">melbyr_render_misc</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_render_misc">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_render_misc"><span class="org-haskell-definition">renderColorized</span> <span class="org-haskell-operator">::</span> [(<span class="org-haskell-type">SGR</span>, <span class="org-haskell-type">T.Text</span>)] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">T.Text</span>
<span class="org-haskell-definition">renderColorized</span> <span class="org-haskell-operator">=</span> T.concat <span class="org-haskell-operator">.</span> map f
  <span class="org-haskell-keyword">where</span>
  f (code, hexChars) <span class="org-haskell-operator">=</span> T.pack (setSGRCode [code]) <span class="org-haskell-operator">&lt;&gt;</span> fgColor <span class="org-haskell-operator">&lt;&gt;</span> hexChars
    <span class="org-haskell-keyword">where</span>
    fgColor <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> code <span class="org-haskell-keyword">of</span>
      (<span class="org-haskell-constructor">SetRGBColor</span> <span class="org-haskell-constructor">Background</span> bgColor) <span class="org-haskell-operator">-&gt;</span> ( T.pack
                                          <span class="org-haskell-operator">$</span> setSGRCode [ <span class="org-haskell-constructor">SetRGBColor</span> <span class="org-haskell-constructor">Foreground</span>
                                                       <span class="org-haskell-operator">$</span> getContrastingColor bgColor
                                                       ])
      <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> T.empty

<span class="org-haskell-definition">asBytes</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">B.ByteString</span>
<span class="org-haskell-definition">asBytes</span> <span class="org-haskell-operator">=</span> (fromRight B.empty <span class="org-haskell-operator">.</span> B16.decode) <span class="org-haskell-operator">.</span> T.encodeUtf8
</pre></div></div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-h-Parse-path-aliases" class="outline-5">
<h5 id="h-Parse-path-aliases"><span class="section-number-5">6.5.11.3.</span> Parse path aliases</h5>
<div class="outline-text-5" id="text-h-Parse-path-aliases">
<div class="org-src-container"><pre class="src src-haskell" id="nil-35"><span class="org-haskell-pragma">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">MelbyRenderer.PathAliases</span>
  ( parsePathAliases
  , pPathAliases
  , pPathAlias
  ) <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Applicative</span> <span class="org-haskell-keyword">hiding</span> (many, some)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Map.Strict</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">M</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Text</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">T</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Void</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Text.Megaparsec</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Text.Megaparsec.Char</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Text.Megaparsec.Char.Lexer</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">L</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Char</span> (isAsciiUpper, isAsciiLower, isDigit, isPunctuation, isAlphaNum)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.Server</span> (<span class="org-haskell-constructor">MonadServer</span>)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Monad.Logger</span> <span class="org-haskell-keyword">hiding</span> (logDebug)

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.Log</span> (logDebug)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.Schema</span>

<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Megaparser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">Parsec</span> <span class="org-haskell-type">Void</span> <span class="org-haskell-type">T.Text</span>

<span class="org-haskell-definition">parsePathAliases</span>
  <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">MonadServer</span> m, <span class="org-haskell-type">MonadLogger</span> m)
  <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MParsePathAliasesRequest</span>
  <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-type">MParsePathAliasesResponse</span>
<span class="org-haskell-definition">parsePathAliases</span> req <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  logDebug <span class="org-haskell-operator">$</span> <span class="org-string">"request was: "</span> <span class="org-haskell-operator">&lt;&gt;</span> (T.pack <span class="org-haskell-operator">$</span> show req)
  <span class="org-haskell-keyword">let</span>
    result <span class="org-haskell-operator">=</span> parsePathAliasesRaw <span class="org-haskell-operator">$</span> path_aliases_raw req
  <span class="org-haskell-keyword">case</span> result <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Right</span> pathAliases <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MParsePathAliasesResponse</span>
      { status <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">PARSE_STATUS_OK</span>
      , path_aliases <span class="org-haskell-operator">=</span> pathAliases
      , error <span class="org-haskell-operator">=</span> <span class="org-string">""</span>
      }
    <span class="org-haskell-constructor">Left</span> err <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MParsePathAliasesResponse</span>
      { status <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">PARSE_STATUS_ERROR</span>
      , path_aliases <span class="org-haskell-operator">=</span> M.empty
      , error <span class="org-haskell-operator">=</span> err
      }

<span class="org-haskell-definition">parsePathAliasesRaw</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Either</span> <span class="org-haskell-type">T.Text</span> (<span class="org-haskell-type">M.Map</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-type">T.Text</span>)
<span class="org-haskell-definition">parsePathAliasesRaw</span> input <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> parse pPathAliases <span class="org-string">""</span> input <span class="org-haskell-keyword">of</span>
  <span class="org-haskell-constructor">Left</span> err <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">.</span> T.pack <span class="org-haskell-operator">$</span> errorBundlePretty err
  <span class="org-haskell-constructor">Right</span> m <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Right</span> m

<span class="org-haskell-definition">pPathAliases</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Megaparser</span> (<span class="org-haskell-type">M.Map</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-type">T.Text</span>)
<span class="org-haskell-definition">pPathAliases</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">Clear leading whitespace/comments.</span>
  <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">&lt;-</span> optional sc
  pathAliasesAsTuples <span class="org-haskell-operator">&lt;-</span> Text.Megaparsec.many pPathAlias
  eof
  pure <span class="org-haskell-operator">$</span> M.fromList pathAliasesAsTuples

<span class="org-haskell-definition">pPathAlias</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Megaparser</span> (<span class="org-haskell-type">T.Text</span>, <span class="org-haskell-type">T.Text</span>)
<span class="org-haskell-definition">pPathAlias</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">Example of the kind of line we want to parse:</span>
  <span class="org-comment-delimiter">--    </span><span class="org-comment">hash -d   kt=${HOME}/go/src/k8s.io/test-infra</span>
  <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">&lt;-</span> symbol <span class="org-string">"hash"</span>
  <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">&lt;-</span> symbol <span class="org-string">"-d"</span>
  alias <span class="org-haskell-operator">&lt;-</span> pAlias
  <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">&lt;-</span> char <span class="org-string">'='</span>
  path <span class="org-haskell-operator">&lt;-</span> T.concat <span class="org-haskell-operator">&lt;$&gt;</span> lexeme (directoryPath <span class="org-haskell-operator">&lt;?&gt;</span> <span class="org-string">"directory path"</span>)
  <span class="org-comment-delimiter">-- </span><span class="org-comment">We want to have the path as the key to the Map, because that's how we use</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">it back in Elixir (FIXME: add link).</span>
  pure (path, alias)
  <span class="org-comment-delimiter">-- </span><span class="org-comment">FIXME: Use withRecovery to recover from a parse error. See</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">https://stackoverflow.com/questions/59640023/how-to-report-multiple-errors-using-megaparsec.</span>
  <span class="org-comment-delimiter">--</span><span class="org-comment">if isValid path</span>
    <span class="org-comment-delimiter">--</span><span class="org-comment">then pure Just (path, alias)</span>
    <span class="org-comment-delimiter">--</span><span class="org-comment">else pure Nothing</span>
  <span class="org-haskell-keyword">where</span>
  directoryPath <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    dp <span class="org-haskell-operator">&lt;-</span> some <span class="org-haskell-operator">$</span> choice [pPath, pVariable]
    <span class="org-comment-delimiter">-- </span><span class="org-comment">This is a hacky way of checking cases where we should fail when the user</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">has put in an aberrant "$" symbol (when it is *not* used as part of</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">defining an environment variable like "${FOO}".) This is the only way we</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">can expect a kind of "eof" at the end here without actually using "eof"</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">(we can't use eof because this parser is part of a larger parser that</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">uses eof, namely pPathAliases). We would ideally want to use an eof here</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">because we want this parser to consume all non-space characters while</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">still playing nicely with the lexeme which consumes all trailing comments</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">and newlines.</span>

    <span class="org-comment-delimiter">-- </span><span class="org-comment">In other words, this checks the case where we have a badly formed path</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">like "/clam-chowder-$oup" --- here the "/clam-chowder-" will get</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">successfully parsed, and neither pVariable nor pPath will succeed on the</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">remaining "$oup" input. We want to ensure that whatever we end up</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">parsing, we will *NOT* get a dollar symbol immediately following a</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">successful parse.</span>
    notFollowedBy (char <span class="org-string">'$'</span>)
    pure dp

<span class="org-haskell-definition">pAlias</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Megaparser</span> <span class="org-haskell-type">T.Text</span>
<span class="org-haskell-definition">pAlias</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  firstLetter <span class="org-haskell-operator">&lt;-</span> satisfy isAllowedFirstLetter <span class="org-haskell-operator">&lt;?&gt;</span> <span class="org-string">"first letter of alias"</span>
  rest <span class="org-haskell-operator">&lt;-</span> takeWhileP (<span class="org-haskell-constructor">Just</span> <span class="org-string">"alias chars"</span>) isAllowedTrailingLetter
  pure <span class="org-haskell-operator">$</span> T.cons firstLetter rest
  <span class="org-haskell-keyword">where</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">The equivalent regex for the allowed range is "_A-Za-z0-9".</span>
  isAllowedFirstLetter c
    <span class="org-haskell-operator">=</span> or <span class="org-haskell-operator">$</span> Prelude.map (<span class="org-haskell-operator">$</span> c)
      [ isAsciiLower
      , isAsciiUpper
      , isDigit
      , (<span class="org-haskell-operator">==</span> <span class="org-string">'_'</span>)
      ]
  <span class="org-comment-delimiter">-- </span><span class="org-comment">Same as isAllowedFirstLetter, but also allow dashes. Note that these</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">parsing rules is just a reflection of what is normally allowed by Zsh's</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">"hash" builtin function. There, if we try something like "hash -d</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">-myalias=/a/very/long/path", the "-myalias" gets interpreted as a flag to</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">the "hash" function. This is why we don't allow the dash character to be</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">used as the first letter of the alias.</span>
  isAllowedTrailingLetter c <span class="org-haskell-operator">=</span> isAllowedFirstLetter c <span class="org-haskell-operator">||</span> c <span class="org-haskell-operator">==</span> <span class="org-string">'-'</span>

<span class="org-haskell-definition">pPath</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Megaparser</span> <span class="org-haskell-type">T.Text</span>
<span class="org-haskell-definition">pPath</span> <span class="org-haskell-operator">=</span> takeWhile1P (<span class="org-haskell-constructor">Just</span> <span class="org-string">"directory chars"</span>) isAllowedPathChar
  <span class="org-haskell-keyword">where</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">Technically speaking, a folder can have a literal "$" character in it, like</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">this: "/foo/bar/\$baz", but in order to simplify our implementation we</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">forbid them because they are too rare. So, we just prohibit the dollar</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">symbol, because it is the first expected character of a variable.</span>
  isAllowedPathChar c <span class="org-haskell-operator">=</span> (c <span class="org-haskell-operator">/=</span> <span class="org-string">'$'</span>) <span class="org-haskell-operator">&amp;&amp;</span> (isAlphaNum c <span class="org-haskell-operator">||</span> isPunctuation c)

<span class="org-haskell-definition">pVariable</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Megaparser</span> <span class="org-haskell-type">T.Text</span>
<span class="org-haskell-definition">pVariable</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">&lt;-</span> string <span class="org-string">"${"</span> <span class="org-haskell-operator">&lt;?&gt;</span> <span class="org-string">"dollar-and-opening-brace"</span>
  firstLetter <span class="org-haskell-operator">&lt;-</span> satisfy isAllowedFirstLetter <span class="org-haskell-operator">&lt;?&gt;</span> <span class="org-string">"first letter of shell variable name"</span>
  rest <span class="org-haskell-operator">&lt;-</span> takeWhile1P (<span class="org-haskell-constructor">Just</span> <span class="org-string">"shell variable name chars"</span>) isAllowedTrailingLetter
  <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">&lt;-</span> char <span class="org-string">'}'</span>
  pure <span class="org-haskell-operator">$</span> <span class="org-string">"${"</span> <span class="org-haskell-operator">&lt;&gt;</span> T.cons firstLetter rest <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">"}"</span>
  <span class="org-haskell-keyword">where</span>
  isAllowedFirstLetter c
    <span class="org-haskell-operator">|</span> isAsciiUpper c <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
    <span class="org-haskell-operator">|</span> c <span class="org-haskell-operator">==</span> <span class="org-string">'_'</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
    <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
  isAllowedTrailingLetter c <span class="org-haskell-operator">=</span> isAllowedFirstLetter c <span class="org-haskell-operator">||</span> isDigit c

<span class="org-comment-delimiter">-- </span><span class="org-comment">This is taken from https://markkarpov.com/tutorial/megaparsec.html#lexing. We</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">want to use these lexeme-based helpers to create parsers that ignore both</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">whitespace as well as comment lines. Othwerwise, we'd have to manually</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">construct these parsers as well, which is annoying and too low-level for us.</span>
<span class="org-haskell-definition">sc</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Megaparser</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">sc</span> <span class="org-haskell-operator">=</span> L.space
  space1
  (L.skipLineComment <span class="org-string">"#"</span>)
  Text.Megaparsec.empty

<span class="org-haskell-definition">lexeme</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Megaparser</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Megaparser</span> a
<span class="org-haskell-definition">lexeme</span> <span class="org-haskell-operator">=</span> L.lexeme sc

<span class="org-haskell-definition">symbol</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Megaparser</span> <span class="org-haskell-type">T.Text</span>
<span class="org-haskell-definition">symbol</span> <span class="org-haskell-operator">=</span> L.symbol sc
</pre></div><div class="org-src-container"><pre class="src src-haskell" id="nil-36"><span class="org-haskell-pragma">{-# LANGUAGE QuasiQuotes #-}</span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">Main</span> (main) <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Map.Strict</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">M</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">NeatInterpolation</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Test.Hspec</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Test.Hspec.Megaparsec</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Text.Megaparsec</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.PathAliases</span> (pPathAlias, pPathAliases)

<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> hspec <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  describe <span class="org-string">"pPathAlias"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">Good cases.</span>
    context <span class="org-string">"when parsing a typical case"</span> <span class="org-haskell-operator">$</span>
      it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span>
        parse pPathAlias <span class="org-string">""</span> <span class="org-string">"hash -d foo=/bar"</span> <span class="org-haskell-operator">`shouldParse`</span> (<span class="org-string">"/bar"</span>, <span class="org-string">"foo"</span>)
    context <span class="org-string">"when parsing a typical case with extra spaces"</span> <span class="org-haskell-operator">$</span>
      it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span>
        parse pPathAlias <span class="org-string">""</span> <span class="org-string">"hash   -d     foo=/bar   "</span> <span class="org-haskell-operator">`shouldParse`</span> (<span class="org-string">"/bar"</span>, <span class="org-string">"foo"</span>)
    context <span class="org-string">"when parsing a path with an embedded variable"</span> <span class="org-haskell-operator">$</span>
      it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span>
        parse pPathAlias <span class="org-string">""</span> <span class="org-string">"hash -d   kk=${HOME}/go/src/k8s.io/kubernetes"</span>
          <span class="org-haskell-operator">`shouldParse`</span> (<span class="org-string">"${HOME}/go/src/k8s.io/kubernetes"</span>, <span class="org-string">"kk"</span>)
    context <span class="org-string">"when parsing a path with multiple embedded variables"</span> <span class="org-haskell-operator">$</span>
      it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span>
        parse pPathAlias <span class="org-string">""</span> <span class="org-string">"hash -d   x=${HOME}/foo/${SUBDIR}/baz"</span>
          <span class="org-haskell-operator">`shouldParse`</span> (<span class="org-string">"${HOME}/foo/${SUBDIR}/baz"</span>, <span class="org-string">"x"</span>)
    context <span class="org-string">"when parsing a path with a trailing comment"</span> <span class="org-haskell-operator">$</span>
      it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span>
        parse pPathAlias <span class="org-string">""</span> <span class="org-string">"hash -d   x=${HOME}/hello # Comment text"</span>
          <span class="org-haskell-operator">`shouldParse`</span> (<span class="org-string">"${HOME}/hello"</span>, <span class="org-string">"x"</span>)
    <span class="org-comment-delimiter">-- </span><span class="org-comment">Bad cases.</span>
    context <span class="org-string">"when the equal sign has a space to the left"</span> <span class="org-haskell-operator">$</span>
      it <span class="org-string">"fails"</span> <span class="org-haskell-operator">$</span>
        parse pPathAlias <span class="org-string">""</span> <span class="org-string">"hash   -d     foo =/bar   "</span>
          <span class="org-haskell-operator">`shouldFailWith`</span> err 17 (utok <span class="org-string">' '</span> <span class="org-haskell-operator">&lt;&gt;</span> etok <span class="org-string">'='</span> <span class="org-haskell-operator">&lt;&gt;</span> elabel <span class="org-string">"alias chars"</span>)
    context <span class="org-string">"when the equal sign has a space to the right"</span> <span class="org-haskell-operator">$</span>
      it <span class="org-string">"fails"</span> <span class="org-haskell-operator">$</span>
        parse pPathAlias <span class="org-string">""</span> <span class="org-string">"hash   -d     foo= /bar   "</span>
          <span class="org-haskell-operator">`shouldFailWith`</span> err 18 (utoks <span class="org-string">" /"</span> <span class="org-haskell-operator">&lt;&gt;</span> elabel <span class="org-string">"directory path"</span>)
    context <span class="org-string">"when there is an aberrant dollar sign in the path"</span> <span class="org-haskell-operator">$</span>
      it <span class="org-string">"fails"</span> <span class="org-haskell-operator">$</span>
        parse pPathAlias <span class="org-string">""</span> <span class="org-string">"hash -d x=/clam-chowder-$oup\n"</span>
          <span class="org-haskell-operator">`shouldFailWith`</span> err 24 (utok <span class="org-string">'$'</span> <span class="org-haskell-operator">&lt;&gt;</span> elabel <span class="org-string">"directory chars"</span>
                                            <span class="org-haskell-operator">&lt;&gt;</span> elabel <span class="org-string">"dollar-and-opening-brace"</span>)
  describe <span class="org-string">"pPathAliases"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    context <span class="org-string">"when there are comment lines"</span> <span class="org-haskell-operator">$</span>
      it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span>
        <span class="org-haskell-keyword">let</span>
          x <span class="org-haskell-operator">=</span>
            [trimming<span class="org-haskell-quasi-quote">|</span>

<span class="org-haskell-quasi-quote">            # Comment at beginning of file.</span>

<span class="org-haskell-quasi-quote">            hash -d x=/foo # Trailing comment.</span>
<span class="org-haskell-quasi-quote">            # Commented out declaration.</span>
<span class="org-haskell-quasi-quote">            # hash -d x=/foo</span>

<span class="org-haskell-quasi-quote">            # Unfortunately we have to escape the dollar sign to make it play</span>
<span class="org-haskell-quasi-quote">            # nicely with Template Haskell.</span>
<span class="org-haskell-quasi-quote">            hash -d kk=$${HOME}/go/src/k8s.io/kubernetes</span>

<span class="org-haskell-quasi-quote">            # Indented entry.</span>
<span class="org-haskell-quasi-quote">              hash    -d   y=/hello</span>
<span class="org-haskell-quasi-quote">            # Comment at end of file.</span>
<span class="org-haskell-quasi-quote">            |</span>]
        <span class="org-haskell-keyword">in</span> parse pPathAliases <span class="org-string">""</span> x
           <span class="org-haskell-operator">`shouldParse`</span> M.fromList
             [ (<span class="org-string">"/foo"</span>, <span class="org-string">"x"</span>)
             , (<span class="org-string">"${HOME}/go/src/k8s.io/kubernetes"</span>, <span class="org-string">"kk"</span>)
             , (<span class="org-string">"/hello"</span>, <span class="org-string">"y"</span>)]
</pre></div>
</div>
</div>
</div>

<div id="outline-container-h-Boilerplate-2" class="outline-4">
<h4 id="h-Boilerplate-2"><span class="section-number-4">6.5.12.</span> Boilerplate</h4>
<div class="outline-text-4" id="text-h-Boilerplate-2">
</div>

<div id="outline-container-h-Option-handling-1" class="outline-5">
<h5 id="h-Option-handling-1"><span class="section-number-5">6.5.12.1.</span> Option handling</h5>
<div class="outline-text-5" id="text-h-Option-handling-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Layout-of--code-melby-renderer-hs--code">melbyr_option_handling</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_option_handling">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_option_handling"><span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_option_handling_types">melbyr_option_handling_types</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_option_handling_parsers">melbyr_option_handling_parsers</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_option_handling_dispatcher">melbyr_option_handling_dispatcher</a></span>
</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyr_option_handling">melbyr_option_handling_types</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_option_handling_types">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_option_handling_types"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">Opts</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Opts</span>
  { subcommand <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Subcommand</span> }

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Subcommand</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Serve</span> <span class="org-haskell-constructor">ServeOpts</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Ping</span>

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">ServeOpts</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ServeOpts</span>
  { oPort <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span>
  }
</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyr_option_handling">melbyr_option_handling_parsers</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_option_handling_parsers">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_option_handling_parsers"><span class="org-haskell-definition">optionsP</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Parser</span> <span class="org-haskell-type">Opts</span>
<span class="org-haskell-definition">optionsP</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Opts</span> <span class="org-haskell-operator">&lt;$&gt;</span> subcommandP

<span class="org-haskell-definition">subcommandP</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Parser</span> <span class="org-haskell-type">Subcommand</span>
<span class="org-haskell-definition">subcommandP</span> <span class="org-haskell-operator">=</span> hsubparser
  (  command <span class="org-string">"serve"</span> (info (<span class="org-haskell-constructor">Serve</span> <span class="org-haskell-operator">&lt;$&gt;</span> serveOptsP) (progDesc <span class="org-string">"get prompt information with Lua"</span>))
  <span class="org-haskell-operator">&lt;&gt;</span> command <span class="org-string">"ping"</span> (info (pure <span class="org-haskell-constructor">Ping</span>) (progDesc <span class="org-string">"FIXME ?"</span>))
  <span class="org-haskell-operator">&lt;&gt;</span> metavar <span class="org-string">"SUBCOMMAND"</span>
  )

<span class="org-haskell-definition">serveOptsP</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Parser</span> <span class="org-haskell-type">ServeOpts</span>
<span class="org-haskell-definition">serveOptsP</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ServeOpts</span>
  <span class="org-haskell-operator">&lt;$&gt;</span> (argument auto (metavar <span class="org-string">"PORT"</span>))

</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyr_option_handling">melbyr_option_handling_dispatcher</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_option_handling_dispatcher">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_option_handling_dispatcher"><span class="org-haskell-definition">optsHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Opts</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">optsHandler</span> (<span class="org-haskell-constructor">Opts</span> subcommand') <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-keyword">case</span> subcommand' <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Serve</span> o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"serving over port "</span> <span class="org-haskell-operator">&lt;&gt;</span> (show (oPort o))
      mixEnv <span class="org-haskell-operator">&lt;-</span> lookupEnv <span class="org-string">"MIX_ENV"</span>
      <span class="org-haskell-keyword">let</span>
        logFilter <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> mixEnv <span class="org-haskell-keyword">of</span>
          <span class="org-comment-delimiter">-- </span><span class="org-comment">For production, disable LevelDebug logs.</span>
          <span class="org-haskell-constructor">Just</span> <span class="org-string">"prod"</span> <span class="org-haskell-operator">-&gt;</span> (<span class="org-haskell-operator">\</span>_logSource logLevel <span class="org-haskell-operator">-&gt;</span> logLevel <span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">LevelInfo</span>)
          <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> (<span class="org-haskell-operator">\</span><span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">True</span>)
      runGRpcAppTrans msgProtoBuf (oPort o) (runStderrLoggingT <span class="org-haskell-operator">.</span> filterLogger logFilter) renderer
    <span class="org-haskell-constructor">Ping</span> <span class="org-haskell-operator">-&gt;</span> putStrLn <span class="org-string">"not implemented"</span>

<span class="org-haskell-definition">renderer</span> <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">MonadServer</span> m, <span class="org-haskell-type">MonadLogger</span> m) <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">SingleServerT</span> info <span class="org-haskell-type">Renderer</span> m <span class="org-haskell-keyword">_</span>
<span class="org-haskell-definition">renderer</span> <span class="org-haskell-operator">=</span> singleService
  ( method <span class="org-haskell-operator">@</span><span class="org-string">"GetColorizedGitSha"</span> getColorizedGitSha
  , method <span class="org-haskell-operator">@</span><span class="org-string">"RenderWidgets"</span> renderWidgets
  , method <span class="org-haskell-operator">@</span><span class="org-string">"ParsePathAliases"</span> parsePathAliases
  )
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Main-1" class="outline-5">
<h5 id="h-Main-1"><span class="section-number-5">6.5.12.2.</span> Main</h5>
<div class="outline-text-5" id="text-h-Main-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Layout-of--code-melby-renderer-hs--code">melbyr_main</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_main">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_main"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  opts <span class="org-haskell-operator">&lt;-</span> customExecParser (prefs showHelpOnEmpty) optsP
  optsHandler opts
  <span class="org-haskell-keyword">where</span>
  optsP <span class="org-haskell-operator">=</span> info parserProgramOptions infoMod
  parserProgramOptions <span class="org-haskell-operator">=</span> helper
    <span class="org-haskell-operator">&lt;*&gt;</span> versionOption
    <span class="org-haskell-operator">&lt;*&gt;</span> optionsP
  infoMod <span class="org-haskell-operator">=</span> fullDesc
    <span class="org-haskell-operator">&lt;&gt;</span> header <span class="org-string">"melbyr - melby renderer"</span>
  <span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_gitVersion">melbyr_gitVersion</a></span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-gRPC-schema-1" class="outline-5">
<h5 id="h-gRPC-schema-1"><span class="section-number-5">6.5.12.3.</span> gRPC schema</h5>
<div class="outline-text-5" id="text-h-gRPC-schema-1">
<p>
FIXME: break this up into smaller chunks
</p>

<div class="org-src-container"><pre class="src src-haskell" id="nil-37"><span class="org-haskell-pragma">{-# language CPP                   #-}</span>
<span class="org-haskell-pragma">{-# language DataKinds             #-}</span>
<span class="org-haskell-pragma">{-# language DeriveAnyClass        #-}</span>
<span class="org-haskell-pragma">{-# language DeriveGeneric         #-}</span>
<span class="org-haskell-pragma">{-# language DerivingVia           #-}</span>
<span class="org-haskell-pragma">{-# language DuplicateRecordFields #-}</span>
<span class="org-haskell-pragma">{-# language FlexibleContexts      #-}</span>
<span class="org-haskell-pragma">{-# language FlexibleInstances     #-}</span>
<span class="org-haskell-pragma">{-# language MultiParamTypeClasses #-}</span>
<span class="org-haskell-pragma">{-# language OverloadedLabels      #-}</span>
<span class="org-haskell-pragma">{-# language PolyKinds             #-}</span>
<span class="org-haskell-pragma">{-# language TemplateHaskell       #-}</span>
<span class="org-haskell-pragma">{-# language TypeFamilies          #-}</span>
<span class="org-haskell-pragma">{-# language TypeOperators         #-}</span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">MelbyRenderer.Schema</span> <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Map.Strict</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">M</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Text</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">T</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Word</span> (<span class="org-haskell-constructor">Word32</span>)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">GHC.Generics</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.Quasi.GRpc</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.Schema</span>

<span class="org-haskell-definition">grpc</span> <span class="org-string">"MelbyRendererSchema"</span> id <span class="org-string">"lib/MelbyRenderer/melby_renderer.proto"</span>

<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_schema_colorized_git_sha">melbyr_schema_colorized_git_sha</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_schema_widgets">melbyr_schema_widgets</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_schema_render_options">melbyr_schema_render_options</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__melbyr_schema_parse_path_aliases">melbyr_schema_parse_path_aliases</a></span>
</pre></div>
</div>

<div id="outline-container-h-Colorized-Git-SHA-2" class="outline-6">
<h6 id="h-Colorized-Git-SHA-2"><span class="section-number-6">6.5.12.3.1.</span> Colorized Git SHA</h6>
<div class="outline-text-6" id="text-h-Colorized-Git-SHA-2">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-37">melbyr_schema_colorized_git_sha</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_schema_colorized_git_sha">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_schema_colorized_git_sha"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MColorizedGitShaRequest</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MColorizedGitShaRequest</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">In mu-haskell, nested types must be contained in a Maybe. See</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">https://github.com/higherkindness/mu-haskell/issues/255#issuecomment-730468011.</span>
  { sha <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  , sha_length <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Word32</span>
  , pad_left <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Word32</span>
  , pad_right <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Word32</span>
  , render_options <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">MRenderOptions</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ColorizedGitShaRequest"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ColorizedGitShaRequest"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MColorizedGitShaResponse</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MColorizedGitShaResponse</span>
  { sha_colorized <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ColorizedGitShaResponse"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ColorizedGitShaResponse"</span>)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Render-options" class="outline-6">
<h6 id="h-Render-options"><span class="section-number-6">6.5.12.3.2.</span> Render options</h6>
<div class="outline-text-6" id="text-h-Render-options">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-37">melbyr_schema_render_options</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_schema_render_options">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_schema_render_options"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MRenderOptions</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MRenderOptions</span>
  { format <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MRenderFormat</span>
  , color_depth <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MRenderColorDepth</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
           , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderOptions"</span>
           , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderOptions"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MRenderFormat</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RENDER_FORMAT_UNSPECIFIED</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">RENDER_FORMAT_UNIX_TERMINAL</span>
  <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
           , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderFormat"</span>
           , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderFormat"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MRenderColorDepth</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RENDER_COLOR_DEPTH_UNSPECIFIED</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">RENDER_COLOR_DEPTH_256</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">RENDER_COLOR_DEPTH_24_BIT</span>
  <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
           , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderColorDepth"</span>
           , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderColorDepth"</span>)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Widgets" class="outline-6">
<h6 id="h-Widgets"><span class="section-number-6">6.5.12.3.3.</span> Widgets</h6>
<div class="outline-text-6" id="text-h-Widgets">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-37">melbyr_schema_widgets</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_schema_widgets">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_schema_widgets"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MRenderWidgetsRequest</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MRenderWidgetsRequest</span>
  { widgets <span class="org-haskell-operator">::</span> [<span class="org-haskell-type">MWidget</span>]
  , delimiter <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">MWidget</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">FIXME: allow duplicate fields once we move to GHC 9 (waiting on mu-haskell)</span>
  , render_options <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">MRenderOptions</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderWidgetsRequest"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderWidgetsRequest"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MRenderWidgetsResponse</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MRenderWidgetsResponse</span>
  { widgets_rendered <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderWidgetsResponse"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"RenderWidgetsResponse"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MWidget</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MWidget</span>
  { str <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  , prop <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">MTextProperty</span>
  , drop_delim_left <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Bool</span>
  , drop_delim_right <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Bool</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
           , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"Widget"</span>
           , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"Widget"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MTextProperty</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MTextProperty</span>
  { fg <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">MColor</span>
  , bg <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">MColor</span>
  , styles <span class="org-haskell-operator">::</span> [<span class="org-haskell-type">MTextStyle</span>]
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
           , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"TextProperty"</span>
           , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"TextProperty"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MColor</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MColor</span>
  { color_oneof <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MColorOneof</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
           , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"Color"</span>
           , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"Color"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MColorOneof</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MColorOneOf24Bit</span> <span class="org-haskell-constructor">MColor24Bit</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">MColorOneOf256</span> <span class="org-haskell-constructor">Word32</span>
  <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MColor24Bit</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MColor24Bit</span>
  { red <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Word32</span>
  , green <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Word32</span>
  , blue <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Word32</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">FIXME: add alpha channel?</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"Color24Bit"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"Color24Bit"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MTextStyle</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">TEXT_STYLE_UNSPECIFIED</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">TEXT_STYLE_BOLD</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">TEXT_STYLE_ITALIC</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">TEXT_STYLE_UNDERLINE</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">TEXT_STYLE_UNDERLINE_DOUBLE</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">TEXT_STYLE_BLINK</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">TEXT_STYLE_BLINK_RAPID</span>
  <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
           , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"TextStyle"</span>
           , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"TextStyle"</span>)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Parse-path-aliases-1" class="outline-6">
<h6 id="h-Parse-path-aliases-1"><span class="section-number-6">6.5.12.3.4.</span> Parse path aliases</h6>
<div class="outline-text-6" id="text-h-Parse-path-aliases-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#nil-37">melbyr_schema_parse_path_aliases</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_schema_parse_path_aliases">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_schema_parse_path_aliases"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MParsePathAliasesRequest</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MParsePathAliasesRequest</span>
  { path_aliases_raw <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ParsePathAliasesRequest"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ParsePathAliasesRequest"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MParsePathAliasesResponse</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">MParsePathAliasesResponse</span>
  { status <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MParseStatus</span>
  , path_aliases <span class="org-haskell-operator">::</span> <span class="org-haskell-type">M.Map</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-type">T.Text</span>
  , error <span class="org-haskell-operator">::</span> <span class="org-haskell-type">T.Text</span>
  } <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
             , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ParsePathAliasesResponse"</span>
             , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ParsePathAliasesResponse"</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">MParseStatus</span>
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">PARSE_STATUS_UNSPECIFIED</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">PARSE_STATUS_ERROR</span>
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">PARSE_STATUS_OK</span>
  <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Ord</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Generic</span>
           , <span class="org-haskell-constructor">ToSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ParseStatus"</span>
           , <span class="org-haskell-constructor">FromSchema</span> <span class="org-haskell-constructor">MelbyRendererSchema</span> <span class="org-string">"ParseStatus"</span>)
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Logging" class="outline-5">
<h5 id="h-Logging"><span class="section-number-5">6.5.12.4.</span> Logging</h5>
<div class="outline-text-5" id="text-h-Logging">
<div class="org-src-container"><pre class="src src-haskell" id="nil-38"><span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">MelbyRenderer.Log</span> <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Monad.Logger</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Monad.Logger.Prefix</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Text</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">T</span>

<span class="org-comment-delimiter">-- </span><span class="org-comment">FIXME: Make this debug output an environment variable option (only turn it on</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">if lookupEnv says MELBYR_VERBOSE is true).</span>
<span class="org-haskell-definition">logDebug</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadLogger</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">logDebug</span> t <span class="org-haskell-operator">=</span> prefixLogs <span class="org-string">"melbyr"</span> <span class="org-haskell-operator">$</span> logDebugN t
</pre></div>
</div>
</div>

<div id="outline-container-h-Other-2" class="outline-5">
<h5 id="h-Other-2"><span class="section-number-5">6.5.12.5.</span> Other</h5>
<div class="outline-text-5" id="text-h-Other-2">
</div>
<div id="outline-container-h-Pragmas-1" class="outline-6">
<h6 id="h-Pragmas-1"><span class="section-number-6">6.5.12.5.1.</span> Pragmas</h6>
<div class="outline-text-6" id="text-h-Pragmas-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Layout-of--code-melby-renderer-hs--code">melbyr_pragmas</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_pragmas">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_pragmas"><span class="org-haskell-pragma">{-# LANGUAGE DataKinds #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE OverloadedLabels #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE PartialTypeSignatures #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeApplications #-}</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">It's funny that we have to specify this, when we already declare</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">PartialTypeSignatures above.</span>
<span class="org-haskell-pragma">{-# OPTIONS_GHC -fno-warn-partial-type-signatures #-}</span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Imports-1" class="outline-6">
<h6 id="h-Imports-1"><span class="section-number-6">6.5.12.5.2.</span> Imports</h6>
<div class="outline-text-6" id="text-h-Imports-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Layout-of--code-melby-renderer-hs--code">melbyr_imports</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_imports">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_imports"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Monad.Logger</span> <span class="org-haskell-keyword">hiding</span> (logDebug)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Version</span> (showVersion)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.GRpc.Server</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Mu.Server</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Options.Applicative</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Environment</span> (lookupEnv)

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Paths_melby_renderer</span> (version)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.Colorizer</span> (getColorizedGitSha)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.GitVersion</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.Schema</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.PathAliases</span> (parsePathAliases)
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">MelbyRenderer.Widgets</span> (renderWidgets)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Git-versioning-1" class="outline-6">
<h6 id="h-Git-versioning-1"><span class="section-number-6">6.5.12.5.3.</span> Git versioning</h6>
<div class="outline-text-6" id="text-h-Git-versioning-1">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__melbyr_main">melbyr_gitVersion</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__melbyr_gitVersion">&#x1f517;</a></span></div><pre class="src src-haskell" id="__NREF__melbyr_gitVersion"><span class="org-haskell-definition">versionOption</span> <span class="org-haskell-operator">=</span> infoOption
  (concat [showVersion version, <span class="org-string">"-g"</span>, <span class="org-haskell-operator">$</span>(gitVersion)])
  (long <span class="org-string">"version"</span> <span class="org-haskell-operator">&lt;&gt;</span> short <span class="org-string">'v'</span> <span class="org-haskell-operator">&lt;&gt;</span> help <span class="org-string">"Show version"</span>)
</pre></div></div><p>
FIXME: should we move this to a common "melby" haskell package?
</p>

<div class="org-src-container"><pre class="src src-haskell" id="nil-39"><span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">MelbyRenderer.GitVersion</span>
  ( gitVersion
  ) <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Time.LocalTime</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Language.Haskell.TH</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Environment</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Process</span>

<span class="org-haskell-definition">gitVersion</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Q</span> <span class="org-haskell-type">Exp</span>
<span class="org-haskell-definition">gitVersion</span> <span class="org-haskell-operator">=</span> stringE <span class="org-haskell-operator">=&lt;&lt;</span> runIO getCombinedInfo

<span class="org-haskell-definition">getCombinedInfo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-definition">getCombinedInfo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  gi <span class="org-haskell-operator">&lt;-</span> getGitInfo
  ti <span class="org-haskell-operator">&lt;-</span> getTimeInfo
  pure <span class="org-haskell-operator">$</span> concat [gi, <span class="org-string">"  ("</span>, ti, <span class="org-string">")"</span>]

<span class="org-haskell-definition">getGitInfo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-definition">getGitInfo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  maybeProjectRoot <span class="org-haskell-operator">&lt;-</span> lookupEnv <span class="org-string">"MELBY_PROJECT_ROOT"</span>
  <span class="org-haskell-keyword">case</span> maybeProjectRoot <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Just</span> projectRoot <span class="org-haskell-operator">-&gt;</span> readProcess <span class="org-string">"git"</span>
      [<span class="org-string">"-C"</span>, projectRoot, <span class="org-string">"describe"</span>, <span class="org-string">"--abbrev=10"</span>, <span class="org-string">"--always"</span>, <span class="org-string">"--dirty"</span>] <span class="org-string">""</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-string">"-unknown"</span>

<span class="org-haskell-definition">getTimeInfo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-definition">getTimeInfo</span> <span class="org-haskell-operator">=</span> show <span class="org-haskell-operator">&lt;$&gt;</span> getZonedTime
</pre></div>
</div>
</div>
</div>
</div>

<div id="outline-container-h-Build-system-1" class="outline-4">
<h4 id="h-Build-system-1"><span class="section-number-4">6.5.13.</span> Build system</h4>
<div class="outline-text-4" id="text-h-Build-system-1">
</div>

<div id="outline-container-h-Makefile-2" class="outline-5">
<h5 id="h-Makefile-2"><span class="section-number-5">6.5.13.1.</span> Makefile</h5>
<div class="outline-text-5" id="text-h-Makefile-2">
<p>
This follows the Makefile for <code>melbyc</code> (FIXME: add link).
</p>

<div class="org-src-container"><pre class="src src-makefile" id="nil-40"><span class="org-variable-name">ZLIB_SO_DIR</span>=$(<span class="org-variable-name">shell</span> pkg-config --libs-only-L zlib)
<span class="org-variable-name">ZLIB_H_DIR</span>=$(<span class="org-variable-name">shell</span> pkg-config --cflags-only-I zlib)

<span class="org-makefile-targets">all</span>: melbyr

<span class="org-makefile-targets">melbyr</span>:
    <span class="org-variable-name">MELBY_PROJECT_ROOT</span>=$(<span class="org-variable-name">PWD</span>) stack build \
        --copy-bins \
        --local-bin-path $(<span class="org-variable-name">PWD</span>) \
        --no-nix-pure \
        <span class="org-variable-name">--extra-lib-dirs</span>=$(<span class="org-variable-name">ZLIB_SO_DIR</span>:<span class="org-variable-name">-L%</span>=%) \
        <span class="org-variable-name">--extra-include-dirs</span>=$(<span class="org-variable-name">ZLIB_H_DIR</span>:<span class="org-variable-name">-I%</span>=%)
<span class="org-makefile-targets">.PHONY</span>: melbyr

<span class="org-makefile-targets">ghci</span>:
    stack exec -- ghci
<span class="org-makefile-targets">.PHONY</span>: ghci

<span class="org-comment-delimiter"># </span><span class="org-comment">This avoids building the main executable on top of the base library and test</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">executable. For various reasons, Stack always builds the main executable</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">binary. See https://github.com/commercialhaskell/stack/issues/5647#issuecomment-1106796448.</span>
<span class="org-makefile-targets">test</span>:
    <span class="org-makefile-targets">stack build melby-renderer</span>:test
<span class="org-makefile-targets">.PHONY</span>: test
</pre></div>
</div>
</div>

<div id="outline-container-h-Cabal-1" class="outline-5">
<h5 id="h-Cabal-1"><span class="section-number-5">6.5.13.2.</span> Cabal</h5>
<div class="outline-text-5" id="text-h-Cabal-1">
<div class="org-src-container"><pre class="src src-haskell-cabal" id="nil-41"><span class="org-keyword">name</span>: melby-renderer
<span class="org-keyword">version</span>: 1.0.0.0
<span class="org-keyword">author</span>: Linus Arver
<span class="org-keyword">maintainer</span>: linusa@google.com
<span class="org-keyword">category</span>: Utility
<span class="org-keyword">build-type</span>: Simple
<span class="org-keyword">cabal-version</span>: &gt;=1.10
<span class="org-keyword">license</span>: Apache-2.0
<span class="org-keyword">license-file</span>: LICENSE
<span class="org-keyword">data-files</span>: lib/MelbyRenderer/melby_renderer.proto

<span class="org-keyword">executable</span> <span class="org-function-name">melbyr</span>
  <span class="org-keyword">main-is</span>: melby-renderer.hs
  <span class="org-keyword">default-language</span>: Haskell2010
  <span class="org-keyword">other-modules</span>:
    Paths_melby_renderer
  <span class="org-keyword">default-extensions</span>:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  <span class="org-keyword">ghc-options</span>:
    -O2 -Werror -threaded -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  <span class="org-keyword">build-depends</span>:
      base &gt;= 4.8
    , melby-renderer
    , monad-logger &gt;= 0.3 &amp;&amp; &lt;0.4
    , mu-grpc-server &gt;=0.3.0.0
    , mu-rpc &gt;= 0.4.0
    , optparse-applicative &gt;= 0.16.1.0

<span class="org-keyword">library</span>
  <span class="org-keyword">default-language</span>: Haskell2010
  <span class="org-keyword">exposed-modules</span>:
    MelbyRenderer.Colorizer
    MelbyRenderer.GitVersion
    MelbyRenderer.Log
    MelbyRenderer.PathAliases
    MelbyRenderer.Schema
    MelbyRenderer.Widgets
  <span class="org-keyword">hs-source-dirs</span>:
    lib
  <span class="org-keyword">default-extensions</span>:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  <span class="org-keyword">ghc-options</span>:
    -O2 -Werror -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  <span class="org-keyword">build-depends</span>:
      base &gt;= 4.8
    , aeson
    , ansi-terminal
    , base16-bytestring
    , bytestring
    , colour
    , containers &gt;= 0.6.5.1
    , megaparsec &gt;= 9.0.1
    , monad-logger &gt;= 0.3 &amp;&amp; &lt;0.4
    , monad-logger-prefix &gt;= 0.1.12 &amp;&amp; &lt;0.2
    , mu-protobuf &gt;= 0.4.0
    , mu-grpc-server &gt;=0.3.0.0
    , mu-rpc &gt;= 0.4.0
    , mu-schema &gt;= 0.3.0
    , process
    , template-haskell
    , text &gt;=1.2 &amp;&amp; &lt;2
    , time

<span class="org-keyword">test-suite</span> <span class="org-function-name">test</span>
  <span class="org-keyword">type</span>: exitcode-stdio-1.0
  <span class="org-keyword">hs-source-dirs</span>: test
  <span class="org-keyword">main-is</span>: Main.hs
  <span class="org-keyword">default-language</span>: Haskell2010
  <span class="org-keyword">default-extensions</span>:
    DisambiguateRecordFields
    DuplicateRecordFields
    ImportQualifiedPost
    LambdaCase
    MultiWayIf
    NoDoAndIfThenElse
    NoNondecreasingIndentation
    OverloadedStrings
  <span class="org-keyword">ghc-options</span>:
    -O2 -Werror -threaded -fno-warn-tabs
    -Wall -Wcompat -Widentities -Wincomplete-uni-patterns
    -Wincomplete-record-updates -Wredundant-constraints
    -fhide-source-paths -Wpartial-fields -fforce-recomp
  <span class="org-keyword">build-depends</span>:
      base &gt;= 4.8
    , containers &gt;= 0.6.5.1
    , melby-renderer
    , hspec &gt;=2.0 &amp;&amp; &lt;3.0
    , hspec-expectations &gt;=0.8 &amp;&amp; &lt;0.9
    , hspec-megaparsec
    , megaparsec &gt;= 9.0.1
    , neat-interpolation
</pre></div><div class="org-src-container"><pre class="src src-haskell-cabal" id="nil-42"><span class="org-keyword">executable-stripping</span>: <span class="org-constant">True</span>
<span class="org-keyword">packages</span>:
  ./melby-renderer.cabal
</pre></div>
</div>
</div>

<div id="outline-container-h-Nix" class="outline-5">
<h5 id="h-Nix"><span class="section-number-5">6.5.13.3.</span> Nix</h5>
<div class="outline-text-5" id="text-h-Nix">
<div class="org-src-container"><pre class="src src-nix" id="nil-43"><span class="org-nix-keyword">let</span>
  <span class="org-nix-attribute">sources</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">../../../../package/nix/sources.nix</span>;
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs { };
  <span class="org-nix-attribute">fakeGit</span> = pkgs.writeShellScriptBin <span class="org-string">"git"</span>
  <span class="org-string">''</span>
<span class="org-string">    echo -unknown</span>
<span class="org-string">  ''</span>;
  <span class="org-nix-attribute">files</span> = [
    <span class="org-nix-constant">./LICENSE</span>
    <span class="org-nix-constant">./cabal.project</span>
    <span class="org-nix-constant">./lib</span>
    <span class="org-nix-constant">./lib/MelbyRenderer</span>
    <span class="org-nix-constant">./lib/MelbyRenderer/Colorizer.hs</span>
    <span class="org-nix-constant">./lib/MelbyRenderer/GitVersion.hs</span>
    <span class="org-nix-constant">./lib/MelbyRenderer/Log.hs</span>
    <span class="org-nix-constant">./lib/MelbyRenderer/melby_renderer.proto</span>
    <span class="org-nix-constant">./lib/MelbyRenderer/PathAliases.hs</span>
    <span class="org-nix-constant">./lib/MelbyRenderer/Schema.hs</span>
    <span class="org-nix-constant">./lib/MelbyRenderer/Widgets.hs</span>
    <span class="org-nix-constant">./melby-renderer.cabal</span>
    <span class="org-nix-constant">./melby-renderer.hs</span>
    <span class="org-nix-constant">./melby-renderer.nix</span>
    <span class="org-nix-constant">./stack.yaml</span>
    <span class="org-nix-constant">./stack.yaml.lock</span>
  ];
  <span class="org-nix-attribute">macOS-security</span> =
    <span class="org-comment"># Make `/usr/bin/security` available in `PATH`, which is needed for stack</span>
    <span class="org-comment"># on darwin which calls this binary to find certificates. See</span>
    <span class="org-comment"># https://github.com/tweag/rules_haskell/commit/31171a520f49f263895112678ac93c7ed958ead1.</span>
    pkgs.writeScriptBin <span class="org-string">"security"</span> <span class="org-string">''exec /usr/bin/security "$@"''</span>;
<span class="org-nix-keyword">in</span>

{ ghc }:

pkgs.haskell.lib.buildStackProject {
  <span class="org-nix-keyword">inherit</span> ghc;
  <span class="org-nix-attribute">name</span> = <span class="org-string">"melby-renderer"</span>;
  <span class="org-nix-attribute">src</span> = <span class="org-nix-constant">./.</span>;
  <span class="org-nix-attribute">buildInputs</span> = [
    pkgs.zlib
    fakeGit
  ] ++ pkgs.lib.optionals pkgs.stdenv.isDarwin [pkgs.llvm_12 macOS-security];
}
</pre></div>
</div>
</div>

<div id="outline-container-h-Stack-1" class="outline-5">
<h5 id="h-Stack-1"><span class="section-number-5">6.5.13.4.</span> Stack</h5>
<div class="outline-text-5" id="text-h-Stack-1">
<div class="org-src-container"><pre class="src src-yaml" id="nil-44"><span class="org-variable-name">resolver</span>: lts-18.28
<span class="org-variable-name">allow-newer</span>: <span class="org-constant">true</span>

<span class="org-variable-name">packages</span>:
- .

<span class="org-variable-name">extra-deps</span>:
- compendium-client-0.2.1.1@sha256:cd477438d507273b34b82581ade333921ae997c1618b48af0c1da2a4968623e0,1203
- graphql-1.0.3.0
- http2-2.0.6
- http2-client-0.10.0.0
- http2-client-grpc-0.8.0.0
- http2-grpc-proto3-wire-0.1.0.0
- http2-grpc-types-0.5.0.0
- hw-kafka-conduit-2.7.0
- mu-avro-0.4.0.4@sha256:10e317c633c5152a26e89becba749456b76f70eb640d1c0b2ccdc0e45a7ef5da,2096
- mu-grpc-common-0.4.0.0@sha256:568b5879cd67c0bc0e956d53fb87552bb6d9a6287c5d1b09e2284ed5b04de418,1394
- mu-optics-0.3.0.1@sha256:c3494c71c6300e6a0dcb77c9782481150956e912c1b47fccd69cbb795e461d52,1068
- mu-protobuf-0.4.2.0@sha256:4787a2688abdda107e150736433b61448acdf0b71eb0c174232239b4c143f78b,2119
- mu-rpc-0.5.0.2@sha256:470f5bc372de1b212f625f9e7310cdf82b7fa41ddea03e092fccff0cd9e19db1,1430
- mu-grpc-server-0.5.0.0@sha256:c67bd7c5dcc87e11ec34ac07b4d18fb1f6de036f58db4176274e6826099fe0a8,2749
- mu-schema-0.3.1.2@sha256:c05e58de29d50376638d19dd3357cd3644d39f984664484f3568d5305b3034d9,1933
- stm-containers-1.2
- stm-hamt-1.2.0.7
- tracing-0.0.7.2
- tracing-control-0.0.7.3
- warp-3.3.14
- warp-grpc-0.4.0.1
</pre></div>
</div>
</div>

<div id="outline-container-h-gitignore-3" class="outline-5">
<h5 id="h-gitignore-3"><span class="section-number-5">6.5.13.5.</span> .gitignore</h5>
<div class="outline-text-5" id="text-h-gitignore-3">
<div class="org-src-container"><pre class="src src-gitignore" id="nil-45">melbyr
.stack-work
</pre></div>
</div>
</div>
</div>
</div>
<div id="outline-container-h-Installation" class="outline-3">
<h3 id="h-Installation"><span class="section-number-3">6.6.</span> Installation</h3>
<div class="outline-text-3" id="text-h-Installation">
<p>
We use Nix for both Linux and Mac (via <a href="https://github.com/LnL7/nix-darwin">https://github.com/LnL7/nix-darwin</a>).
</p>
</div>

<div id="outline-container-h-Linux" class="outline-4">
<h4 id="h-Linux"><span class="section-number-4">6.6.1.</span> Linux</h4>
<div class="outline-text-4" id="text-h-Linux">
<div class="org-src-container"><pre class="src src-text" id="nil-46">[Unit]
Description=melby service
After=network.target
StartLimitIntervalSec=0

[Service]
ExecStart=melbyd
Environment=RELEASE_COOKIE=%h/.melby/cookie
Environment=LUA_PATH=%h/.melby/?.lua
EnvironmentFile=%h/.melby/systemd/env
Restart=always
RestartSec=1
Type=simple
</pre></div>
</div>
</div>
</div>

<div id="outline-container-h-Build-system-2" class="outline-3">
<h3 id="h-Build-system-2"><span class="section-number-3">6.7.</span> Build system</h3>
<div class="outline-text-3" id="text-h-Build-system-2">
</div>

<div id="outline-container-h-Elixir-1" class="outline-4">
<h4 id="h-Elixir-1"><span class="section-number-4">6.7.1.</span> Elixir</h4>
<div class="outline-text-4" id="text-h-Elixir-1">
</div>

<div id="outline-container-h-Makefile-3" class="outline-5">
<h5 id="h-Makefile-3"><span class="section-number-5">6.7.1.1.</span> Makefile</h5>
<div class="outline-text-5" id="text-h-Makefile-3">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">daemon/Makefile</label><span class="lilac-caption-link-symbol"><a href="#daemon-Makefile">&#x1f517;</a></span></div><pre class="src src-makefile" id="daemon-Makefile"><span class="org-comment-delimiter"># </span><span class="org-comment">See https://stackoverflow.com/a/73509979/437583 for getting the directory of</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">this Makefile.</span>
<span class="org-variable-name">ROOT_DIR</span> := $(<span class="org-variable-name">dir</span> $(<span class="org-variable-name">realpath</span> $(<span class="org-variable-name">lastword</span> $(<span class="org-variable-name">MAKEFILE_LIST</span>))))
<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Merge these with the env vars already exported in nix-shell.</span>
export <span class="org-variable-name">MELBYR_PATH</span> := $(<span class="org-variable-name">ROOT_DIR</span>)/lib/melbyd/renderer/melbyr
export <span class="org-variable-name">LUA_PATH</span> := $(<span class="org-variable-name">ROOT_DIR</span>)/test/sample/?.lua
export <span class="org-variable-name">MELBY_DIR</span> := $(<span class="org-variable-name">ROOT_DIR</span>)/test/sample

<span class="org-comment-delimiter"># </span><span class="org-comment">Platform. E.g., "Darwin", "Linux".</span>
<span class="org-variable-name">PLATFORM</span> := $(<span class="org-variable-name">shell</span> uname)

<span class="org-makefile-targets">all</span>:
    mix deps.get
<span class="org-makefile-space">    #</span><span class="org-comment-delimiter"> </span><span class="org-comment">Run the command below to install protoc-gen-elixir.</span>
<span class="org-makefile-space">    #</span><span class="org-comment-delimiter"> </span><span class="org-comment">mix escript.install hex protobuf</span>
<span class="org-makefile-space">    #</span><span class="org-comment-delimiter"> </span><span class="org-comment">FIXME: replace with a make eval to remove the repetition</span>
    protoc --elixir_out=plugins=grpc:lib/generated --proto_path=.. ../melby.proto
    protoc --elixir_out=plugins=grpc:lib/generated --proto_path=.. ../melby_client.proto
    protoc --elixir_out=plugins=grpc:lib/generated --proto_path=.. ../melby_daemon.proto
    protoc --elixir_out=plugins=grpc:lib/generated --proto_path=.. ../melby_renderer.proto
<span class="org-makefile-targets">check-deps</span>:
    mix hex.outdated
<span class="org-makefile-targets">update-mix</span>:
    mix deps.update --all
<span class="org-comment-delimiter"># </span><span class="org-comment">We have to run this after running 'mix deps.update --all' in order to</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">sync the dependencies used for building the release version with the</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">dependencies used during development.</span>
<span class="org-makefile-targets">update-mix.nix</span>: update-mix
    mix2nix &gt; mix.nix
<span class="org-makefile-targets">repl</span>: fix-rustler
    iex -S mix
<span class="org-makefile-targets">fix-rustler</span>:
    mkdir -p _build/test/lib/melbyd/priv/native
    mkdir -p _build/dev/lib/melbyd/priv/native
    mkdir -p _build/prod/lib/melbyd/priv/native
ifeq (<span class="org-string">'${</span><span class="org-string"><span class="org-variable-name">PLATFORM</span></span><span class="org-string">}'</span>,<span class="org-string">'Darwin'</span>)
    ln -sf $(<span class="org-variable-name">PWD</span>)/lib/melbyd/nifs/target/debug/deps/libmelbyd_nifs.dylib \
        $(<span class="org-variable-name">PWD</span>)/_build/test/lib/melbyd/priv/native/libmelbyd_nifs.so || true
    ln -sf $(<span class="org-variable-name">PWD</span>)/lib/melbyd/nifs/target/debug/deps/libmelbyd_nifs.dylib \
        $(<span class="org-variable-name">PWD</span>)/_build/dev/lib/melbyd/priv/native/libmelbyd_nifs.so || true
    ln -sf $(<span class="org-variable-name">PWD</span>)/lib/melbyd/nifs/target/debug/deps/libmelbyd_nifs.dylib \
        $(<span class="org-variable-name">PWD</span>)/_build/prod/lib/melbyd/priv/native/libmelbyd_nifs.so || true
else
    ln -sf $(<span class="org-variable-name">PWD</span>)/lib/melbyd/nifs/target/debug/deps/libmelbyd_nifs.so  \
        $(<span class="org-variable-name">PWD</span>)/_build/test/lib/melbyd/priv/native/libmelbyd_nifs.so || true
    ln -sf $(<span class="org-variable-name">PWD</span>)/lib/melbyd/nifs/target/debug/deps/libmelbyd_nifs.so \
        $(<span class="org-variable-name">PWD</span>)/_build/dev/lib/melbyd/priv/native/libmelbyd_nifs.so || true
    ln -sf $(<span class="org-variable-name">PWD</span>)/lib/melbyd/nifs/target/debug/deps/libmelbyd_nifs.so \
        $(<span class="org-variable-name">PWD</span>)/_build/prod/lib/melbyd/priv/native/libmelbyd_nifs.so || true
endif
<span class="org-makefile-targets">PHONY</span>: fix-rustler
<span class="org-makefile-targets">compile-prod</span>: fix-rustler
    <span class="org-variable-name">MIX_ENV</span>=prod mix compile
<span class="org-makefile-targets">compile-dev</span>: fix-rustler
    <span class="org-variable-name">MIX_ENV</span>=dev mix compile
<span class="org-makefile-targets">run-dev</span>: compile-dev
    <span class="org-variable-name">MIX_ENV</span>=dev elixir --sname melbyd-dev -S mix run --no-compile --no-halt
<span class="org-makefile-targets">run-prod</span>: compile-prod
    <span class="org-variable-name">MIX_ENV</span>=prod elixir --sname melbyd-prod -S mix run --no-compile --no-halt
<span class="org-makefile-targets">test</span>: fix-rustler
    mix test
<span class="org-makefile-targets">.PHONY</span>: test
</pre></div></div>
</div>
</div>

<div id="outline-container-h-gitattributes" class="outline-5">
<h5 id="h-gitattributes"><span class="section-number-5">6.7.1.2.</span> gitattributes</h5>
<div class="outline-text-5" id="text-h-gitattributes">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">daemon/.gitattributes</label><span class="lilac-caption-link-symbol"><a href="#daemon--gitattributes">&#x1f517;</a></span></div><pre class="src src-gitattributes" id="daemon--gitattributes">mix.nix diff
lib/melbyd/nifs/Cargo.lock diff
lib/melbyd/nifs/Cargo.toml diff
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Mix-tool-configuration" class="outline-5">
<h5 id="h-Mix-tool-configuration"><span class="section-number-5">6.7.1.3.</span> Mix tool configuration</h5>
<div class="outline-text-5" id="text-h-Mix-tool-configuration">
<div class="org-src-container"><pre class="src src-elixir" id="nil-47"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.MixProject</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Mix.Project</span>

  <span class="org-keyword">def</span> <span class="org-function-name">project</span> <span class="org-keyword">do</span>
    [
      <span class="org-elixir-atom">app:</span> <span class="org-elixir-atom">:melbyd</span>,
      <span class="org-elixir-atom">version:</span> <span class="org-string">"0.1.0"</span>,
      <span class="org-elixir-atom">elixir:</span> <span class="org-string">"~&gt; 1.11"</span>,
      <span class="org-elixir-atom">start_permanent:</span> <span class="org-type">Mix</span>.env() == <span class="org-elixir-atom">:prod</span>,
      <span class="org-elixir-atom">deps:</span> deps(),
      <span class="org-elixir-atom">aliases:</span> aliases()
    ]
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Run "mix help compile.app" to learn about applications.</span>
  <span class="org-keyword">def</span> <span class="org-function-name">application</span> <span class="org-keyword">do</span>
    [
      <span class="org-elixir-atom">extra_applications:</span> [
        <span class="org-elixir-atom">:file_system</span>,
        <span class="org-elixir-atom">:gproc</span>,
        <span class="org-elixir-atom">:logger</span>,
      ],
      <span class="org-elixir-atom">mod:</span> {<span class="org-type">Melbyd.Application</span>, []},
    ]
  <span class="org-keyword">end</span>

  <span class="org-keyword">defp</span> <span class="org-function-name">aliases</span> <span class="org-keyword">do</span>
    [
      <span class="org-elixir-atom">test:</span> [<span class="org-string">"cmd cd lib/melbyd/nifs &amp;&amp; make test"</span>, <span class="org-string">"test"</span>]
    ]
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Run "mix help deps" to learn about dependencies.</span>
  <span class="org-keyword">defp</span> <span class="org-function-name">deps</span> <span class="org-keyword">do</span>
    [
      {<span class="org-elixir-atom">:cachex</span>, <span class="org-string">"~&gt; 3.6"</span>},
      {<span class="org-elixir-atom">:file_system</span>, <span class="org-string">"~&gt; 1.0"</span>},
      {<span class="org-elixir-atom">:gproc</span>, <span class="org-string">"~&gt; 1.0.0"</span>},
      {<span class="org-elixir-atom">:grpc</span>, <span class="org-string">"~&gt; 0.8.0"</span>},
      {<span class="org-elixir-atom">:luerl</span>, <span class="org-string">"~&gt; 1.0"</span>},
      {<span class="org-elixir-atom">:muontrap</span>, <span class="org-string">"~&gt; 1.4.0"</span>},
      {<span class="org-elixir-atom">:phoenix_pubsub</span>, <span class="org-string">"~&gt; 2.0"</span>},
      {<span class="org-elixir-atom">:protobuf</span>, <span class="org-string">"~&gt; 0.12.0"</span>},
      {<span class="org-elixir-atom">:rustler</span>, <span class="org-string">"~&gt; 0.33.0"</span>},
      {<span class="org-elixir-atom">:temp</span>, <span class="org-string">"~&gt; 0.4"</span>},
      {<span class="org-elixir-atom">:timex</span>, <span class="org-string">"~&gt; 3.7"</span>},
      {<span class="org-elixir-atom">:tz</span>, <span class="org-string">"~&gt; 0.26.5"</span>},
      {<span class="org-elixir-atom">:wait_for_it</span>, <span class="org-string">"~&gt; 2.1"</span>}
    ]
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre></div>
</div>
</div>

<div id="outline-container-h-gitignore-4" class="outline-5">
<h5 id="h-gitignore-4"><span class="section-number-5">6.7.1.4.</span> .gitignore</h5>
<div class="outline-text-5" id="text-h-gitignore-4">
<div class="org-src-container"><pre class="src src-gitignore" id="nil-48"># The directory Mix will write compiled artifacts to.
/_build/

# The directory Mix downloads your dependencies sources to.
/deps/

# Files used during testing.
/test/fake_kube_config
</pre></div>
</div>
</div>

<div id="outline-container-h-Formatter" class="outline-5">
<h5 id="h-Formatter"><span class="section-number-5">6.7.1.5.</span> Formatter</h5>
<div class="outline-text-5" id="text-h-Formatter">
<div class="org-src-container"><pre class="src src-elixir" id="nil-49"><span class="org-comment-delimiter"># </span><span class="org-comment">Used by "mix format"</span>
[
  <span class="org-elixir-atom">inputs:</span> [<span class="org-string">"{mix,.formatter}.exs"</span>, <span class="org-string">"{config,lib,test}/**/*.{ex,exs}"</span>]
]
</pre></div>
</div>
</div>

<div id="outline-container-h-protoc-gen-elixir-nix" class="outline-5">
<h5 id="h-protoc-gen-elixir-nix"><span class="section-number-5">6.7.1.6.</span> protoc-gen-elixir.nix</h5>
<div class="outline-text-5" id="text-h-protoc-gen-elixir-nix">
<p>
Sadly the protoc-gen-elixir plugin is not yet packaged in Nixpkgs, so we have to
package it ourselves by writing our own derivation. This allows us to have a
working <code>nix-shell</code> where we can generate Elixir code from <code>*.proto</code> files.
</p>

<div class="org-src-container"><pre class="src src-nix" id="nil-50">{ sources ? <span class="org-nix-builtin">import</span> <span class="org-nix-constant">./nix/sources.nix</span>
, pkgs ? <span class="org-nix-builtin">import</span> sources.nixpkgs {} }:
<span class="org-nix-keyword">let</span>
  <span class="org-nix-attribute">packages</span> = pkgs.beam.packagesWith pkgs.beam.interpreters.erlangR26;
  <span class="org-nix-attribute">mixFodDeps</span> = packages.fetchMixDeps {
    <span class="org-nix-attribute">pname</span> = <span class="org-string">"mix-deps-</span><span class="org-nix-antiquote">${</span>pname<span class="org-nix-antiquote">}</span>";
    <span class="org-nix-keyword">inherit</span> src version;
    <span class="org-nix-attribute">sha256</span> = <span class="org-string">"sha256-9ZHYtxgdvYO8rjVU10OtkJuWNMjpU/4dCX01DO7pu14="</span>;
  };
  <span class="org-nix-attribute">pname</span> = <span class="org-string">"protoc-gen-elixir"</span>;
  <span class="org-nix-attribute">src</span> = pkgs.fetchgit {
    <span class="org-nix-attribute">url</span> = <span class="org-string">"https://github.com/elixir-protobuf/protobuf"</span>;
    <span class="org-nix-attribute">rev</span> = <span class="org-string">"v</span><span class="org-nix-antiquote">${</span>version<span class="org-nix-antiquote">}</span>";
    <span class="org-nix-attribute">sha256</span> = <span class="org-string">"sha256-J9HEISTDda3E2D20Okw3rhpe29W3qATr0rrfUoQ+81I="</span>;
  };
  <span class="org-nix-attribute">version</span> = <span class="org-string">"0.11.0"</span>;
<span class="org-nix-keyword">in</span>
  <span class="org-comment"># FIXME: This is very heavy as it compiles the entire project (which we don't</span>
  <span class="org-comment"># need to do). However this appears to be the only way possible to compile the</span>
  <span class="org-comment"># protoc-gen-elixir escript executable.</span>
  packages.mixRelease {
    <span class="org-nix-keyword">inherit</span> pname src version mixFodDeps;
    <span class="org-nix-attribute">buildPhase</span> = <span class="org-string">''</span>
<span class="org-string">      MIX_ENV=prod mix do escript.build --force</span>
<span class="org-string">    ''</span>;

    <span class="org-nix-attribute">installPhase</span> = <span class="org-string">''</span>
<span class="org-string">      mkdir -p $out/bin</span>
<span class="org-string">      mv protoc-gen-elixir $out/bin</span>
<span class="org-string">    ''</span>;
  }
</pre></div>
</div>
</div>

<div id="outline-container-h-Mix-release" class="outline-5">
<h5 id="h-Mix-release"><span class="section-number-5">6.7.1.7.</span> Mix release</h5>
<div class="outline-text-5" id="text-h-Mix-release">
<p>
We package up <code>melbyd</code> as a standalone "package".
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">daemon/melby-daemon.nix</label><span class="lilac-caption-link-symbol"><a href="#daemon-melby-daemon-nix">&#x1f517;</a></span></div><pre class="src src-nix" id="daemon-melby-daemon-nix">{ sources ? <span class="org-nix-builtin">import</span> <span class="org-nix-constant">../package/nix/sources.nix</span> }:
<span class="org-nix-keyword">let</span>
  <span class="org-comment"># Overlays</span>
  <span class="org-nix-attribute">oxalica-rust-overlay</span> = <span class="org-nix-builtin">import</span> sources.rust-overlay;
  <span class="org-comment"># The final "pkgs" attribute with all the bells and whistles of our overlays.</span>
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs {
    <span class="org-nix-attribute">overlays</span> = [
      oxalica-rust-overlay
    ];
  };
  <span class="org-nix-attribute">systemdAvailable</span> = pkgs.lib.meta.availableOn
    pkgs.stdenv.hostPlatform
    pkgs.systemd;
  <span class="org-nix-attribute">packages</span> = pkgs.beam.packagesWith pkgs.beam.interpreters.erlangR26;
  <span class="org-comment"># FIXME: This appears to result in a SHA mismatch between Linux and Mac. We</span>
  <span class="org-comment"># should probably use mix2nix to download mix dependencies reproducibly, as</span>
  <span class="org-comment"># described in</span>
  <span class="org-comment"># https://github.com/NixOS/nixpkgs/blame/2ea8b001f6ba09cc6eb9a30f4e117cbc3ec5afe2/doc/languages-frameworks/beam.section.md#L79.</span>
  <span class="org-comment">#</span>
  <span class="org-comment"># Hmm but this appears to be the same now since upgrading to 23.11.</span>
  <span class="org-nix-attribute">mixFodDeps</span> = packages.fetchMixDeps {
    <span class="org-nix-attribute">pname</span> = <span class="org-string">"mix-deps-</span><span class="org-nix-antiquote">${</span>pname<span class="org-nix-antiquote">}</span>";
    <span class="org-nix-keyword">inherit</span> src version;
    <span class="org-nix-attribute">sha256</span> = <span class="org-string">"sha256-sNHiSWJgB2bRIt6i3o10EV6HL+SbqsyFoN5RBtHTQ3M="</span>;
  };
  <span class="org-nix-attribute">mixNixDeps</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">./mix.nix</span> {
    <span class="org-nix-attribute">lib</span> = pkgs.lib;
    <span class="org-nix-attribute">beamPackages</span> = pkgs.beamPackages;
  };
  <span class="org-nix-attribute">pname</span> = <span class="org-string">"melby-daemon"</span>;
  <span class="org-comment"># FIXME When this file is eventually upstreamed to Nixpkgs (if we want that),</span>
  <span class="org-comment"># at that point we can start referring to Git tags/releases and use the</span>
  <span class="org-comment"># version string from that instead (and download the tarball/zip, and proceed</span>
  <span class="org-comment"># to build the package).</span>
  <span class="org-nix-attribute">version</span> = <span class="org-string">"0-dev"</span>;
  <span class="org-nix-attribute">src</span> = builtins.path {
    <span class="org-nix-attribute">name</span> = <span class="org-string">"melby-daemon"</span>;
    <span class="org-nix-attribute">path</span> = <span class="org-nix-constant">./.</span>;
    <span class="org-nix-attribute">filter</span> = path: type: builtins.elem (<span class="org-nix-constant">/.</span> + path) files;
  };
  <span class="org-nix-attribute">files</span> = [
    <span class="org-nix-constant">./config</span>
    <span class="org-nix-constant">./config/config.exs</span>
    <span class="org-nix-constant">./config/dev.exs</span>
    <span class="org-nix-constant">./config/prod.exs</span>
    <span class="org-nix-constant">./config/runtime.exs</span>
    <span class="org-nix-constant">./config/test.exs</span>
    <span class="org-nix-constant">./.formatter.exs</span>
    <span class="org-nix-constant">./.gitignore</span>
    <span class="org-nix-constant">./install</span>
    <span class="org-nix-constant">./install/melby.service</span>
    <span class="org-nix-constant">./install/launchctl.sh</span>
    <span class="org-nix-constant">./lib</span>
    <span class="org-nix-constant">./lib/generated</span>
    <span class="org-nix-constant">./lib/generated/melby_client.pb.ex</span>
    <span class="org-nix-constant">./lib/generated/melby_daemon.pb.ex</span>
    <span class="org-nix-constant">./lib/generated/melby.pb.ex</span>
    <span class="org-nix-constant">./lib/generated/melby_renderer.pb.ex</span>
    <span class="org-nix-constant">./lib/melbyd</span>
    <span class="org-nix-constant">./lib/melbyd/router.ex</span>

    <span class="org-nix-constant">./lib/melbyd/nifs</span>
    <span class="org-nix-constant">./lib/melbyd/nifs/Cargo.toml</span>
    <span class="org-nix-constant">./lib/melbyd/nifs/Cargo.lock</span>
    <span class="org-nix-constant">./lib/melbyd/nifs/.gitignore</span>
    <span class="org-nix-constant">./lib/melbyd/nifs/src</span>
    <span class="org-nix-constant">./lib/melbyd/nifs/src/path_shorten.rs</span>
    <span class="org-nix-constant">./lib/melbyd/nifs/src/color.rs</span>
    <span class="org-nix-constant">./lib/melbyd/nifs/src/lib.rs</span>
    <span class="org-nix-constant">./lib/melbyd/nifs/Makefile</span>

    <span class="org-nix-constant">./lib/melbyd/color.ex</span>
    <span class="org-nix-constant">./lib/melbyd/application.ex</span>
    <span class="org-nix-constant">./lib/melbyd/cache.ex</span>
    <span class="org-nix-constant">./lib/melbyd/standard_resource.ex</span>
    <span class="org-nix-constant">./lib/melbyd/view.ex</span>
    <span class="org-nix-constant">./lib/melbyd/grpc.ex</span>
    <span class="org-nix-constant">./lib/melbyd/shell_logger.ex</span>
    <span class="org-nix-constant">./lib/melbyd/lua_api.ex</span>
    <span class="org-nix-constant">./lib/melbyd/nifs.ex</span>
    <span class="org-nix-constant">./lib/melbyd/path.ex</span>
    <span class="org-nix-constant">./lib/melbyd/renderer</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/cabal.project</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/.ghci</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/lib</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/lib/MelbyRenderer</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/lib/MelbyRenderer/melby_renderer.proto</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/lib/MelbyRenderer/Schema.hs</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/lib/MelbyRenderer/GitVersion.hs</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/lib/MelbyRenderer/Log.hs</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/melby-renderer.cabal</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/stack.yaml.lock</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/melby-renderer.hs</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/.gitignore</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/Makefile</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/melby-renderer.nix</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/stack.yaml</span>
    <span class="org-nix-constant">./lib/melbyd/renderer/LICENSE</span>
    <span class="org-nix-constant">./Makefile</span>
    <span class="org-nix-constant">./mix.exs</span>
    <span class="org-nix-constant">./mix.lock</span>
    <span class="org-nix-constant">./test</span>
    <span class="org-nix-constant">./test/test_helper.exs</span>
    <span class="org-nix-constant">./test/sample</span>
    <span class="org-nix-constant">./test/sample/get_pods.gotemplate</span>
    <span class="org-nix-constant">./test/sample/GitFake.lua</span>
    <span class="org-nix-constant">./test/sample/Git.lua</span>
    <span class="org-nix-constant">./test/sample/git_staged_bytes.sh</span>
    <span class="org-nix-constant">./test/sample/KubeCurrentFake.lua</span>
    <span class="org-nix-constant">./test/sample/KubeCurrent.lua</span>
    <span class="org-nix-constant">./test/sample/KubeFake.lua</span>
    <span class="org-nix-constant">./test/sample/Kube.lua</span>
    <span class="org-nix-constant">./test/sample/melby.lua</span>
    <span class="org-nix-constant">./test/melbyd_test.exs</span>
  ];
  <span class="org-nix-attribute">melby</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">../package/build.nix</span>;
  <span class="org-nix-attribute">nifs_ext</span> = <span class="org-nix-keyword">if</span> pkgs.stdenv.isDarwin <span class="org-nix-keyword">then</span> <span class="org-string">"dylib"</span> <span class="org-nix-keyword">else</span> <span class="org-string">"so"</span>;
  <span class="org-comment"># For whatever reason Rustler insists on searching for .so files, even on</span>
  <span class="org-comment"># Darwin. Luckily we can just copy over the generated .dylib files to .so</span>
  <span class="org-comment"># files.</span>
  <span class="org-nix-attribute">nifs_cp_lib_cmd</span> = pkgs.lib.strings.optionalString pkgs.stdenv.isDarwin <span class="org-string">''</span>
<span class="org-string">    cp _build/prod/lib/melbyd/priv/native/libmelbyd_nifs.dylib \</span>
<span class="org-string">       _build/prod/lib/melbyd/priv/native/libmelbyd_nifs.so</span>
<span class="org-string">  ''</span>;
  <span class="org-comment"># We have to manually compile the "mac_listener" binary because the</span>
  <span class="org-comment"># "file_system" Elixir package does not do this automatically. See</span>
  <span class="org-comment"># https://gist.github.com/jbott/2030c133509e7c1db4f41941b5367475.</span>
  <span class="org-nix-attribute">mac_compile_mac_listener_cmd</span> = pkgs.lib.strings.optionalString pkgs.stdenv.isDarwin <span class="org-string">''</span>
<span class="org-string">    clang \</span>
<span class="org-string">      -framework CoreFoundation \</span>
<span class="org-string">      -framework CoreServices \</span>
<span class="org-string">      -Wno-deprecated-declarations deps/file_system/c_src/mac/*.c \</span>
<span class="org-string">      -o $out/bin/mac_listener</span>
<span class="org-string">  ''</span>;
<span class="org-nix-keyword">in</span>
  packages.mixRelease {
    <span class="org-nix-keyword">inherit</span> pname src version mixNixDeps;
    <span class="org-comment">#inherit pname src version mixFodDeps;</span>
    <span class="org-nix-attribute">buildInputs</span> = [
      pkgs.rust-bin.stable.latest.default
      pkgs.rust-analyzer
      melby.melby-nifs
      melby.melby-renderer
    ]
    <span class="org-comment"># FIXME: This part is a copy/paste of shell.nix at the root and should be</span>
    <span class="org-comment"># deduplicated.</span>
    <span class="org-comment"># For file_system on Linux.</span>
    ++ pkgs.lib.optional pkgs.stdenv.isLinux pkgs.inotify-tools
    <span class="org-comment"># For file_system on macOS. See</span>
    <span class="org-comment"># https://elixirforum.com/t/could-not-compile-file-system-watcher-for-mac/17432/10</span>
    <span class="org-comment"># for a discussion about getting a file system watcher working on Mac.</span>
    ++ pkgs.lib.optionals pkgs.stdenv.isDarwin
        (<span class="org-nix-keyword">with</span> pkgs.darwin.apple_sdk.frameworks; [
          CoreFoundation
          CoreServices
          Security
        ]);
    <span class="org-nix-attribute">nativeBuildInputs</span> = [ pkgs.makeWrapper ];
    <span class="org-nix-attribute">LANG</span> = <span class="org-string">"en_US.UTF-8"</span>;
    <span class="org-nix-attribute">LOCALE_ARCHIVE</span> = pkgs.lib.optional pkgs.stdenv.isLinux
      <span class="org-string">"</span><span class="org-nix-antiquote">${</span>pkgs.glibcLocales<span class="org-nix-antiquote">}</span><span class="org-string">/lib/locale/locale-archive"</span>;

    <span class="org-comment"># Install our Rust NIF shared object that was already compiled in a separate</span>
    <span class="org-comment"># Nix package we made (called "melby-nifs"). This is required for Rustler to</span>
    <span class="org-comment"># generate the correct beam bytecode that calls into melbyd_nifs.</span>
    <span class="org-nix-attribute">postConfigure</span> = <span class="org-string">''</span>
<span class="org-string">      echo "extracting melby-nifs"</span>
<span class="org-string">      </span><span class="org-nix-antiquote">${</span>pkgs.zstd<span class="org-nix-antiquote">}</span><span class="org-string">/bin/zstd -d </span><span class="org-nix-antiquote">${</span>melby.melby-nifs<span class="org-nix-antiquote">}</span><span class="org-string">/target.tar.zst --stdout \</span>
<span class="org-string">        | tar -x -C ./lib/melbyd/nifs</span>
<span class="org-string">      mkdir -p _build/prod/lib/melbyd/priv/native</span>
<span class="org-string">      cp lib/melbyd/nifs/target/release/deps/libmelbyd_nifs.</span><span class="org-nix-antiquote">${</span>nifs_ext<span class="org-nix-antiquote">}</span><span class="org-string"> \</span>
<span class="org-string">         _build/prod/lib/melbyd/priv/native</span>
<span class="org-string">      </span><span class="org-nix-antiquote">${</span>nifs_cp_lib_cmd<span class="org-nix-antiquote">}</span>
<span class="org-string">    ''</span>;

    <span class="org-comment"># Make melbyr available as a runtime dependency.</span>
    <span class="org-nix-attribute">postBuild</span> = <span class="org-string">''</span>
<span class="org-string">      mkdir -p $out/bin</span>
<span class="org-string">      cp </span><span class="org-nix-antiquote">${</span>melby.melby-renderer<span class="org-nix-antiquote">}</span><span class="org-string">/bin/melbyr $out/bin</span>
<span class="org-string">      </span><span class="org-nix-antiquote">${</span>mac_compile_mac_listener_cmd<span class="org-nix-antiquote">}</span>
<span class="org-string">    ''</span>;

    <span class="org-comment"># Install</span>
    <span class="org-nix-attribute">postInstall</span> = <span class="org-string">''</span>
<span class="org-string">      mkdir -p $out/share/melby</span>
<span class="org-string">      cp -r $src/test/sample $out/share/melby</span>

<span class="org-string">      if </span><span class="org-nix-antiquote">${</span> pkgs.lib.boolToString systemdAvailable <span class="org-nix-antiquote">}</span><span class="org-string">; then</span>
<span class="org-string">        install -Dm644 $src/install/melby.service \</span>
<span class="org-string">          $out/share/systemd/user/melby.service</span>

<span class="org-string">        # Fix ExecStart path.</span>
<span class="org-string">        substituteInPlace "$out/share/systemd/user/melby.service" \</span>
<span class="org-string">          --replace 'ExecStart=melbyd' "ExecStart=$out/bin/melbyd start"</span>
<span class="org-string">      fi</span>

<span class="org-string">      # Make the autogenerated "melbyd" wrapper script (courtesy of mixRelease)</span>
<span class="org-string">      # source the PATH locations of dependencies, because otherwise if we use</span>
<span class="org-string">      # the script in a bare-bones environment (such as systemd), it will fail</span>
<span class="org-string">      # to find binaries like "readlink" or "cut" (coreutils).</span>
<span class="org-string">      wrapProgram $out/bin/melbyd --prefix PATH : </span><span class="org-nix-antiquote">${</span>pkgs.lib.makeBinPath
        (<span class="org-nix-keyword">with</span> pkgs;
            [
                coreutils
                gawk
                gnugrep
                gnused
            ])<span class="org-nix-antiquote">}</span>
<span class="org-string">    ''</span>;

    <span class="org-comment"># See https://github.com/whitfin/cachex/issues/205 and</span>
    <span class="org-comment"># https://github.com/NixOS/nixpkgs/pull/192472 and</span>
    <span class="org-comment"># https://github.com/erlang/otp/pull/2114. Cachex breaks with "invalid_hook"</span>
    <span class="org-comment"># if you strip binaries and beam files.</span>
    <span class="org-nix-attribute">stripDebug</span> = <span class="org-nix-builtin">false</span>;
  }
</pre></div></div><p>
Build our Rust library (<code>melbyd_nifs</code>).
</p>

<div class="org-src-container"><pre class="src src-nix" id="nil-51">{ sources ? <span class="org-nix-builtin">import</span> <span class="org-nix-constant">../../../../package/nix/sources.nix</span> }:
<span class="org-nix-keyword">let</span>
  <span class="org-nix-attribute">files</span> = [
    <span class="org-nix-constant">./Cargo.toml</span>
    <span class="org-nix-constant">./Cargo.lock</span>
    <span class="org-nix-constant">./.gitignore</span>
    <span class="org-nix-constant">./src</span>
    <span class="org-nix-constant">./src/path_shorten.rs</span>
    <span class="org-nix-constant">./src/color.rs</span>
    <span class="org-nix-constant">./src/lib.rs</span>
    <span class="org-nix-constant">./Makefile</span>
  ];

  <span class="org-nix-attribute">src</span> = builtins.path {
    <span class="org-nix-attribute">name</span> = <span class="org-string">"melby-nifs"</span>;
    <span class="org-nix-attribute">path</span> = <span class="org-nix-constant">./.</span>;
    <span class="org-nix-attribute">filter</span> = path: type: builtins.elem (<span class="org-nix-constant">/.</span> + path) files;
  };
  <span class="org-comment"># Overlays</span>
  <span class="org-nix-attribute">oxalica-rust-overlay</span> = <span class="org-nix-builtin">import</span> sources.rust-overlay;
  <span class="org-comment"># Build rust crates.</span>
  <span class="org-nix-attribute">naersk</span> = pkgs.callPackage sources.naersk {};
  <span class="org-comment"># The final "pkgs" attribute with all the bells and whistles of our overlays.</span>
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs {
    <span class="org-nix-attribute">overlays</span> = [
      oxalica-rust-overlay
    ];
  };
<span class="org-nix-keyword">in</span>
  naersk.buildPackage {
    <span class="org-nix-keyword">inherit</span> src;
    <span class="org-nix-attribute">copyBins</span> = <span class="org-nix-builtin">false</span>;
    <span class="org-nix-attribute">copyTarget</span> = <span class="org-nix-builtin">true</span>;
    <span class="org-comment"># See https://pyo3.rs/v0.14.2/building_and_distribution.html#macos (by way</span>
    <span class="org-comment"># of https://github.com/PyO3/pyo3/issues/1800#issuecomment-1071890916).</span>
    <span class="org-nix-attribute">CARGO_BUILD_RUSTFLAGS</span> = pkgs.lib.optional
      pkgs.stdenv.isDarwin
      <span class="org-string">"-C link-arg=-undefined -C link-arg=dynamic_lookup"</span>;
  }
</pre></div>
</div>
</div>

<div id="outline-container-h-Additional-application-configuration" class="outline-5">
<h5 id="h-Additional-application-configuration"><span class="section-number-5">6.7.1.8.</span> Additional application configuration</h5>
<div class="outline-text-5" id="text-h-Additional-application-configuration">
<div class="org-src-container"><pre class="src src-elixir" id="nil-52"><span class="org-keyword">import</span> <span class="org-type">Config</span>

config <span class="org-elixir-atom">:logger</span>, <span class="org-elixir-atom">:console</span>,
  <span class="org-elixir-atom">format:</span> <span class="org-string">"$time [$level] $metadata $message\n"</span>,
  <span class="org-elixir-atom">metadata:</span> [<span class="org-elixir-atom">:error_code</span>, <span class="org-elixir-atom">:file</span>, <span class="org-elixir-atom">:line</span>, <span class="org-elixir-atom">:mfa</span>, <span class="org-elixir-atom">:pid</span>]

<span class="org-comment-delimiter"># </span><span class="org-comment">Disable truncation of log messages.</span>
config <span class="org-elixir-atom">:logger</span>,
  <span class="org-elixir-atom">truncate:</span> <span class="org-elixir-atom">:infinity</span>

config <span class="org-elixir-atom">:elixir</span>, <span class="org-elixir-atom">:time_zone_database</span>, <span class="org-type">Tz.TimeZoneDatabase</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">This imports config/test.exs when we run unit tests. Otherwise that</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">configuration (used during "mix test", called by "make test") is not used.</span>
import_config <span class="org-string">"</span><span class="org-variable-name">#{config_env()}</span><span class="org-string">.exs"</span>
</pre></div><div class="org-src-container"><pre class="src src-elixir" id="nil-53"><span class="org-comment-delimiter"># </span><span class="org-comment">Stub.</span>
</pre></div><div class="org-src-container"><pre class="src src-elixir" id="nil-54"><span class="org-keyword">import</span> <span class="org-type">Config</span>

config <span class="org-elixir-atom">:logger</span>,
  <span class="org-elixir-atom">backends:</span> [<span class="org-elixir-atom">:console</span>],
  <span class="org-elixir-atom">compile_time_purge_matching:</span> [
    [<span class="org-elixir-atom">level_lower_than:</span> <span class="org-elixir-atom">:info</span>]
  ]
</pre></div><div class="org-src-container"><pre class="src src-elixir" id="nil-55"><span class="org-keyword">import</span> <span class="org-type">Config</span>

config <span class="org-elixir-atom">:melbyd</span>,
  <span class="org-elixir-atom">env:</span> config_env(),
  <span class="org-comment-delimiter"># </span><span class="org-comment">MELBYD_SRS_TTL: Number of ticks (tick about 1 second) to go through (with 0</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">client usage) before exiting. This is a simple way to garbage-collect unused</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">SRS GenServers to prevent unbounded growth.</span>
  <span class="org-elixir-atom">melbyd_srs_ttl:</span> <span class="org-type">System</span>.get_env(<span class="org-string">"MELBYD_SRS_TTL"</span>) || <span class="org-elixir-number">3600</span> * <span class="org-elixir-number">4</span>,
  <span class="org-elixir-atom">melbyd_sps_ttl:</span> <span class="org-type">System</span>.get_env(<span class="org-string">"MELBYD_SLG_TTL"</span>) || <span class="org-elixir-number">3600</span> * <span class="org-elixir-number">4</span>,
  <span class="org-elixir-atom">melbyd_port:</span>
    <span class="org-type">System</span>.get_env(<span class="org-string">"MELBYD_PORT"</span>) ||
      (<span class="org-keyword">if</span> config_env() == <span class="org-elixir-atom">:prod</span> <span class="org-keyword">do</span>
         <span class="org-elixir-number">50051</span>
       <span class="org-keyword">else</span>
         <span class="org-elixir-number">50052</span>
       <span class="org-keyword">end</span>),
  <span class="org-elixir-atom">melbyr_port:</span>
    <span class="org-type">System</span>.get_env(<span class="org-string">"MELBYR_PORT"</span>) ||
      (<span class="org-keyword">if</span> config_env() == <span class="org-elixir-atom">:prod</span> <span class="org-keyword">do</span>
         <span class="org-elixir-number">50055</span>
       <span class="org-keyword">else</span>
         <span class="org-elixir-number">50056</span>
       <span class="org-keyword">end</span>),
  <span class="org-comment-delimiter"># </span><span class="org-comment">Users can set this variable to make melbyd use it directly (useful for</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">testing out development, non-packaged versions of melbyr). In production we</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">would simply expect to run the first "melbyr" binary found on the PATH.</span>
  <span class="org-elixir-atom">melbyr_path:</span> <span class="org-type">System</span>.get_env(<span class="org-string">"MELBYR_PATH"</span>) || <span class="org-string">"melbyr"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Avoid</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">.../latest_remote_poll.txt": read-only file system</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">error with tzdata. Basically tzdata tries to self-update constantly, and it</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">must do this in a writable directory. Currently this defaults to the Nix store</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">for melbyd which is read-only, so we use the ~/.melby/tzdata directory instead.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">The ~/.melby directory is created on application startup.</span>
config <span class="org-elixir-atom">:tzdata</span>, <span class="org-elixir-atom">:data_dir</span>, <span class="org-type">Path</span>.expand(<span class="org-string">"~/.melby/tzdata"</span>)
</pre></div>
</div>
</div>
</div>

<div id="outline-container-h-Rust-NIFs-integration" class="outline-4">
<h4 id="h-Rust-NIFs-integration"><span class="section-number-4">6.7.2.</span> Rust NIFs integration</h4>
<div class="outline-text-4" id="text-h-Rust-NIFs-integration">
<p>
In order to expose our Rust code to Elixir, we have to write some wrappers for
both the Elixir and Rust side.
</p>
</div>

<div id="outline-container-h-Elixir-wrapper" class="outline-5">
<h5 id="h-Elixir-wrapper"><span class="section-number-5">6.7.2.1.</span> Elixir wrapper</h5>
<div class="outline-text-5" id="text-h-Elixir-wrapper">
<div class="org-src-container"><pre class="src src-elixir" id="nil-56"><span class="org-keyword">defmodule</span> <span class="org-type">Melbyd.Nifs</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Rustler</span>,
    <span class="org-elixir-atom">otp_app:</span> <span class="org-elixir-atom">:melbyd</span>,
    <span class="org-elixir-atom">crate:</span> <span class="org-elixir-atom">:melbyd_nifs</span>,
    <span class="org-elixir-atom">path:</span> <span class="org-string">"lib/melbyd/nifs"</span>,
    <span class="org-elixir-atom">skip_compilation?:</span> <span class="org-elixir-atom">true</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">When your NIFs are loaded, they will override these functions.</span>
  <span class="org-keyword">def</span> <span class="org-function-name">path_shorten</span>(<span class="org-comment">_path</span>, <span class="org-comment">_aliases</span>, <span class="org-comment">_env_vars</span>, <span class="org-comment">_shorten_threshold</span>),
    <span class="org-elixir-atom">do:</span> <span class="org-elixir-atom">:erlang</span>.nif_error(<span class="org-elixir-atom">:nif_not_loaded</span>)

  <span class="org-keyword">def</span> <span class="org-function-name">parse_color</span>(<span class="org-comment">_color_str</span>), <span class="org-elixir-atom">do:</span> <span class="org-elixir-atom">:erlang</span>.nif_error(<span class="org-elixir-atom">:nif_not_loaded</span>)
<span class="org-keyword">end</span>
</pre></div>
</div>
</div>

<div id="outline-container-h-Rust-wrapper" class="outline-5">
<h5 id="h-Rust-wrapper"><span class="section-number-5">6.7.2.2.</span> Rust wrapper</h5>
<div class="outline-text-5" id="text-h-Rust-wrapper">
<div class="org-src-container"><pre class="src src-rust" id="nil-57"><span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">color</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">path_shorten</span>;

<span class="org-preprocessor">#[cfg(feature = </span><span class="org-string">"elixir_support"</span><span class="org-preprocessor">)]</span>
<span class="org-constant">rustler</span>::<span class="org-preprocessor">init!</span>(
    <span class="org-string">"Elixir.Melbyd.Nifs"</span>,
    [
        <span class="org-constant">path_shorten</span>::path_shorten,
        <span class="org-constant">color</span>::parse_color,
    ]
);
</pre></div>
</div>
</div>

<div id="outline-container-h-Boilerplate-3" class="outline-5">
<h5 id="h-Boilerplate-3"><span class="section-number-5">6.7.2.3.</span> Boilerplate</h5>
<div class="outline-text-5" id="text-h-Boilerplate-3">
</div>

<div id="outline-container-h-Makefile-4" class="outline-6">
<h6 id="h-Makefile-4"><span class="section-number-6">6.7.2.3.1.</span> Makefile</h6>
<div class="outline-text-6" id="text-h-Makefile-4">
<div class="org-src-container"><pre class="src src-makefile" id="nil-58"><span class="org-makefile-targets">test</span>:
    cargo test
</pre></div>
</div>
</div>

<div id="outline-container-h-Cargo" class="outline-6">
<h6 id="h-Cargo"><span class="section-number-6">6.7.2.3.2.</span> Cargo</h6>
<div class="outline-text-6" id="text-h-Cargo">
<div class="org-src-container"><pre class="src src-makefile" id="nil-59">[package]
<span class="org-variable-name">name</span> = <span class="org-string">"melbyd_nifs"</span>
<span class="org-variable-name">version</span> = <span class="org-string">"0.1.0"</span>
<span class="org-variable-name">authors</span> = []
<span class="org-variable-name">edition</span> = <span class="org-string">"2018"</span>

[lib]
<span class="org-variable-name">name</span> = <span class="org-string">"melbyd_nifs"</span>
<span class="org-variable-name">path</span> = <span class="org-string">"src/lib.rs"</span>
<span class="org-variable-name">crate-type</span> = [<span class="org-string">"cdylib"</span>, <span class="org-string">"lib"</span>]

[dependencies]
<span class="org-variable-name">csscolorparser</span> = <span class="org-string">"0.6.2"</span>
<span class="org-variable-name">envsubst</span> = <span class="org-string">"0.2.1"</span>
<span class="org-variable-name">serde</span> = { version = <span class="org-string">"1.0"</span>, features = [<span class="org-string">"derive"</span>] }
<span class="org-variable-name">serde_json</span> = <span class="org-string">"1.0"</span>
<span class="org-variable-name">rustler</span> = { version = <span class="org-string">"0.31.0"</span>, optional = true }

[features]
<span class="org-variable-name">default</span> = [<span class="org-string">"elixir_support"</span>]
<span class="org-variable-name">elixir_support</span> = [<span class="org-string">"dep:rustler"</span>]
</pre></div>
</div>
</div>

<div id="outline-container-h-gitignore-5" class="outline-6">
<h6 id="h-gitignore-5"><span class="section-number-6">6.7.2.3.3.</span> .gitignore</h6>
<div class="outline-text-6" id="text-h-gitignore-5">
<p>
We ignore Cargo.lock for libraries. See
<a href="https://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries">https://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries</a>.
</p>

<div class="org-src-container"><pre class="src src-gitignore" id="nil-60">/target
Cargo.lock
</pre></div>
</div>
</div>
</div>
</div>

<div id="outline-container-h-Haskell--melbyr" class="outline-4">
<h4 id="h-Haskell--melbyr"><span class="section-number-4">6.7.3.</span> Haskell (melbyr)</h4>
<div class="outline-text-4" id="text-h-Haskell--melbyr">
<p>
See (FIXME: add link) for the build system for melbyr.
</p>
</div>

<div id="outline-container-h-Set-up-GHCi-environment" class="outline-5">
<h5 id="h-Set-up-GHCi-environment"><span class="section-number-5">6.7.3.1.</span> Set up GHCi environment</h5>
<div class="outline-text-5" id="text-h-Set-up-GHCi-environment">
<p>
These are development defaults for interacting with GHCi.
</p>

<div class="org-src-container"><pre class="src src-text" id="nil-61">:set -XOverloadedStrings
</pre></div>
</div>
</div>
</div>
</div>

<div id="outline-container-h-Tests-1" class="outline-3">
<h3 id="h-Tests-1"><span class="section-number-3">6.8.</span> Tests</h3>
<div class="outline-text-3" id="text-h-Tests-1">
<p>
This probably should be in a separate file, as it requires a pretty big context
switch.
</p>

<div class="org-src-container"><pre class="src src-elixir" id="nil-62"><span class="org-comment-delimiter"># </span><span class="org-comment">Instead of printing logs, capture them. Only print them for tests that fail.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">See https://hashrocket.com/blog/posts/silence-logger-messages-in-exunit.</span>
<span class="org-type">ExUnit</span>.start(<span class="org-elixir-atom">capture_log:</span> <span class="org-elixir-atom">true</span>)
</pre></div>
</div>
</div>
</div>
</div>
</body>
</html>
