# Copyright 2024 Linus Arver
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#+title: melby-client (Rust)
#+PROPERTY: header-args :noweb no-export

* Code overview

While the Haskell client above does work, the [[https://github.com/higherkindness/mu-haskell][=mu-haskell=]] library it depends on
appears to be abandoned. So we need a backup plan in case that library does turn
out to be abandoned forever.

Here we use Rust to build an equivalent client. We start with =Cargo.toml= for
defining dependencies.

See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html.

#+name: rust-client-Cargo.toml
#+caption: Cargo.toml for client-rust
#+begin_src toml :tangle client-rust/Cargo.toml
[package]
name = "melbyc-rust"
description = "melby client, written in Rust"
version = "0.1.0"
edition = "2021"

[dependencies]
tonic = "0.11"
tokio = { version = "1.0", features = ["macros", "rt-multi-thread"] }
prost = "0.12"
clap = { version = "4.5.4", features = ["derive"]}
config = { version = "0.14", features = ["yaml"]}

[build-dependencies]
tonic-build = "0.11"

[[bin]]
name = "melbyc-rust"
path = "src/main.rs"

[profile.release]
# Strip all symbols.
strip = true
#+end_src

And here's the =.gitignore= for this client.

#+begin_src text :tangle client-rust/.gitignore
.cargo

target
#+end_src

Here's the =Makefile= for building and testing.

#+begin_src makefile :tangle client-rust/Makefile
build_dev:
	cargo build
.PHONY: build_dev

build_prod:
	cargo build --release
.PHONY: build_prod

test:
	cargo test
.PHONY: test
#+end_src

Here's the file for protobuf code generation. The =build.rs= name is a special
name that Cargo recognizes automatically.

#+name: build.rs
#+caption: build.rs for client-rust
#+begin_src rust :tangle client-rust/build.rs
use std::error::Error;

fn main() -> Result<(), Box<dyn Error>> {
    tonic_build::compile_protos("proto/melby_client.proto")?;
    tonic_build::configure()
    .build_server(false)
    .out_dir("src/grpc_generated")  // you can change the generated code's location
    .compile(
        &["proto/melby_client.proto"],
        &["proto"], // specify the root location to search proto dependencies
    ).unwrap();

    Ok(())
}
#+end_src

The code above generates =src/grpc_generated/melby_client.rs=. In order to
import it as a module, we have to export it as part of the =grpc_generated=
package. We do that below.

#+name: mod.rs
#+caption: mod.rs for generated code
#+begin_src rust :tangle client-rust/src/grpc_generated/mod.rs
pub mod melby_client;
#+end_src

** Main function

#+name: rust-client-main.rs
#+caption: main.rs for client-rust
#+begin_src rust :tangle client-rust/src/main.rs
use std::collections::HashMap;
use std::error::Error;
use std::path::PathBuf;
use clap::{Parser, Subcommand};

pub mod grpc_generated;
use grpc_generated::melby_client::view_client::ViewClient;
use grpc_generated::melby_client::ViewRequest;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Optional name to operate on
    name: Option<String>,

    /// Sets a custom config file
    #[arg(short, long, value_name = "FILE")]
    config: Option<PathBuf>,

    /// Turn debugging information on
    #[arg(short, long, action = clap::ArgAction::Count)]
    debug: u8,

    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// does testing things
    Test {
        /// lists test values
        #[arg(short, long)]
        list: bool,
    },
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();

    // You can check the value provided by positional arguments, or option arguments
    if let Some(name) = cli.name.as_deref() {
        println!("Value for name: {name}");
    }

    if let Some(config_path) = cli.config.as_deref() {
        println!("Value for config: {}", config_path.display());
    }

    // You can see how many times a particular flag or argument occurred
    // Note, only flags can have multiple occurrences
    match cli.debug {
        0 => println!("Debug mode is off"),
        1 => println!("Debug mode is kind of on"),
        2 => println!("Debug mode is on"),
        _ => println!("Don't be crazy"),
    }

    // You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    match &cli.command {
        Some(Commands::Test { list }) => {
            if *list {
                println!("Printing testing lists...");
            } else {
                println!("Not printing testing lists...");
            }
        }
        None => {}
    }

    // FIXME: allow setting the URL as an option
    let url = "http://[::1]:50051";
    let mut client = ViewClient::connect(url).await?;

    // FIXME: allow setting these values as options. ENV vars should be slurped
    // up from the environment. Instead of slurping up everything, only slurp up
    // an "allowlist" of known ENV vars we want to feed into the server. This
    // allowlist could be defined in settings.yml or even as an additive list of
    // flags. We could do the additive list of flags first and then move to
    // settings.yml in the future if there are just too many flags.
    let mut env_vars: HashMap<String, String> = HashMap::new();
    let req = ViewRequest {
        config_path: "".to_string(),
        config: "".to_string(),
        env_vars: env_vars,
        shell_pid: "".to_string(),
    };

    let request = tonic::Request::new(req);
    let response = client.get_view(request).await?;

    println!("Response: {:?}", response.get_ref().view);

    Ok(())
}
#+end_src
